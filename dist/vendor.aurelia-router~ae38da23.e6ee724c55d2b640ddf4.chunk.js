(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-router~ae38da23"],{

/***/ "4ysu":
/*!***************************************************************************!*\
  !*** ./node_modules/aurelia-router/dist/native-modules/aurelia-router.js ***!
  \***************************************************************************/
/*! exports provided: ActivateNextStep, AppRouter, BuildNavigationPlanStep, CanActivateNextStep, CanDeactivatePreviousStep, CommitChangesStep, DeactivatePreviousStep, LoadRouteStep, NavModel, NavigationInstruction, Pipeline, PipelineProvider, PipelineSlotName, PipelineStatus, Redirect, RedirectToRoute, RouteLoader, Router, RouterConfiguration, RouterEvent, activationStrategy, isNavigationCommand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivateNextStep\", function() { return ActivateNextStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AppRouter\", function() { return AppRouter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuildNavigationPlanStep\", function() { return BuildNavigationPlanStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanActivateNextStep\", function() { return CanActivateNextStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanDeactivatePreviousStep\", function() { return CanDeactivatePreviousStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommitChangesStep\", function() { return CommitChangesStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeactivatePreviousStep\", function() { return DeactivatePreviousStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadRouteStep\", function() { return LoadRouteStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavModel\", function() { return NavModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationInstruction\", function() { return NavigationInstruction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pipeline\", function() { return Pipeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipelineProvider\", function() { return PipelineProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipelineSlotName\", function() { return PipelineSlotName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipelineStatus\", function() { return PipelineStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Redirect\", function() { return Redirect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedirectToRoute\", function() { return RedirectToRoute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteLoader\", function() { return RouteLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return Router; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterConfiguration\", function() { return RouterConfiguration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterEvent\", function() { return RouterEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"activationStrategy\", function() { return activationStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNavigationCommand\", function() { return isNavigationCommand; });\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-dependency-injection */ \"3U8n\");\n/* harmony import */ var aurelia_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-history */ \"eP1p\");\n/* harmony import */ var aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-route-recognizer */ \"0esZ\");\n/* harmony import */ var aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-event-aggregator */ \"aurelia-event-aggregator\");\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\r\n * Class used to represent an instruction during a navigation.\r\n */\r\nvar NavigationInstruction = /** @class */ (function () {\r\n    function NavigationInstruction(init) {\r\n        /**\r\n         * Current built viewport plan of this nav instruction\r\n         */\r\n        this.plan = null;\r\n        this.options = {};\r\n        Object.assign(this, init);\r\n        this.params = this.params || {};\r\n        this.viewPortInstructions = {};\r\n        var ancestorParams = [];\r\n        var current = this;\r\n        do {\r\n            var currentParams = Object.assign({}, current.params);\r\n            if (current.config && current.config.hasChildRouter) {\r\n                // remove the param for the injected child route segment\r\n                delete currentParams[current.getWildCardName()];\r\n            }\r\n            ancestorParams.unshift(currentParams);\r\n            current = current.parentInstruction;\r\n        } while (current);\r\n        var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));\r\n        this.lifecycleArgs = [allParams, this.config, this];\r\n    }\r\n    /**\r\n     * Gets an array containing this instruction and all child instructions for the current navigation.\r\n     */\r\n    NavigationInstruction.prototype.getAllInstructions = function () {\r\n        var instructions = [this];\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        for (var key in viewPortInstructions) {\r\n            var childInstruction = viewPortInstructions[key].childNavigationInstruction;\r\n            if (childInstruction) {\r\n                instructions.push.apply(instructions, childInstruction.getAllInstructions());\r\n            }\r\n        }\r\n        return instructions;\r\n    };\r\n    /**\r\n     * Gets an array containing the instruction and all child instructions for the previous navigation.\r\n     * Previous instructions are no longer available after navigation completes.\r\n     */\r\n    NavigationInstruction.prototype.getAllPreviousInstructions = function () {\r\n        return this.getAllInstructions().map(function (c) { return c.previousInstruction; }).filter(function (c) { return c; });\r\n    };\r\n    NavigationInstruction.prototype.addViewPortInstruction = function (nameOrInitOptions, strategy, moduleId, component) {\r\n        var viewPortInstruction;\r\n        var viewPortName = typeof nameOrInitOptions === 'string' ? nameOrInitOptions : nameOrInitOptions.name;\r\n        var lifecycleArgs = this.lifecycleArgs;\r\n        var config = Object.assign({}, lifecycleArgs[1], { currentViewPort: viewPortName });\r\n        if (typeof nameOrInitOptions === 'string') {\r\n            viewPortInstruction = {\r\n                name: nameOrInitOptions,\r\n                strategy: strategy,\r\n                moduleId: moduleId,\r\n                component: component,\r\n                childRouter: component.childRouter,\r\n                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]\r\n            };\r\n        }\r\n        else {\r\n            viewPortInstruction = {\r\n                name: viewPortName,\r\n                strategy: nameOrInitOptions.strategy,\r\n                component: nameOrInitOptions.component,\r\n                moduleId: nameOrInitOptions.moduleId,\r\n                childRouter: nameOrInitOptions.component.childRouter,\r\n                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]\r\n            };\r\n        }\r\n        return this.viewPortInstructions[viewPortName] = viewPortInstruction;\r\n    };\r\n    /**\r\n     * Gets the name of the route pattern's wildcard parameter, if applicable.\r\n     */\r\n    NavigationInstruction.prototype.getWildCardName = function () {\r\n        // todo: potential issue, or at least unsafe typings\r\n        var configRoute = this.config.route;\r\n        var wildcardIndex = configRoute.lastIndexOf('*');\r\n        return configRoute.substr(wildcardIndex + 1);\r\n    };\r\n    /**\r\n     * Gets the path and query string created by filling the route\r\n     * pattern's wildcard parameter with the matching param.\r\n     */\r\n    NavigationInstruction.prototype.getWildcardPath = function () {\r\n        var wildcardName = this.getWildCardName();\r\n        var path = this.params[wildcardName] || '';\r\n        var queryString = this.queryString;\r\n        if (queryString) {\r\n            path += '?' + queryString;\r\n        }\r\n        return path;\r\n    };\r\n    /**\r\n     * Gets the instruction's base URL, accounting for wildcard route parameters.\r\n     */\r\n    NavigationInstruction.prototype.getBaseUrl = function () {\r\n        var _this = this;\r\n        var $encodeURI = encodeURI;\r\n        var fragment = decodeURI(this.fragment);\r\n        if (fragment === '') {\r\n            var nonEmptyRoute = this.router.routes.find(function (route) {\r\n                return route.name === _this.config.name &&\r\n                    route.route !== '';\r\n            });\r\n            if (nonEmptyRoute) {\r\n                fragment = nonEmptyRoute.route;\r\n            }\r\n        }\r\n        if (!this.params) {\r\n            return $encodeURI(fragment);\r\n        }\r\n        var wildcardName = this.getWildCardName();\r\n        var path = this.params[wildcardName] || '';\r\n        if (!path) {\r\n            return $encodeURI(fragment);\r\n        }\r\n        return $encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));\r\n    };\r\n    /**\r\n     * Finalize a viewport instruction\r\n     * @internal\r\n     */\r\n    NavigationInstruction.prototype._commitChanges = function (waitToSwap) {\r\n        var _this = this;\r\n        var router = this.router;\r\n        router.currentInstruction = this;\r\n        var previousInstruction = this.previousInstruction;\r\n        if (previousInstruction) {\r\n            previousInstruction.config.navModel.isActive = false;\r\n        }\r\n        this.config.navModel.isActive = true;\r\n        router.refreshNavigation();\r\n        var loads = [];\r\n        var delaySwaps = [];\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        var _loop_1 = function (viewPortName) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var viewPort = router.viewPorts[viewPortName];\r\n            if (!viewPort) {\r\n                throw new Error(\"There was no router-view found in the view for \" + viewPortInstruction.moduleId + \".\");\r\n            }\r\n            var childNavInstruction = viewPortInstruction.childNavigationInstruction;\r\n            if (viewPortInstruction.strategy === \"replace\" /* Replace */) {\r\n                if (childNavInstruction && childNavInstruction.parentCatchHandler) {\r\n                    loads.push(childNavInstruction._commitChanges(waitToSwap));\r\n                }\r\n                else {\r\n                    if (waitToSwap) {\r\n                        delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });\r\n                    }\r\n                    loads.push(viewPort\r\n                        .process(viewPortInstruction, waitToSwap)\r\n                        .then(function () { return childNavInstruction\r\n                        ? childNavInstruction._commitChanges(waitToSwap)\r\n                        : Promise.resolve(); }));\r\n                }\r\n            }\r\n            else {\r\n                if (childNavInstruction) {\r\n                    loads.push(childNavInstruction._commitChanges(waitToSwap));\r\n                }\r\n            }\r\n        };\r\n        for (var viewPortName in viewPortInstructions) {\r\n            _loop_1(viewPortName);\r\n        }\r\n        return Promise\r\n            .all(loads)\r\n            .then(function () {\r\n            delaySwaps.forEach(function (x) { return x.viewPort.swap(x.viewPortInstruction); });\r\n            return null;\r\n        })\r\n            .then(function () { return prune(_this); });\r\n    };\r\n    /**@internal */\r\n    NavigationInstruction.prototype._updateTitle = function () {\r\n        var router = this.router;\r\n        var title = this._buildTitle(router.titleSeparator);\r\n        if (title) {\r\n            router.history.setTitle(title);\r\n        }\r\n    };\r\n    /**@internal */\r\n    NavigationInstruction.prototype._buildTitle = function (separator) {\r\n        if (separator === void 0) { separator = ' | '; }\r\n        var title = '';\r\n        var childTitles = [];\r\n        var navModelTitle = this.config.navModel.title;\r\n        var instructionRouter = this.router;\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        if (navModelTitle) {\r\n            title = instructionRouter.transformTitle(navModelTitle);\r\n        }\r\n        for (var viewPortName in viewPortInstructions) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var child_nav_instruction = viewPortInstruction.childNavigationInstruction;\r\n            if (child_nav_instruction) {\r\n                var childTitle = child_nav_instruction._buildTitle(separator);\r\n                if (childTitle) {\r\n                    childTitles.push(childTitle);\r\n                }\r\n            }\r\n        }\r\n        if (childTitles.length) {\r\n            title = childTitles.join(separator) + (title ? separator : '') + title;\r\n        }\r\n        if (instructionRouter.title) {\r\n            title += (title ? separator : '') + instructionRouter.transformTitle(instructionRouter.title);\r\n        }\r\n        return title;\r\n    };\r\n    return NavigationInstruction;\r\n}());\r\nvar prune = function (instruction) {\r\n    instruction.previousInstruction = null;\r\n    instruction.plan = null;\r\n};\n\n/**\r\n* Class for storing and interacting with a route's navigation settings.\r\n*/\r\nvar NavModel = /** @class */ (function () {\r\n    function NavModel(router, relativeHref) {\r\n        /**\r\n        * True if this nav item is currently active.\r\n        */\r\n        this.isActive = false;\r\n        /**\r\n        * The title.\r\n        */\r\n        this.title = null;\r\n        /**\r\n        * This nav item's absolute href.\r\n        */\r\n        this.href = null;\r\n        /**\r\n        * This nav item's relative href.\r\n        */\r\n        this.relativeHref = null;\r\n        /**\r\n        * Data attached to the route at configuration time.\r\n        */\r\n        this.settings = {};\r\n        /**\r\n        * The route config.\r\n        */\r\n        this.config = null;\r\n        this.router = router;\r\n        this.relativeHref = relativeHref;\r\n    }\r\n    /**\r\n    * Sets the route's title and updates document.title.\r\n    *  If the a navigation is in progress, the change will be applied\r\n    *  to document.title when the navigation completes.\r\n    *\r\n    * @param title The new title.\r\n    */\r\n    NavModel.prototype.setTitle = function (title) {\r\n        this.title = title;\r\n        if (this.isActive) {\r\n            this.router.updateTitle();\r\n        }\r\n    };\r\n    return NavModel;\r\n}());\n\nfunction _normalizeAbsolutePath(path, hasPushState, absolute) {\r\n    if (absolute === void 0) { absolute = false; }\r\n    if (!hasPushState && path[0] !== '#') {\r\n        path = '#' + path;\r\n    }\r\n    if (hasPushState && absolute) {\r\n        path = path.substring(1, path.length);\r\n    }\r\n    return path;\r\n}\r\nfunction _createRootedPath(fragment, baseUrl, hasPushState, absolute) {\r\n    if (isAbsoluteUrl.test(fragment)) {\r\n        return fragment;\r\n    }\r\n    var path = '';\r\n    if (baseUrl.length && baseUrl[0] !== '/') {\r\n        path += '/';\r\n    }\r\n    path += baseUrl;\r\n    if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {\r\n        path += '/';\r\n    }\r\n    if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {\r\n        path = path.substring(0, path.length - 1);\r\n    }\r\n    return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);\r\n}\r\nfunction _resolveUrl(fragment, baseUrl, hasPushState) {\r\n    if (isRootedPath.test(fragment)) {\r\n        return _normalizeAbsolutePath(fragment, hasPushState);\r\n    }\r\n    return _createRootedPath(fragment, baseUrl, hasPushState);\r\n}\r\nfunction _ensureArrayWithSingleRoutePerConfig(config) {\r\n    var routeConfigs = [];\r\n    if (Array.isArray(config.route)) {\r\n        for (var i = 0, ii = config.route.length; i < ii; ++i) {\r\n            var current = Object.assign({}, config);\r\n            current.route = config.route[i];\r\n            routeConfigs.push(current);\r\n        }\r\n    }\r\n    else {\r\n        routeConfigs.push(Object.assign({}, config));\r\n    }\r\n    return routeConfigs;\r\n}\r\nvar isRootedPath = /^#?\\//;\r\nvar isAbsoluteUrl = /^([a-z][a-z0-9+\\-.]*:)?\\/\\//i;\n\n/**\r\n * Class used to configure a [[Router]] instance.\r\n *\r\n * @constructor\r\n */\r\nvar RouterConfiguration = /** @class */ (function () {\r\n    function RouterConfiguration() {\r\n        this.instructions = [];\r\n        this.options = {};\r\n        this.pipelineSteps = [];\r\n    }\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s navigation pipeline.\r\n     *\r\n     * @param name The name of the pipeline slot to insert the step into.\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPipelineStep = function (name, step) {\r\n        if (step === null || step === undefined) {\r\n            throw new Error('Pipeline step cannot be null or undefined.');\r\n        }\r\n        this.pipelineSteps.push({ name: name, step: step });\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s authorize pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addAuthorizeStep = function (step) {\r\n        return this.addPipelineStep(\"authorize\" /* Authorize */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s preActivate pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPreActivateStep = function (step) {\r\n        return this.addPipelineStep(\"preActivate\" /* PreActivate */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s preRender pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPreRenderStep = function (step) {\r\n        return this.addPipelineStep(\"preRender\" /* PreRender */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s postRender pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPostRenderStep = function (step) {\r\n        return this.addPipelineStep(\"postRender\" /* PostRender */, step);\r\n    };\r\n    /**\r\n     * Configures a route that will be used if there is no previous location available on navigation cancellation.\r\n     *\r\n     * @param fragment The URL fragment to use as the navigation destination.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.fallbackRoute = function (fragment) {\r\n        this._fallbackRoute = fragment;\r\n        return this;\r\n    };\r\n    /**\r\n     * Maps one or more routes to be registered with the router.\r\n     *\r\n     * @param route The [[RouteConfig]] to map, or an array of [[RouteConfig]] to map.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.map = function (route) {\r\n        var _this = this;\r\n        if (Array.isArray(route)) {\r\n            route.forEach(function (r) { return _this.map(r); });\r\n            return this;\r\n        }\r\n        return this.mapRoute(route);\r\n    };\r\n    /**\r\n     * Configures defaults to use for any view ports.\r\n     *\r\n     * @param viewPortConfig a view port configuration object to use as a\r\n     *  default, of the form { viewPortName: { moduleId } }.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.useViewPortDefaults = function (viewPortConfig) {\r\n        this.viewPortDefaults = viewPortConfig;\r\n        return this;\r\n    };\r\n    /**\r\n     * Maps a single route to be registered with the router.\r\n     *\r\n     * @param route The [[RouteConfig]] to map.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.mapRoute = function (config) {\r\n        this.instructions.push(function (router) {\r\n            var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\r\n            var navModel;\r\n            for (var i = 0, ii = routeConfigs.length; i < ii; ++i) {\r\n                var routeConfig = routeConfigs[i];\r\n                routeConfig.settings = routeConfig.settings || {};\r\n                if (!navModel) {\r\n                    navModel = router.createNavModel(routeConfig);\r\n                }\r\n                router.addRoute(routeConfig, navModel);\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers an unknown route handler to be run when the URL fragment doesn't match any registered routes.\r\n     *\r\n     * @param config A string containing a moduleId to load, or a [[RouteConfig]], or a function that takes the\r\n     *  [[NavigationInstruction]] and selects a moduleId to load.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.mapUnknownRoutes = function (config) {\r\n        this.unknownRouteConfig = config;\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies the current configuration to the specified [[Router]].\r\n     *\r\n     * @param router The [[Router]] to apply the configuration to.\r\n     */\r\n    RouterConfiguration.prototype.exportToRouter = function (router) {\r\n        var instructions = this.instructions;\r\n        for (var i = 0, ii = instructions.length; i < ii; ++i) {\r\n            instructions[i](router);\r\n        }\r\n        var _a = this, title = _a.title, titleSeparator = _a.titleSeparator, unknownRouteConfig = _a.unknownRouteConfig, _fallbackRoute = _a._fallbackRoute, viewPortDefaults = _a.viewPortDefaults;\r\n        if (title) {\r\n            router.title = title;\r\n        }\r\n        if (titleSeparator) {\r\n            router.titleSeparator = titleSeparator;\r\n        }\r\n        if (unknownRouteConfig) {\r\n            router.handleUnknownRoutes(unknownRouteConfig);\r\n        }\r\n        if (_fallbackRoute) {\r\n            router.fallbackRoute = _fallbackRoute;\r\n        }\r\n        if (viewPortDefaults) {\r\n            router.useViewPortDefaults(viewPortDefaults);\r\n        }\r\n        Object.assign(router.options, this.options);\r\n        var pipelineSteps = this.pipelineSteps;\r\n        var pipelineStepCount = pipelineSteps.length;\r\n        if (pipelineStepCount) {\r\n            if (!router.isRoot) {\r\n                throw new Error('Pipeline steps can only be added to the root router');\r\n            }\r\n            var pipelineProvider = router.pipelineProvider;\r\n            for (var i = 0, ii = pipelineStepCount; i < ii; ++i) {\r\n                var _b = pipelineSteps[i], name_1 = _b.name, step = _b.step;\r\n                pipelineProvider.addStep(name_1, step);\r\n            }\r\n        }\r\n    };\r\n    return RouterConfiguration;\r\n}());\n\n/**\r\n * The primary class responsible for handling routing and navigation.\r\n */\r\nvar Router = /** @class */ (function () {\r\n    /**\r\n     * @param container The [[Container]] to use when child routers.\r\n     * @param history The [[History]] implementation to delegate navigation requests to.\r\n     */\r\n    function Router(container, history) {\r\n        var _this = this;\r\n        /**\r\n         * The parent router, or null if this instance is not a child router.\r\n         */\r\n        this.parent = null;\r\n        this.options = {};\r\n        /**\r\n         * The defaults used when a viewport lacks specified content\r\n         */\r\n        this.viewPortDefaults = {};\r\n        /**\r\n         * Extension point to transform the document title before it is built and displayed.\r\n         * By default, child routers delegate to the parent router, and the app router\r\n         * returns the title unchanged.\r\n         */\r\n        this.transformTitle = function (title) {\r\n            if (_this.parent) {\r\n                return _this.parent.transformTitle(title);\r\n            }\r\n            return title;\r\n        };\r\n        this.container = container;\r\n        this.history = history;\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.\r\n     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.\r\n     */\r\n    Router.prototype.reset = function () {\r\n        var _this = this;\r\n        this.viewPorts = {};\r\n        this.routes = [];\r\n        this.baseUrl = '';\r\n        this.isConfigured = false;\r\n        this.isNavigating = false;\r\n        this.isExplicitNavigation = false;\r\n        this.isExplicitNavigationBack = false;\r\n        this.isNavigatingFirst = false;\r\n        this.isNavigatingNew = false;\r\n        this.isNavigatingRefresh = false;\r\n        this.isNavigatingForward = false;\r\n        this.isNavigatingBack = false;\r\n        this.couldDeactivate = false;\r\n        this.navigation = [];\r\n        this.currentInstruction = null;\r\n        this.viewPortDefaults = {};\r\n        this._fallbackOrder = 100;\r\n        this._recognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__[\"RouteRecognizer\"]();\r\n        this._childRecognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__[\"RouteRecognizer\"]();\r\n        this._configuredPromise = new Promise(function (resolve) {\r\n            _this._resolveConfiguredPromise = resolve;\r\n        });\r\n    };\r\n    Object.defineProperty(Router.prototype, \"isRoot\", {\r\n        /**\r\n         * Gets a value indicating whether or not this [[Router]] is the root in the router tree. I.e., it has no parent.\r\n         */\r\n        get: function () {\r\n            return !this.parent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Registers a viewPort to be used as a rendering target for activated routes.\r\n     *\r\n     * @param viewPort The viewPort.\r\n     * @param name The name of the viewPort. 'default' if unspecified.\r\n     */\r\n    Router.prototype.registerViewPort = function (viewPort, name) {\r\n        name = name || 'default';\r\n        this.viewPorts[name] = viewPort;\r\n    };\r\n    /**\r\n     * Returns a Promise that resolves when the router is configured.\r\n     */\r\n    Router.prototype.ensureConfigured = function () {\r\n        return this._configuredPromise;\r\n    };\r\n    /**\r\n     * Configures the router.\r\n     *\r\n     * @param callbackOrConfig The [[RouterConfiguration]] or a callback that takes a [[RouterConfiguration]].\r\n     */\r\n    Router.prototype.configure = function (callbackOrConfig) {\r\n        var _this = this;\r\n        this.isConfigured = true;\r\n        var result = callbackOrConfig;\r\n        var config;\r\n        if (typeof callbackOrConfig === 'function') {\r\n            config = new RouterConfiguration();\r\n            result = callbackOrConfig(config);\r\n        }\r\n        return Promise\r\n            .resolve(result)\r\n            .then(function (c) {\r\n            if (c && c.exportToRouter) {\r\n                config = c;\r\n            }\r\n            config.exportToRouter(_this);\r\n            _this.isConfigured = true;\r\n            _this._resolveConfiguredPromise();\r\n        });\r\n    };\r\n    /**\r\n     * Navigates to a new location.\r\n     *\r\n     * @param fragment The URL fragment to use as the navigation destination.\r\n     * @param options The navigation options.\r\n     */\r\n    Router.prototype.navigate = function (fragment, options) {\r\n        if (!this.isConfigured && this.parent) {\r\n            return this.parent.navigate(fragment, options);\r\n        }\r\n        this.isExplicitNavigation = true;\r\n        return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);\r\n    };\r\n    /**\r\n     * Navigates to a new location corresponding to the route and params specified. Equivallent to [[Router.generate]] followed\r\n     * by [[Router.navigate]].\r\n     *\r\n     * @param route The name of the route to use when generating the navigation location.\r\n     * @param params The route parameters to be used when populating the route pattern.\r\n     * @param options The navigation options.\r\n     */\r\n    Router.prototype.navigateToRoute = function (route, params, options) {\r\n        var path = this.generate(route, params);\r\n        return this.navigate(path, options);\r\n    };\r\n    /**\r\n     * Navigates back to the most recent location in history.\r\n     */\r\n    Router.prototype.navigateBack = function () {\r\n        this.isExplicitNavigationBack = true;\r\n        this.history.navigateBack();\r\n    };\r\n    /**\r\n     * Creates a child router of the current router.\r\n     *\r\n     * @param container The [[Container]] to provide to the child router. Uses the current [[Router]]'s [[Container]] if unspecified.\r\n     * @returns {Router} The new child Router.\r\n     */\r\n    Router.prototype.createChild = function (container) {\r\n        var childRouter = new Router(container || this.container.createChild(), this.history);\r\n        childRouter.parent = this;\r\n        return childRouter;\r\n    };\r\n    /**\r\n     * Generates a URL fragment matching the specified route pattern.\r\n     *\r\n     * @param name The name of the route whose pattern should be used to generate the fragment.\r\n     * @param params The route params to be used to populate the route pattern.\r\n     * @param options If options.absolute = true, then absolute url will be generated; otherwise, it will be relative url.\r\n     * @returns {string} A string containing the generated URL fragment.\r\n     */\r\n    Router.prototype.generate = function (nameOrRoute, params, options) {\r\n        if (params === void 0) { params = {}; }\r\n        if (options === void 0) { options = {}; }\r\n        // A child recognizer generates routes for potential child routes. Any potential child route is added\r\n        // to the childRoute property of params for the childRouter to recognize. When generating routes, we\r\n        // use the childRecognizer when childRoute params are available to generate a child router enabled route.\r\n        var recognizer = 'childRoute' in params ? this._childRecognizer : this._recognizer;\r\n        var hasRoute = recognizer.hasRoute(nameOrRoute);\r\n        if (!hasRoute) {\r\n            if (this.parent) {\r\n                return this.parent.generate(nameOrRoute, params, options);\r\n            }\r\n            throw new Error(\"A route with name '\" + nameOrRoute + \"' could not be found. Check that `name: '\" + nameOrRoute + \"'` was specified in the route's config.\");\r\n        }\r\n        var path = recognizer.generate(nameOrRoute, params);\r\n        var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);\r\n        return options.absolute ? \"\" + this.history.getAbsoluteRoot() + rootedPath : rootedPath;\r\n    };\r\n    /**\r\n     * Creates a [[NavModel]] for the specified route config.\r\n     *\r\n     * @param config The route config.\r\n     */\r\n    Router.prototype.createNavModel = function (config) {\r\n        var navModel = new NavModel(this, 'href' in config\r\n            ? config.href\r\n            // potential error when config.route is a string[] ?\r\n            : config.route);\r\n        navModel.title = config.title;\r\n        navModel.order = config.nav;\r\n        navModel.href = config.href;\r\n        navModel.settings = config.settings;\r\n        navModel.config = config;\r\n        return navModel;\r\n    };\r\n    /**\r\n     * Registers a new route with the router.\r\n     *\r\n     * @param config The [[RouteConfig]].\r\n     * @param navModel The [[NavModel]] to use for the route. May be omitted for single-pattern routes.\r\n     */\r\n    Router.prototype.addRoute = function (config, navModel) {\r\n        if (Array.isArray(config.route)) {\r\n            var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\r\n            // the following is wrong. todo: fix this after TS refactoring release\r\n            routeConfigs.forEach(this.addRoute.bind(this));\r\n            return;\r\n        }\r\n        validateRouteConfig(config);\r\n        if (!('viewPorts' in config) && !config.navigationStrategy) {\r\n            config.viewPorts = {\r\n                'default': {\r\n                    moduleId: config.moduleId,\r\n                    view: config.view\r\n                }\r\n            };\r\n        }\r\n        if (!navModel) {\r\n            navModel = this.createNavModel(config);\r\n        }\r\n        this.routes.push(config);\r\n        var path = config.route;\r\n        if (path.charAt(0) === '/') {\r\n            path = path.substr(1);\r\n        }\r\n        var caseSensitive = config.caseSensitive === true;\r\n        var state = this._recognizer.add({\r\n            path: path,\r\n            handler: config,\r\n            caseSensitive: caseSensitive\r\n        });\r\n        if (path) {\r\n            var settings = config.settings;\r\n            delete config.settings;\r\n            var withChild = JSON.parse(JSON.stringify(config));\r\n            config.settings = settings;\r\n            withChild.route = path + \"/*childRoute\";\r\n            withChild.hasChildRouter = true;\r\n            this._childRecognizer.add({\r\n                path: withChild.route,\r\n                handler: withChild,\r\n                caseSensitive: caseSensitive\r\n            });\r\n            withChild.navModel = navModel;\r\n            withChild.settings = config.settings;\r\n            withChild.navigationStrategy = config.navigationStrategy;\r\n        }\r\n        config.navModel = navModel;\r\n        var navigation = this.navigation;\r\n        if ((navModel.order || navModel.order === 0) && navigation.indexOf(navModel) === -1) {\r\n            if ((!navModel.href && navModel.href !== '') && (state.types.dynamics || state.types.stars)) {\r\n                throw new Error('Invalid route config for \"' + config.route + '\" : dynamic routes must specify an \"href:\" to be included in the navigation model.');\r\n            }\r\n            if (typeof navModel.order !== 'number') {\r\n                navModel.order = ++this._fallbackOrder;\r\n            }\r\n            navigation.push(navModel);\r\n            // this is a potential error / inconsistency between browsers\r\n            //\r\n            // MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n            // If compareFunction(a, b) returns 0, leave a and b unchanged with respect to each other,\r\n            // but sorted with respect to all different elements.\r\n            // Note: the ECMAscript standard does not guarantee this behaviour,\r\n            // and thus not all browsers (e.g. Mozilla versions dating back to at least 2003) respect this.\r\n            navigation.sort(function (a, b) { return a.order - b.order; });\r\n        }\r\n    };\r\n    /**\r\n     * Gets a value indicating whether or not this [[Router]] or one of its ancestors has a route registered with the specified name.\r\n     *\r\n     * @param name The name of the route to check.\r\n     */\r\n    Router.prototype.hasRoute = function (name) {\r\n        return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));\r\n    };\r\n    /**\r\n     * Gets a value indicating whether or not this [[Router]] has a route registered with the specified name.\r\n     *\r\n     * @param name The name of the route to check.\r\n     */\r\n    Router.prototype.hasOwnRoute = function (name) {\r\n        return this._recognizer.hasRoute(name);\r\n    };\r\n    /**\r\n     * Register a handler to use when the incoming URL fragment doesn't match any registered routes.\r\n     *\r\n     * @param config The moduleId, or a function that selects the moduleId, or a [[RouteConfig]].\r\n     */\r\n    Router.prototype.handleUnknownRoutes = function (config) {\r\n        var _this = this;\r\n        if (!config) {\r\n            throw new Error('Invalid unknown route handler');\r\n        }\r\n        this.catchAllHandler = function (instruction) {\r\n            return _this\r\n                ._createRouteConfig(config, instruction)\r\n                .then(function (c) {\r\n                instruction.config = c;\r\n                return instruction;\r\n            });\r\n        };\r\n    };\r\n    /**\r\n     * Updates the document title using the current navigation instruction.\r\n     */\r\n    Router.prototype.updateTitle = function () {\r\n        var parentRouter = this.parent;\r\n        if (parentRouter) {\r\n            return parentRouter.updateTitle();\r\n        }\r\n        var currentInstruction = this.currentInstruction;\r\n        if (currentInstruction) {\r\n            currentInstruction._updateTitle();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Updates the navigation routes with hrefs relative to the current location.\r\n     * Note: This method will likely move to a plugin in a future release.\r\n     */\r\n    Router.prototype.refreshNavigation = function () {\r\n        var nav = this.navigation;\r\n        for (var i = 0, length_1 = nav.length; i < length_1; i++) {\r\n            var current = nav[i];\r\n            if (!current.config.href) {\r\n                current.href = _createRootedPath(current.relativeHref, this.baseUrl, this.history._hasPushState);\r\n            }\r\n            else {\r\n                current.href = _normalizeAbsolutePath(current.config.href, this.history._hasPushState);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets the default configuration for the view ports. This specifies how to\r\n     *  populate a view port for which no module is specified. The default is\r\n     *  an empty view/view-model pair.\r\n     */\r\n    Router.prototype.useViewPortDefaults = function ($viewPortDefaults) {\r\n        // a workaround to have strong typings while not requiring to expose interface ViewPortInstruction\r\n        var viewPortDefaults = $viewPortDefaults;\r\n        for (var viewPortName in viewPortDefaults) {\r\n            var viewPortConfig = viewPortDefaults[viewPortName];\r\n            this.viewPortDefaults[viewPortName] = {\r\n                moduleId: viewPortConfig.moduleId\r\n            };\r\n        }\r\n    };\r\n    /**@internal */\r\n    Router.prototype._refreshBaseUrl = function () {\r\n        var parentRouter = this.parent;\r\n        if (parentRouter) {\r\n            this.baseUrl = generateBaseUrl(parentRouter, parentRouter.currentInstruction);\r\n        }\r\n    };\r\n    /**@internal */\r\n    Router.prototype._createNavigationInstruction = function (url, parentInstruction) {\r\n        if (url === void 0) { url = ''; }\r\n        if (parentInstruction === void 0) { parentInstruction = null; }\r\n        var fragment = url;\r\n        var queryString = '';\r\n        var queryIndex = url.indexOf('?');\r\n        if (queryIndex !== -1) {\r\n            fragment = url.substr(0, queryIndex);\r\n            queryString = url.substr(queryIndex + 1);\r\n        }\r\n        var urlRecognizationResults = this._recognizer.recognize(url);\r\n        if (!urlRecognizationResults || !urlRecognizationResults.length) {\r\n            urlRecognizationResults = this._childRecognizer.recognize(url);\r\n        }\r\n        var instructionInit = {\r\n            fragment: fragment,\r\n            queryString: queryString,\r\n            config: null,\r\n            parentInstruction: parentInstruction,\r\n            previousInstruction: this.currentInstruction,\r\n            router: this,\r\n            options: {\r\n                compareQueryParams: this.options.compareQueryParams\r\n            }\r\n        };\r\n        var result;\r\n        if (urlRecognizationResults && urlRecognizationResults.length) {\r\n            var first = urlRecognizationResults[0];\r\n            var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                params: first.params,\r\n                queryParams: first.queryParams || urlRecognizationResults.queryParams,\r\n                config: first.config || first.handler\r\n            }));\r\n            if (typeof first.handler === 'function') {\r\n                result = evaluateNavigationStrategy(instruction, first.handler, first);\r\n            }\r\n            else if (first.handler && typeof first.handler.navigationStrategy === 'function') {\r\n                result = evaluateNavigationStrategy(instruction, first.handler.navigationStrategy, first.handler);\r\n            }\r\n            else {\r\n                result = Promise.resolve(instruction);\r\n            }\r\n        }\r\n        else if (this.catchAllHandler) {\r\n            var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                params: { path: fragment },\r\n                queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},\r\n                config: null // config will be created by the catchAllHandler\r\n            }));\r\n            result = evaluateNavigationStrategy(instruction, this.catchAllHandler);\r\n        }\r\n        else if (this.parent) {\r\n            var router = this._parentCatchAllHandler(this.parent);\r\n            if (router) {\r\n                var newParentInstruction = this._findParentInstructionFromRouter(router, parentInstruction);\r\n                var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                    params: { path: fragment },\r\n                    queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},\r\n                    router: router,\r\n                    parentInstruction: newParentInstruction,\r\n                    parentCatchHandler: true,\r\n                    config: null // config will be created by the chained parent catchAllHandler\r\n                }));\r\n                result = evaluateNavigationStrategy(instruction, router.catchAllHandler);\r\n            }\r\n        }\r\n        if (result && parentInstruction) {\r\n            this.baseUrl = generateBaseUrl(this.parent, parentInstruction);\r\n        }\r\n        return result || Promise.reject(new Error(\"Route not found: \" + url));\r\n    };\r\n    /**@internal */\r\n    Router.prototype._findParentInstructionFromRouter = function (router, instruction) {\r\n        if (instruction.router === router) {\r\n            instruction.fragment = router.baseUrl; // need to change the fragment in case of a redirect instead of moduleId\r\n            return instruction;\r\n        }\r\n        else if (instruction.parentInstruction) {\r\n            return this._findParentInstructionFromRouter(router, instruction.parentInstruction);\r\n        }\r\n        return undefined;\r\n    };\r\n    /**@internal */\r\n    Router.prototype._parentCatchAllHandler = function (router) {\r\n        if (router.catchAllHandler) {\r\n            return router;\r\n        }\r\n        else if (router.parent) {\r\n            return this._parentCatchAllHandler(router.parent);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Router.prototype._createRouteConfig = function (config, instruction) {\r\n        var _this = this;\r\n        return Promise\r\n            .resolve(config)\r\n            .then(function (c) {\r\n            if (typeof c === 'string') {\r\n                return { moduleId: c };\r\n            }\r\n            else if (typeof c === 'function') {\r\n                return c(instruction);\r\n            }\r\n            return c;\r\n        })\r\n            // typing here could be either RouteConfig or RedirectConfig\r\n            // but temporarily treat both as RouteConfig\r\n            // todo: improve typings precision\r\n            .then(function (c) { return typeof c === 'string' ? { moduleId: c } : c; })\r\n            .then(function (c) {\r\n            c.route = instruction.params.path;\r\n            validateRouteConfig(c);\r\n            if (!c.navModel) {\r\n                c.navModel = _this.createNavModel(c);\r\n            }\r\n            return c;\r\n        });\r\n    };\r\n    return Router;\r\n}());\r\n/* @internal exported for unit testing */\r\nvar generateBaseUrl = function (router, instruction) {\r\n    return \"\" + (router.baseUrl || '') + (instruction.getBaseUrl() || '');\r\n};\r\n/* @internal exported for unit testing */\r\nvar validateRouteConfig = function (config) {\r\n    if (typeof config !== 'object') {\r\n        throw new Error('Invalid Route Config');\r\n    }\r\n    if (typeof config.route !== 'string') {\r\n        var name_1 = config.name || '(no name)';\r\n        throw new Error('Invalid Route Config for \"' + name_1 + '\": You must specify a \"route:\" pattern.');\r\n    }\r\n    if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {\r\n        throw new Error('Invalid Route Config for \"' + config.route + '\": You must specify a \"moduleId:\", \"redirect:\", \"navigationStrategy:\", or \"viewPorts:\".');\r\n    }\r\n};\r\n/* @internal exported for unit testing */\r\nvar evaluateNavigationStrategy = function (instruction, evaluator, context) {\r\n    return Promise\r\n        .resolve(evaluator.call(context, instruction))\r\n        .then(function () {\r\n        if (!('viewPorts' in instruction.config)) {\r\n            instruction.config.viewPorts = {\r\n                'default': {\r\n                    moduleId: instruction.config.moduleId\r\n                }\r\n            };\r\n        }\r\n        return instruction;\r\n    });\r\n};\n\n/**@internal exported for unit testing */\r\nvar createNextFn = function (instruction, steps) {\r\n    var index = -1;\r\n    var next = function () {\r\n        index++;\r\n        if (index < steps.length) {\r\n            var currentStep = steps[index];\r\n            try {\r\n                return currentStep(instruction, next);\r\n            }\r\n            catch (e) {\r\n                return next.reject(e);\r\n            }\r\n        }\r\n        else {\r\n            return next.complete();\r\n        }\r\n    };\r\n    next.complete = createCompletionHandler(next, \"completed\" /* Completed */);\r\n    next.cancel = createCompletionHandler(next, \"canceled\" /* Canceled */);\r\n    next.reject = createCompletionHandler(next, \"rejected\" /* Rejected */);\r\n    return next;\r\n};\r\n/**@internal exported for unit testing */\r\nvar createCompletionHandler = function (next, status) {\r\n    return function (output) { return Promise\r\n        .resolve({\r\n        status: status,\r\n        output: output,\r\n        completed: status === \"completed\" /* Completed */\r\n    }); };\r\n};\n\n/**\r\n * The class responsible for managing and processing the navigation pipeline.\r\n */\r\nvar Pipeline = /** @class */ (function () {\r\n    function Pipeline() {\r\n        /**\r\n         * The pipeline steps. And steps added via addStep will be converted to a function\r\n         * The actualy running functions with correct step contexts of this pipeline\r\n         */\r\n        this.steps = [];\r\n    }\r\n    /**\r\n     * Adds a step to the pipeline.\r\n     *\r\n     * @param step The pipeline step.\r\n     */\r\n    Pipeline.prototype.addStep = function (step) {\r\n        var run;\r\n        if (typeof step === 'function') {\r\n            run = step;\r\n        }\r\n        else if (typeof step.getSteps === 'function') {\r\n            // getSteps is to enable support open slots\r\n            // where devs can add multiple steps into the same slot name\r\n            var steps = step.getSteps();\r\n            for (var i = 0, l = steps.length; i < l; i++) {\r\n                this.addStep(steps[i]);\r\n            }\r\n            return this;\r\n        }\r\n        else {\r\n            run = step.run.bind(step);\r\n        }\r\n        this.steps.push(run);\r\n        return this;\r\n    };\r\n    /**\r\n     * Runs the pipeline.\r\n     *\r\n     * @param instruction The navigation instruction to process.\r\n     */\r\n    Pipeline.prototype.run = function (instruction) {\r\n        var nextFn = createNextFn(instruction, this.steps);\r\n        return nextFn();\r\n    };\r\n    return Pipeline;\r\n}());\n\n/**\r\n* Determines if the provided object is a navigation command.\r\n* A navigation command is anything with a navigate method.\r\n*\r\n* @param obj The object to check.\r\n*/\r\nfunction isNavigationCommand(obj) {\r\n    return obj && typeof obj.navigate === 'function';\r\n}\r\n/**\r\n* Used during the activation lifecycle to cause a redirect.\r\n*/\r\nvar Redirect = /** @class */ (function () {\r\n    /**\r\n     * @param url The URL fragment to use as the navigation destination.\r\n     * @param options The navigation options.\r\n     */\r\n    function Redirect(url, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.url = url;\r\n        this.options = Object.assign({ trigger: true, replace: true }, options);\r\n        this.shouldContinueProcessing = false;\r\n    }\r\n    /**\r\n     * Called by the activation system to set the child router.\r\n     *\r\n     * @param router The router.\r\n     */\r\n    Redirect.prototype.setRouter = function (router) {\r\n        this.router = router;\r\n    };\r\n    /**\r\n     * Called by the navigation pipeline to navigate.\r\n     *\r\n     * @param appRouter The router to be redirected.\r\n     */\r\n    Redirect.prototype.navigate = function (appRouter) {\r\n        var navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);\r\n        navigatingRouter.navigate(this.url, this.options);\r\n    };\r\n    return Redirect;\r\n}());\r\n/**\r\n * Used during the activation lifecycle to cause a redirect to a named route.\r\n */\r\nvar RedirectToRoute = /** @class */ (function () {\r\n    /**\r\n     * @param route The name of the route.\r\n     * @param params The parameters to be sent to the activation method.\r\n     * @param options The options to use for navigation.\r\n     */\r\n    function RedirectToRoute(route, params, options) {\r\n        if (params === void 0) { params = {}; }\r\n        if (options === void 0) { options = {}; }\r\n        this.route = route;\r\n        this.params = params;\r\n        this.options = Object.assign({ trigger: true, replace: true }, options);\r\n        this.shouldContinueProcessing = false;\r\n    }\r\n    /**\r\n     * Called by the activation system to set the child router.\r\n     *\r\n     * @param router The router.\r\n     */\r\n    RedirectToRoute.prototype.setRouter = function (router) {\r\n        this.router = router;\r\n    };\r\n    /**\r\n     * Called by the navigation pipeline to navigate.\r\n     *\r\n     * @param appRouter The router to be redirected.\r\n     */\r\n    RedirectToRoute.prototype.navigate = function (appRouter) {\r\n        var navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);\r\n        navigatingRouter.navigateToRoute(this.route, this.params, this.options);\r\n    };\r\n    return RedirectToRoute;\r\n}());\n\n/**\r\n * @internal exported for unit testing\r\n */\r\nfunction _buildNavigationPlan(instruction, forceLifecycleMinimum) {\r\n    var config = instruction.config;\r\n    if ('redirect' in config) {\r\n        return buildRedirectPlan(instruction);\r\n    }\r\n    var prevInstruction = instruction.previousInstruction;\r\n    var defaultViewPortConfigs = instruction.router.viewPortDefaults;\r\n    if (prevInstruction) {\r\n        return buildTransitionPlans(instruction, prevInstruction, defaultViewPortConfigs, forceLifecycleMinimum);\r\n    }\r\n    // first navigation, only need to prepare a few information for each viewport plan\r\n    var viewPortPlans = {};\r\n    var viewPortConfigs = config.viewPorts;\r\n    for (var viewPortName in viewPortConfigs) {\r\n        var viewPortConfig = viewPortConfigs[viewPortName];\r\n        if (viewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {\r\n            viewPortConfig = defaultViewPortConfigs[viewPortName];\r\n        }\r\n        viewPortPlans[viewPortName] = {\r\n            name: viewPortName,\r\n            strategy: \"replace\" /* Replace */,\r\n            config: viewPortConfig\r\n        };\r\n    }\r\n    return Promise.resolve(viewPortPlans);\r\n}\r\n/**\r\n * Build redirect plan based on config of a navigation instruction\r\n * @internal exported for unit testing\r\n */\r\nvar buildRedirectPlan = function (instruction) {\r\n    var config = instruction.config;\r\n    var router = instruction.router;\r\n    return router\r\n        ._createNavigationInstruction(config.redirect)\r\n        .then(function (redirectInstruction) {\r\n        var params = {};\r\n        var originalInstructionParams = instruction.params;\r\n        var redirectInstructionParams = redirectInstruction.params;\r\n        for (var key in redirectInstructionParams) {\r\n            // If the param on the redirect points to another param, e.g. { route: first/:this, redirect: second/:this }\r\n            var val = redirectInstructionParams[key];\r\n            if (typeof val === 'string' && val[0] === ':') {\r\n                val = val.slice(1);\r\n                // And if that param is found on the original instruction then use it\r\n                if (val in originalInstructionParams) {\r\n                    params[key] = originalInstructionParams[val];\r\n                }\r\n            }\r\n            else {\r\n                params[key] = redirectInstructionParams[key];\r\n            }\r\n        }\r\n        var redirectLocation = router.generate(redirectInstruction.config, params, instruction.options);\r\n        // Special handling for child routes\r\n        for (var key in originalInstructionParams) {\r\n            redirectLocation = redirectLocation.replace(\":\" + key, originalInstructionParams[key]);\r\n        }\r\n        var queryString = instruction.queryString;\r\n        if (queryString) {\r\n            redirectLocation += '?' + queryString;\r\n        }\r\n        return Promise.resolve(new Redirect(redirectLocation));\r\n    });\r\n};\r\n/**\r\n * @param viewPortPlans the Plan record that holds information about built plans\r\n * @internal exported for unit testing\r\n */\r\nvar buildTransitionPlans = function (currentInstruction, previousInstruction, defaultViewPortConfigs, forceLifecycleMinimum) {\r\n    var viewPortPlans = {};\r\n    var newInstructionConfig = currentInstruction.config;\r\n    var hasNewParams = hasDifferentParameterValues(previousInstruction, currentInstruction);\r\n    var pending = [];\r\n    var previousViewPortInstructions = previousInstruction.viewPortInstructions;\r\n    var _loop_1 = function (viewPortName) {\r\n        var prevViewPortInstruction = previousViewPortInstructions[viewPortName];\r\n        var prevViewPortComponent = prevViewPortInstruction.component;\r\n        var newInstructionViewPortConfigs = newInstructionConfig.viewPorts;\r\n        // if this is invoked on a viewport without any changes, based on new url,\r\n        // newViewPortConfig will be the existing viewport instruction\r\n        var nextViewPortConfig = viewPortName in newInstructionViewPortConfigs\r\n            ? newInstructionViewPortConfigs[viewPortName]\r\n            : prevViewPortInstruction;\r\n        if (nextViewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {\r\n            nextViewPortConfig = defaultViewPortConfigs[viewPortName];\r\n        }\r\n        var viewPortActivationStrategy = determineActivationStrategy(currentInstruction, prevViewPortInstruction, nextViewPortConfig, hasNewParams, forceLifecycleMinimum);\r\n        var viewPortPlan = viewPortPlans[viewPortName] = {\r\n            name: viewPortName,\r\n            // ViewPortInstruction can quack like a RouteConfig\r\n            config: nextViewPortConfig,\r\n            prevComponent: prevViewPortComponent,\r\n            prevModuleId: prevViewPortInstruction.moduleId,\r\n            strategy: viewPortActivationStrategy\r\n        };\r\n        // recursively build nav plans for all existing child routers/viewports of this viewport\r\n        // this is possible because existing child viewports and routers already have necessary information\r\n        // to process the wildcard path from parent instruction\r\n        if (viewPortActivationStrategy !== \"replace\" /* Replace */ && prevViewPortInstruction.childRouter) {\r\n            var path = currentInstruction.getWildcardPath();\r\n            var task = prevViewPortInstruction\r\n                .childRouter\r\n                ._createNavigationInstruction(path, currentInstruction)\r\n                .then(function (childInstruction) {\r\n                viewPortPlan.childNavigationInstruction = childInstruction;\r\n                return _buildNavigationPlan(childInstruction, \r\n                // is it safe to assume viewPortPlan has not been changed from previous assignment?\r\n                // if so, can just use local variable viewPortPlanStrategy\r\n                // there could be user code modifying viewport plan during _createNavigationInstruction?\r\n                viewPortPlan.strategy === \"invoke-lifecycle\" /* InvokeLifecycle */)\r\n                    .then(function (childPlan) {\r\n                    if (childPlan instanceof Redirect) {\r\n                        return Promise.reject(childPlan);\r\n                    }\r\n                    childInstruction.plan = childPlan;\r\n                    // for bluebird ?\r\n                    return null;\r\n                });\r\n            });\r\n            pending.push(task);\r\n        }\r\n    };\r\n    for (var viewPortName in previousViewPortInstructions) {\r\n        _loop_1(viewPortName);\r\n    }\r\n    return Promise.all(pending).then(function () { return viewPortPlans; });\r\n};\r\n/**\r\n * @param newViewPortConfig if this is invoked on a viewport without any changes, based on new url, newViewPortConfig will be the existing viewport instruction\r\n * @internal exported for unit testing\r\n */\r\nvar determineActivationStrategy = function (currentNavInstruction, prevViewPortInstruction, newViewPortConfig, \r\n// indicates whether there is difference between old and new url params\r\nhasNewParams, forceLifecycleMinimum) {\r\n    var newInstructionConfig = currentNavInstruction.config;\r\n    var prevViewPortViewModel = prevViewPortInstruction.component.viewModel;\r\n    var viewPortPlanStrategy;\r\n    if (prevViewPortInstruction.moduleId !== newViewPortConfig.moduleId) {\r\n        viewPortPlanStrategy = \"replace\" /* Replace */;\r\n    }\r\n    else if ('determineActivationStrategy' in prevViewPortViewModel) {\r\n        viewPortPlanStrategy = prevViewPortViewModel.determineActivationStrategy.apply(prevViewPortViewModel, currentNavInstruction.lifecycleArgs);\r\n    }\r\n    else if (newInstructionConfig.activationStrategy) {\r\n        viewPortPlanStrategy = newInstructionConfig.activationStrategy;\r\n    }\r\n    else if (hasNewParams || forceLifecycleMinimum) {\r\n        viewPortPlanStrategy = \"invoke-lifecycle\" /* InvokeLifecycle */;\r\n    }\r\n    else {\r\n        viewPortPlanStrategy = \"no-change\" /* NoChange */;\r\n    }\r\n    return viewPortPlanStrategy;\r\n};\r\n/**@internal exported for unit testing */\r\nvar hasDifferentParameterValues = function (prev, next) {\r\n    var prevParams = prev.params;\r\n    var nextParams = next.params;\r\n    var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;\r\n    for (var key in nextParams) {\r\n        if (key === nextWildCardName) {\r\n            continue;\r\n        }\r\n        if (prevParams[key] !== nextParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    for (var key in prevParams) {\r\n        if (key === nextWildCardName) {\r\n            continue;\r\n        }\r\n        if (prevParams[key] !== nextParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!next.options.compareQueryParams) {\r\n        return false;\r\n    }\r\n    var prevQueryParams = prev.queryParams;\r\n    var nextQueryParams = next.queryParams;\r\n    for (var key in nextQueryParams) {\r\n        if (prevQueryParams[key] !== nextQueryParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    for (var key in prevQueryParams) {\r\n        if (prevQueryParams[key] !== nextQueryParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\n/**\r\n * Transform a navigation instruction into viewport plan record object,\r\n * or a redirect request if user viewmodel demands\r\n */\r\nvar BuildNavigationPlanStep = /** @class */ (function () {\r\n    function BuildNavigationPlanStep() {\r\n    }\r\n    BuildNavigationPlanStep.prototype.run = function (navigationInstruction, next) {\r\n        return _buildNavigationPlan(navigationInstruction)\r\n            .then(function (plan) {\r\n            if (plan instanceof Redirect) {\r\n                return next.cancel(plan);\r\n            }\r\n            navigationInstruction.plan = plan;\r\n            return next();\r\n        })\r\n            .catch(next.cancel);\r\n    };\r\n    return BuildNavigationPlanStep;\r\n}());\n\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar loadNewRoute = function (routeLoader, navigationInstruction) {\r\n    var loadingPlans = determineLoadingPlans(navigationInstruction);\r\n    var loadPromises = loadingPlans.map(function (loadingPlan) { return loadRoute(routeLoader, loadingPlan.navigationInstruction, loadingPlan.viewPortPlan); });\r\n    return Promise.all(loadPromises);\r\n};\r\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar determineLoadingPlans = function (navigationInstruction, loadingPlans) {\r\n    if (loadingPlans === void 0) { loadingPlans = []; }\r\n    var viewPortPlans = navigationInstruction.plan;\r\n    for (var viewPortName in viewPortPlans) {\r\n        var viewPortPlan = viewPortPlans[viewPortName];\r\n        var childNavInstruction = viewPortPlan.childNavigationInstruction;\r\n        if (viewPortPlan.strategy === \"replace\" /* Replace */) {\r\n            loadingPlans.push({ viewPortPlan: viewPortPlan, navigationInstruction: navigationInstruction });\r\n            if (childNavInstruction) {\r\n                determineLoadingPlans(childNavInstruction, loadingPlans);\r\n            }\r\n        }\r\n        else {\r\n            var viewPortInstruction = navigationInstruction.addViewPortInstruction({\r\n                name: viewPortName,\r\n                strategy: viewPortPlan.strategy,\r\n                moduleId: viewPortPlan.prevModuleId,\r\n                component: viewPortPlan.prevComponent\r\n            });\r\n            if (childNavInstruction) {\r\n                viewPortInstruction.childNavigationInstruction = childNavInstruction;\r\n                determineLoadingPlans(childNavInstruction, loadingPlans);\r\n            }\r\n        }\r\n    }\r\n    return loadingPlans;\r\n};\r\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar loadRoute = function (routeLoader, navigationInstruction, viewPortPlan) {\r\n    var planConfig = viewPortPlan.config;\r\n    var moduleId = planConfig ? planConfig.moduleId : null;\r\n    return loadComponent(routeLoader, navigationInstruction, planConfig)\r\n        .then(function (component) {\r\n        var viewPortInstruction = navigationInstruction.addViewPortInstruction({\r\n            name: viewPortPlan.name,\r\n            strategy: viewPortPlan.strategy,\r\n            moduleId: moduleId,\r\n            component: component\r\n        });\r\n        var childRouter = component.childRouter;\r\n        if (childRouter) {\r\n            var path = navigationInstruction.getWildcardPath();\r\n            return childRouter\r\n                ._createNavigationInstruction(path, navigationInstruction)\r\n                .then(function (childInstruction) {\r\n                viewPortPlan.childNavigationInstruction = childInstruction;\r\n                return _buildNavigationPlan(childInstruction)\r\n                    .then(function (childPlan) {\r\n                    if (childPlan instanceof Redirect) {\r\n                        return Promise.reject(childPlan);\r\n                    }\r\n                    childInstruction.plan = childPlan;\r\n                    viewPortInstruction.childNavigationInstruction = childInstruction;\r\n                    return loadNewRoute(routeLoader, childInstruction);\r\n                });\r\n            });\r\n        }\r\n        // ts complains without this, though they are same\r\n        return void 0;\r\n    });\r\n};\r\n/**\r\n * Load a routed-component based on navigation instruction and route config\r\n * @internal exported for unit testing only\r\n */\r\nvar loadComponent = function (routeLoader, navigationInstruction, config) {\r\n    var router = navigationInstruction.router;\r\n    var lifecycleArgs = navigationInstruction.lifecycleArgs;\r\n    return Promise.resolve()\r\n        .then(function () { return routeLoader.loadRoute(router, config, navigationInstruction); })\r\n        .then(\r\n    /**\r\n     * @param component an object carrying information about loaded route\r\n     * typically contains information about view model, childContainer, view and router\r\n     */\r\n    function (component) {\r\n        var viewModel = component.viewModel, childContainer = component.childContainer;\r\n        component.router = router;\r\n        component.config = config;\r\n        if ('configureRouter' in viewModel) {\r\n            var childRouter_1 = childContainer.getChildRouter();\r\n            component.childRouter = childRouter_1;\r\n            return childRouter_1\r\n                .configure(function (c) { return viewModel.configureRouter(c, childRouter_1, lifecycleArgs[0], lifecycleArgs[1], lifecycleArgs[2]); })\r\n                .then(function () { return component; });\r\n        }\r\n        return component;\r\n    });\r\n};\n\n/**\r\n * Abstract class that is responsible for loading view / view model from a route config\r\n * The default implementation can be found in `aurelia-templating-router`\r\n */\r\nvar RouteLoader = /** @class */ (function () {\r\n    function RouteLoader() {\r\n    }\r\n    /**\r\n     * Load a route config based on its viewmodel / view configuration\r\n     */\r\n    // return typing: return typings used to be never\r\n    // as it was a throw. Changing it to Promise<any> should not cause any issues\r\n    RouteLoader.prototype.loadRoute = function (router, config, navigationInstruction) {\r\n        throw new Error('Route loaders must implement \"loadRoute(router, config, navigationInstruction)\".');\r\n    };\r\n    return RouteLoader;\r\n}());\n\n/**\r\n * A pipeline step responsible for loading a route config of a navigation instruction\r\n */\r\nvar LoadRouteStep = /** @class */ (function () {\r\n    function LoadRouteStep(routeLoader) {\r\n        this.routeLoader = routeLoader;\r\n    }\r\n    /**@internal */\r\n    LoadRouteStep.inject = function () { return [RouteLoader]; };\r\n    /**\r\n     * Run the internal to load route config of a navigation instruction to prepare for next steps in the pipeline\r\n     */\r\n    LoadRouteStep.prototype.run = function (navigationInstruction, next) {\r\n        return loadNewRoute(this.routeLoader, navigationInstruction)\r\n            .then(next, next.cancel);\r\n    };\r\n    return LoadRouteStep;\r\n}());\n\n/**\r\n * A pipeline step for instructing a piepline to commit changes on a navigation instruction\r\n */\r\nvar CommitChangesStep = /** @class */ (function () {\r\n    function CommitChangesStep() {\r\n    }\r\n    CommitChangesStep.prototype.run = function (navigationInstruction, next) {\r\n        return navigationInstruction\r\n            ._commitChanges(/*wait to swap?*/ true)\r\n            .then(function () {\r\n            navigationInstruction._updateTitle();\r\n            return next();\r\n        });\r\n    };\r\n    return CommitChangesStep;\r\n}());\n\n/**\r\n * An optional interface describing the available activation strategies.\r\n * @internal Used internally.\r\n */\r\nvar InternalActivationStrategy;\r\n(function (InternalActivationStrategy) {\r\n    /**\r\n     * Reuse the existing view model, without invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"NoChange\"] = \"no-change\";\r\n    /**\r\n     * Reuse the existing view model, invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"InvokeLifecycle\"] = \"invoke-lifecycle\";\r\n    /**\r\n     * Replace the existing view model, invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"Replace\"] = \"replace\";\r\n})(InternalActivationStrategy || (InternalActivationStrategy = {}));\r\n/**\r\n * The strategy to use when activating modules during navigation.\r\n */\r\n// kept for compat reason\r\nvar activationStrategy = {\r\n    noChange: \"no-change\" /* NoChange */,\r\n    invokeLifecycle: \"invoke-lifecycle\" /* InvokeLifecycle */,\r\n    replace: \"replace\" /* Replace */\r\n};\n\n/**\r\n * Recursively find list of deactivate-able view models\r\n * and invoke the either 'canDeactivate' or 'deactivate' on each\r\n * @internal exported for unit testing\r\n */\r\nvar processDeactivatable = function (navigationInstruction, callbackName, next, ignoreResult) {\r\n    var plan = navigationInstruction.plan;\r\n    var infos = findDeactivatable(plan, callbackName);\r\n    var i = infos.length; // query from inside out\r\n    function inspect(val) {\r\n        if (ignoreResult || shouldContinue(val)) {\r\n            return iterate();\r\n        }\r\n        return next.cancel(val);\r\n    }\r\n    function iterate() {\r\n        if (i--) {\r\n            try {\r\n                var viewModel = infos[i];\r\n                var result = viewModel[callbackName](navigationInstruction);\r\n                return processPotential(result, inspect, next.cancel);\r\n            }\r\n            catch (error) {\r\n                return next.cancel(error);\r\n            }\r\n        }\r\n        navigationInstruction.router.couldDeactivate = true;\r\n        return next();\r\n    }\r\n    return iterate();\r\n};\r\n/**\r\n * Recursively find and returns a list of deactivate-able view models\r\n * @internal exported for unit testing\r\n */\r\nvar findDeactivatable = function (plan, callbackName, list) {\r\n    if (list === void 0) { list = []; }\r\n    for (var viewPortName in plan) {\r\n        var viewPortPlan = plan[viewPortName];\r\n        var prevComponent = viewPortPlan.prevComponent;\r\n        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace)\r\n            && prevComponent) {\r\n            var viewModel = prevComponent.viewModel;\r\n            if (callbackName in viewModel) {\r\n                list.push(viewModel);\r\n            }\r\n        }\r\n        if (viewPortPlan.strategy === activationStrategy.replace && prevComponent) {\r\n            addPreviousDeactivatable(prevComponent, callbackName, list);\r\n        }\r\n        else if (viewPortPlan.childNavigationInstruction) {\r\n            findDeactivatable(viewPortPlan.childNavigationInstruction.plan, callbackName, list);\r\n        }\r\n    }\r\n    return list;\r\n};\r\n/**\r\n * @internal exported for unit testing\r\n */\r\nvar addPreviousDeactivatable = function (component, callbackName, list) {\r\n    var childRouter = component.childRouter;\r\n    if (childRouter && childRouter.currentInstruction) {\r\n        var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;\r\n        for (var viewPortName in viewPortInstructions) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var prevComponent = viewPortInstruction.component;\r\n            var prevViewModel = prevComponent.viewModel;\r\n            if (callbackName in prevViewModel) {\r\n                list.push(prevViewModel);\r\n            }\r\n            addPreviousDeactivatable(prevComponent, callbackName, list);\r\n        }\r\n    }\r\n};\r\n/**\r\n * @internal exported for unit testing\r\n */\r\nvar processActivatable = function (navigationInstruction, callbackName, next, ignoreResult) {\r\n    var infos = findActivatable(navigationInstruction, callbackName);\r\n    var length = infos.length;\r\n    var i = -1; // query from top down\r\n    function inspect(val, router) {\r\n        if (ignoreResult || shouldContinue(val, router)) {\r\n            return iterate();\r\n        }\r\n        return next.cancel(val);\r\n    }\r\n    function iterate() {\r\n        var _a;\r\n        i++;\r\n        if (i < length) {\r\n            try {\r\n                var current_1 = infos[i];\r\n                var result = (_a = current_1.viewModel)[callbackName].apply(_a, current_1.lifecycleArgs);\r\n                return processPotential(result, function (val) { return inspect(val, current_1.router); }, next.cancel);\r\n            }\r\n            catch (error) {\r\n                return next.cancel(error);\r\n            }\r\n        }\r\n        return next();\r\n    }\r\n    return iterate();\r\n};\r\n/**\r\n * Find list of activatable view model and add to list (3rd parameter)\r\n * @internal exported for unit testing\r\n */\r\nvar findActivatable = function (navigationInstruction, callbackName, list, router) {\r\n    if (list === void 0) { list = []; }\r\n    var plan = navigationInstruction.plan;\r\n    Object\r\n        .keys(plan)\r\n        .forEach(function (viewPortName) {\r\n        var viewPortPlan = plan[viewPortName];\r\n        var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];\r\n        var viewPortComponent = viewPortInstruction.component;\r\n        var viewModel = viewPortComponent.viewModel;\r\n        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle\r\n            || viewPortPlan.strategy === activationStrategy.replace)\r\n            && callbackName in viewModel) {\r\n            list.push({\r\n                viewModel: viewModel,\r\n                lifecycleArgs: viewPortInstruction.lifecycleArgs,\r\n                router: router\r\n            });\r\n        }\r\n        var childNavInstruction = viewPortPlan.childNavigationInstruction;\r\n        if (childNavInstruction) {\r\n            findActivatable(childNavInstruction, callbackName, list, viewPortComponent.childRouter || router);\r\n        }\r\n    });\r\n    return list;\r\n};\r\nvar shouldContinue = function (output, router) {\r\n    if (output instanceof Error) {\r\n        return false;\r\n    }\r\n    if (isNavigationCommand(output)) {\r\n        if (typeof output.setRouter === 'function') {\r\n            output.setRouter(router);\r\n        }\r\n        return !!output.shouldContinueProcessing;\r\n    }\r\n    if (output === undefined) {\r\n        return true;\r\n    }\r\n    return output;\r\n};\r\n/**\r\n * wraps a subscription, allowing unsubscribe calls even if\r\n * the first value comes synchronously\r\n */\r\nvar SafeSubscription = /** @class */ (function () {\r\n    function SafeSubscription(subscriptionFunc) {\r\n        this._subscribed = true;\r\n        this._subscription = subscriptionFunc(this);\r\n        if (!this._subscribed) {\r\n            this.unsubscribe();\r\n        }\r\n    }\r\n    Object.defineProperty(SafeSubscription.prototype, \"subscribed\", {\r\n        get: function () {\r\n            return this._subscribed;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SafeSubscription.prototype.unsubscribe = function () {\r\n        if (this._subscribed && this._subscription) {\r\n            this._subscription.unsubscribe();\r\n        }\r\n        this._subscribed = false;\r\n    };\r\n    return SafeSubscription;\r\n}());\r\n/**\r\n * A function to process return value from `activate`/`canActivate` steps\r\n * Supports observable/promise\r\n *\r\n * For observable, resolve at first next() or on complete()\r\n */\r\nvar processPotential = function (obj, resolve, reject) {\r\n    // if promise like\r\n    if (obj && typeof obj.then === 'function') {\r\n        return Promise.resolve(obj).then(resolve).catch(reject);\r\n    }\r\n    // if observable\r\n    if (obj && typeof obj.subscribe === 'function') {\r\n        var obs_1 = obj;\r\n        return new SafeSubscription(function (sub) { return obs_1.subscribe({\r\n            next: function () {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    resolve(obj);\r\n                }\r\n            },\r\n            error: function (error) {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    reject(error);\r\n                }\r\n            },\r\n            complete: function () {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    resolve(obj);\r\n                }\r\n            }\r\n        }); });\r\n    }\r\n    // else just resolve\r\n    try {\r\n        return resolve(obj);\r\n    }\r\n    catch (error) {\r\n        return reject(error);\r\n    }\r\n};\n\n/**\r\n * A pipeline step responsible for finding and activating method `canDeactivate` on a view model of a route\r\n */\r\nvar CanDeactivatePreviousStep = /** @class */ (function () {\r\n    function CanDeactivatePreviousStep() {\r\n    }\r\n    CanDeactivatePreviousStep.prototype.run = function (navigationInstruction, next) {\r\n        return processDeactivatable(navigationInstruction, 'canDeactivate', next);\r\n    };\r\n    return CanDeactivatePreviousStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `canActivate` on a view model of a route\r\n */\r\nvar CanActivateNextStep = /** @class */ (function () {\r\n    function CanActivateNextStep() {\r\n    }\r\n    CanActivateNextStep.prototype.run = function (navigationInstruction, next) {\r\n        return processActivatable(navigationInstruction, 'canActivate', next);\r\n    };\r\n    return CanActivateNextStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `deactivate` on a view model of a route\r\n */\r\nvar DeactivatePreviousStep = /** @class */ (function () {\r\n    function DeactivatePreviousStep() {\r\n    }\r\n    DeactivatePreviousStep.prototype.run = function (navigationInstruction, next) {\r\n        return processDeactivatable(navigationInstruction, 'deactivate', next, true);\r\n    };\r\n    return DeactivatePreviousStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `activate` on a view model of a route\r\n */\r\nvar ActivateNextStep = /** @class */ (function () {\r\n    function ActivateNextStep() {\r\n    }\r\n    ActivateNextStep.prototype.run = function (navigationInstruction, next) {\r\n        return processActivatable(navigationInstruction, 'activate', next, true);\r\n    };\r\n    return ActivateNextStep;\r\n}());\n\n/**\r\n * A multi-slots Pipeline Placeholder Step for hooking into a pipeline execution\r\n */\r\nvar PipelineSlot = /** @class */ (function () {\r\n    function PipelineSlot(container, name, alias) {\r\n        this.steps = [];\r\n        this.container = container;\r\n        this.slotName = name;\r\n        this.slotAlias = alias;\r\n    }\r\n    PipelineSlot.prototype.getSteps = function () {\r\n        var _this = this;\r\n        return this.steps.map(function (x) { return _this.container.get(x); });\r\n    };\r\n    return PipelineSlot;\r\n}());\r\n/**\r\n * Class responsible for creating the navigation pipeline.\r\n */\r\nvar PipelineProvider = /** @class */ (function () {\r\n    function PipelineProvider(container) {\r\n        this.container = container;\r\n        this.steps = [\r\n            BuildNavigationPlanStep,\r\n            CanDeactivatePreviousStep,\r\n            LoadRouteStep,\r\n            createPipelineSlot(container, \"authorize\" /* Authorize */),\r\n            CanActivateNextStep,\r\n            createPipelineSlot(container, \"preActivate\" /* PreActivate */, 'modelbind'),\r\n            // NOTE: app state changes start below - point of no return\r\n            DeactivatePreviousStep,\r\n            ActivateNextStep,\r\n            createPipelineSlot(container, \"preRender\" /* PreRender */, 'precommit'),\r\n            CommitChangesStep,\r\n            createPipelineSlot(container, \"postRender\" /* PostRender */, 'postcomplete')\r\n        ];\r\n    }\r\n    /**@internal */\r\n    PipelineProvider.inject = function () { return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__[\"Container\"]]; };\r\n    /**\r\n     * Create the navigation pipeline.\r\n     */\r\n    PipelineProvider.prototype.createPipeline = function (useCanDeactivateStep) {\r\n        var _this = this;\r\n        if (useCanDeactivateStep === void 0) { useCanDeactivateStep = true; }\r\n        var pipeline = new Pipeline();\r\n        this.steps.forEach(function (step) {\r\n            if (useCanDeactivateStep || step !== CanDeactivatePreviousStep) {\r\n                pipeline.addStep(_this.container.get(step));\r\n            }\r\n        });\r\n        return pipeline;\r\n    };\r\n    /**@internal */\r\n    PipelineProvider.prototype._findStep = function (name) {\r\n        // Steps that are not PipelineSlots are constructor functions, and they will automatically fail. Probably.\r\n        return this.steps.find(function (x) { return x.slotName === name || x.slotAlias === name; });\r\n    };\r\n    /**\r\n     * Adds a step into the pipeline at a known slot location.\r\n     */\r\n    PipelineProvider.prototype.addStep = function (name, step) {\r\n        var found = this._findStep(name);\r\n        if (found) {\r\n            var slotSteps = found.steps;\r\n            // prevent duplicates\r\n            if (!slotSteps.includes(step)) {\r\n                slotSteps.push(step);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid pipeline slot name: \" + name + \".\");\r\n        }\r\n    };\r\n    /**\r\n     * Removes a step from a slot in the pipeline\r\n     */\r\n    PipelineProvider.prototype.removeStep = function (name, step) {\r\n        var slot = this._findStep(name);\r\n        if (slot) {\r\n            var slotSteps = slot.steps;\r\n            slotSteps.splice(slotSteps.indexOf(step), 1);\r\n        }\r\n    };\r\n    /**\r\n     * Clears all steps from a slot in the pipeline\r\n     * @internal\r\n     */\r\n    PipelineProvider.prototype._clearSteps = function (name) {\r\n        if (name === void 0) { name = ''; }\r\n        var slot = this._findStep(name);\r\n        if (slot) {\r\n            slot.steps = [];\r\n        }\r\n    };\r\n    /**\r\n     * Resets all pipeline slots\r\n     */\r\n    PipelineProvider.prototype.reset = function () {\r\n        this._clearSteps(\"authorize\" /* Authorize */);\r\n        this._clearSteps(\"preActivate\" /* PreActivate */);\r\n        this._clearSteps(\"preRender\" /* PreRender */);\r\n        this._clearSteps(\"postRender\" /* PostRender */);\r\n    };\r\n    return PipelineProvider;\r\n}());\r\n/**@internal */\r\nvar createPipelineSlot = function (container, name, alias) {\r\n    return new PipelineSlot(container, name, alias);\r\n};\n\nvar logger = Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"])('app-router');\r\n/**\r\n * The main application router.\r\n */\r\nvar AppRouter = /** @class */ (function (_super) {\r\n    __extends(AppRouter, _super);\r\n    function AppRouter(container, history, pipelineProvider, events) {\r\n        var _this = _super.call(this, container, history) || this;\r\n        _this.pipelineProvider = pipelineProvider;\r\n        _this.events = events;\r\n        return _this;\r\n    }\r\n    /**@internal */\r\n    AppRouter.inject = function () { return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__[\"Container\"], aurelia_history__WEBPACK_IMPORTED_MODULE_2__[\"History\"], PipelineProvider, aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__[\"EventAggregator\"]]; };\r\n    /**\r\n     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.\r\n     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.\r\n     */\r\n    AppRouter.prototype.reset = function () {\r\n        _super.prototype.reset.call(this);\r\n        this.maxInstructionCount = 10;\r\n        if (!this._queue) {\r\n            this._queue = [];\r\n        }\r\n        else {\r\n            this._queue.length = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Loads the specified URL.\r\n     *\r\n     * @param url The URL fragment to load.\r\n     */\r\n    AppRouter.prototype.loadUrl = function (url) {\r\n        var _this = this;\r\n        return this\r\n            ._createNavigationInstruction(url)\r\n            .then(function (instruction) { return _this._queueInstruction(instruction); })\r\n            .catch(function (error) {\r\n            logger.error(error);\r\n            restorePreviousLocation(_this);\r\n        });\r\n    };\r\n    /**\r\n     * Registers a viewPort to be used as a rendering target for activated routes.\r\n     *\r\n     * @param viewPort The viewPort. This is typically a <router-view/> element in Aurelia default impl\r\n     * @param name The name of the viewPort. 'default' if unspecified.\r\n     */\r\n    AppRouter.prototype.registerViewPort = function (viewPort, name) {\r\n        var _this = this;\r\n        // having strong typing without changing public API\r\n        var $viewPort = viewPort;\r\n        _super.prototype.registerViewPort.call(this, $viewPort, name);\r\n        // beside adding viewport to the registry of this instance\r\n        // AppRouter also configure routing/history to start routing functionality\r\n        // There are situation where there are more than 1 <router-view/> element at root view\r\n        // in that case, still only activate once via the following guard\r\n        if (!this.isActive) {\r\n            var viewModel_1 = this._findViewModel($viewPort);\r\n            if ('configureRouter' in viewModel_1) {\r\n                // If there are more than one <router-view/> element at root view\r\n                // use this flag to guard against configure method being invoked multiple times\r\n                // this flag is set inside method configure\r\n                if (!this.isConfigured) {\r\n                    // replace the real resolve with a noop to guarantee that any action in base class Router\r\n                    // won't resolve the configurePromise prematurely\r\n                    var resolveConfiguredPromise_1 = this._resolveConfiguredPromise;\r\n                    this._resolveConfiguredPromise = function () { };\r\n                    return this\r\n                        .configure(function (config) {\r\n                        return Promise\r\n                            .resolve(viewModel_1.configureRouter(config, _this))\r\n                            // an issue with configure interface. Should be fixed there\r\n                            // todo: fix this via configure interface in router\r\n                            .then(function () { return config; });\r\n                    })\r\n                        .then(function () {\r\n                        _this.activate();\r\n                        resolveConfiguredPromise_1();\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                this.activate();\r\n            }\r\n        }\r\n        // when a viewport is added dynamically to a root view that is already activated\r\n        // just process the navigation instruction\r\n        else {\r\n            this._dequeueInstruction();\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    /**\r\n     * Activates the router. This instructs the router to begin listening for history changes and processing instructions.\r\n     *\r\n     * @params options The set of options to activate the router with.\r\n     */\r\n    AppRouter.prototype.activate = function (options) {\r\n        if (this.isActive) {\r\n            return;\r\n        }\r\n        this.isActive = true;\r\n        // route handler property is responsible for handling url change\r\n        // the interface of aurelia-history isn't clear on this perspective\r\n        this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);\r\n        this.history.activate(this.options);\r\n        this._dequeueInstruction();\r\n    };\r\n    /**\r\n     * Deactivates the router.\r\n     */\r\n    AppRouter.prototype.deactivate = function () {\r\n        this.isActive = false;\r\n        this.history.deactivate();\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._queueInstruction = function (instruction) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            instruction.resolve = resolve;\r\n            _this._queue.unshift(instruction);\r\n            _this._dequeueInstruction();\r\n        });\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._dequeueInstruction = function (instructionCount) {\r\n        var _this = this;\r\n        if (instructionCount === void 0) { instructionCount = 0; }\r\n        return Promise.resolve().then(function () {\r\n            if (_this.isNavigating && !instructionCount) {\r\n                // ts complains about inconsistent returns without void 0\r\n                return void 0;\r\n            }\r\n            var instruction = _this._queue.shift();\r\n            _this._queue.length = 0;\r\n            if (!instruction) {\r\n                // ts complains about inconsistent returns without void 0\r\n                return void 0;\r\n            }\r\n            _this.isNavigating = true;\r\n            var navtracker = _this.history.getState('NavigationTracker');\r\n            var currentNavTracker = _this.currentNavigationTracker;\r\n            if (!navtracker && !currentNavTracker) {\r\n                _this.isNavigatingFirst = true;\r\n                _this.isNavigatingNew = true;\r\n            }\r\n            else if (!navtracker) {\r\n                _this.isNavigatingNew = true;\r\n            }\r\n            else if (!currentNavTracker) {\r\n                _this.isNavigatingRefresh = true;\r\n            }\r\n            else if (currentNavTracker < navtracker) {\r\n                _this.isNavigatingForward = true;\r\n            }\r\n            else if (currentNavTracker > navtracker) {\r\n                _this.isNavigatingBack = true;\r\n            }\r\n            if (!navtracker) {\r\n                navtracker = Date.now();\r\n                _this.history.setState('NavigationTracker', navtracker);\r\n            }\r\n            _this.currentNavigationTracker = navtracker;\r\n            instruction.previousInstruction = _this.currentInstruction;\r\n            var maxInstructionCount = _this.maxInstructionCount;\r\n            if (!instructionCount) {\r\n                _this.events.publish(\"router:navigation:processing\" /* Processing */, { instruction: instruction });\r\n            }\r\n            else if (instructionCount === maxInstructionCount - 1) {\r\n                logger.error(instructionCount + 1 + \" navigation instructions have been attempted without success. Restoring last known good location.\");\r\n                restorePreviousLocation(_this);\r\n                return _this._dequeueInstruction(instructionCount + 1);\r\n            }\r\n            else if (instructionCount > maxInstructionCount) {\r\n                throw new Error('Maximum navigation attempts exceeded. Giving up.');\r\n            }\r\n            var pipeline = _this.pipelineProvider.createPipeline(!_this.couldDeactivate);\r\n            return pipeline\r\n                .run(instruction)\r\n                .then(function (result) { return processResult(instruction, result, instructionCount, _this); })\r\n                .catch(function (error) {\r\n                return { output: error instanceof Error ? error : new Error(error) };\r\n            })\r\n                .then(function (result) { return resolveInstruction(instruction, result, !!instructionCount, _this); });\r\n        });\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._findViewModel = function (viewPort) {\r\n        if (this.container.viewModel) {\r\n            return this.container.viewModel;\r\n        }\r\n        if (viewPort.container) {\r\n            var container = viewPort.container;\r\n            while (container) {\r\n                if (container.viewModel) {\r\n                    this.container.viewModel = container.viewModel;\r\n                    return container.viewModel;\r\n                }\r\n                container = container.parent;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return AppRouter;\r\n}(Router));\r\nvar processResult = function (instruction, result, instructionCount, router) {\r\n    if (!(result && 'completed' in result && 'output' in result)) {\r\n        result = result || {};\r\n        result.output = new Error(\"Expected router pipeline to return a navigation result, but got [\" + JSON.stringify(result) + \"] instead.\");\r\n    }\r\n    var finalResult = null;\r\n    var navigationCommandResult = null;\r\n    if (isNavigationCommand(result.output)) {\r\n        navigationCommandResult = result.output.navigate(router);\r\n    }\r\n    else {\r\n        finalResult = result;\r\n        if (!result.completed) {\r\n            if (result.output instanceof Error) {\r\n                logger.error(result.output.toString());\r\n            }\r\n            restorePreviousLocation(router);\r\n        }\r\n    }\r\n    return Promise.resolve(navigationCommandResult)\r\n        .then(function (_) { return router._dequeueInstruction(instructionCount + 1); })\r\n        .then(function (innerResult) { return finalResult || innerResult || result; });\r\n};\r\nvar resolveInstruction = function (instruction, result, isInnerInstruction, router) {\r\n    instruction.resolve(result);\r\n    var eventAggregator = router.events;\r\n    var eventArgs = { instruction: instruction, result: result };\r\n    if (!isInnerInstruction) {\r\n        router.isNavigating = false;\r\n        router.isExplicitNavigation = false;\r\n        router.isExplicitNavigationBack = false;\r\n        router.isNavigatingFirst = false;\r\n        router.isNavigatingNew = false;\r\n        router.isNavigatingRefresh = false;\r\n        router.isNavigatingForward = false;\r\n        router.isNavigatingBack = false;\r\n        router.couldDeactivate = false;\r\n        var eventName = void 0;\r\n        if (result.output instanceof Error) {\r\n            eventName = \"router:navigation:error\" /* Error */;\r\n        }\r\n        else if (!result.completed) {\r\n            eventName = \"router:navigation:canceled\" /* Canceled */;\r\n        }\r\n        else {\r\n            var queryString = instruction.queryString ? ('?' + instruction.queryString) : '';\r\n            router.history.previousLocation = instruction.fragment + queryString;\r\n            eventName = \"router:navigation:success\" /* Success */;\r\n        }\r\n        eventAggregator.publish(eventName, eventArgs);\r\n        eventAggregator.publish(\"router:navigation:complete\" /* Complete */, eventArgs);\r\n    }\r\n    else {\r\n        eventAggregator.publish(\"router:navigation:child:complete\" /* ChildComplete */, eventArgs);\r\n    }\r\n    return result;\r\n};\r\nvar restorePreviousLocation = function (router) {\r\n    var previousLocation = router.history.previousLocation;\r\n    if (previousLocation) {\r\n        router.navigate(previousLocation, { trigger: false, replace: true });\r\n    }\r\n    else if (router.fallbackRoute) {\r\n        router.navigate(router.fallbackRoute, { trigger: true, replace: true });\r\n    }\r\n    else {\r\n        logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');\r\n    }\r\n};\n\n/**\r\n* The status of a Pipeline.\r\n*/\r\nvar PipelineStatus;\r\n(function (PipelineStatus) {\r\n    PipelineStatus[\"Completed\"] = \"completed\";\r\n    PipelineStatus[\"Canceled\"] = \"canceled\";\r\n    PipelineStatus[\"Rejected\"] = \"rejected\";\r\n    PipelineStatus[\"Running\"] = \"running\";\r\n})(PipelineStatus || (PipelineStatus = {}));\n\n/**\r\n * A list of known router events used by the Aurelia router\r\n * to signal the pipeline has come to a certain state\r\n */\r\n// const enum is preserved in tsconfig\r\nvar RouterEvent;\r\n(function (RouterEvent) {\r\n    RouterEvent[\"Processing\"] = \"router:navigation:processing\";\r\n    RouterEvent[\"Error\"] = \"router:navigation:error\";\r\n    RouterEvent[\"Canceled\"] = \"router:navigation:canceled\";\r\n    RouterEvent[\"Complete\"] = \"router:navigation:complete\";\r\n    RouterEvent[\"Success\"] = \"router:navigation:success\";\r\n    RouterEvent[\"ChildComplete\"] = \"router:navigation:child:complete\";\r\n})(RouterEvent || (RouterEvent = {}));\n\n/**\r\n * Available pipeline slot names to insert interceptor into router pipeline\r\n */\r\n// const enum is preserved in tsconfig\r\nvar PipelineSlotName;\r\n(function (PipelineSlotName) {\r\n    /**\r\n     * Authorization slot. Invoked early in the pipeline,\r\n     * before `canActivate` hook of incoming route\r\n     */\r\n    PipelineSlotName[\"Authorize\"] = \"authorize\";\r\n    /**\r\n     * Pre-activation slot. Invoked early in the pipeline,\r\n     * Invoked timing:\r\n     *   - after Authorization slot\r\n     *   - after canActivate hook on new view model\r\n     *   - before deactivate hook on old view model\r\n     *   - before activate hook on new view model\r\n     */\r\n    PipelineSlotName[\"PreActivate\"] = \"preActivate\";\r\n    /**\r\n     * Pre-render slot. Invoked later in the pipeline\r\n     * Invokcation timing:\r\n     *   - after activate hook on new view model\r\n     *   - before commit step on new navigation instruction\r\n     */\r\n    PipelineSlotName[\"PreRender\"] = \"preRender\";\r\n    /**\r\n     * Post-render slot. Invoked last in the pipeline\r\n     */\r\n    PipelineSlotName[\"PostRender\"] = \"postRender\";\r\n})(PipelineSlotName || (PipelineSlotName = {}));\n\n\n//# sourceMappingURL=aurelia-router.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! promise-polyfill */ \"B/eG\")[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNHlzdS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXJvdXRlci9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtcm91dGVyLmpzP2UzMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnYXVyZWxpYS1sb2dnaW5nJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ2F1cmVsaWEtZGVwZW5kZW5jeS1pbmplY3Rpb24nO1xuaW1wb3J0IHsgSGlzdG9yeSB9IGZyb20gJ2F1cmVsaWEtaGlzdG9yeSc7XG5pbXBvcnQgeyBSb3V0ZVJlY29nbml6ZXIgfSBmcm9tICdhdXJlbGlhLXJvdXRlLXJlY29nbml6ZXInO1xuaW1wb3J0IHsgRXZlbnRBZ2dyZWdhdG9yIH0gZnJvbSAnYXVyZWxpYS1ldmVudC1hZ2dyZWdhdG9yJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKipcclxuICogQ2xhc3MgdXNlZCB0byByZXByZXNlbnQgYW4gaW5zdHJ1Y3Rpb24gZHVyaW5nIGEgbmF2aWdhdGlvbi5cclxuICovXHJcbnZhciBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24oaW5pdCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgYnVpbHQgdmlld3BvcnQgcGxhbiBvZiB0aGlzIG5hdiBpbnN0cnVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGxhbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0KTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHRoaXMucGFyYW1zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnMgPSB7fTtcclxuICAgICAgICB2YXIgYW5jZXN0b3JQYXJhbXMgPSBbXTtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXM7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuY29uZmlnICYmIGN1cnJlbnQuY29uZmlnLmhhc0NoaWxkUm91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBhcmFtIGZvciB0aGUgaW5qZWN0ZWQgY2hpbGQgcm91dGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRQYXJhbXNbY3VycmVudC5nZXRXaWxkQ2FyZE5hbWUoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5jZXN0b3JQYXJhbXMudW5zaGlmdChjdXJyZW50UGFyYW1zKTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XHJcbiAgICAgICAgdmFyIGFsbFBhcmFtcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbe30sIHRoaXMucXVlcnlQYXJhbXNdLmNvbmNhdChhbmNlc3RvclBhcmFtcykpO1xyXG4gICAgICAgIHRoaXMubGlmZWN5Y2xlQXJncyA9IFthbGxQYXJhbXMsIHRoaXMuY29uZmlnLCB0aGlzXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBhcnJheSBjb250YWluaW5nIHRoaXMgaW5zdHJ1Y3Rpb24gYW5kIGFsbCBjaGlsZCBpbnN0cnVjdGlvbnMgZm9yIHRoZSBjdXJyZW50IG5hdmlnYXRpb24uXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0QWxsSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbdGhpc107XHJcbiAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb25zID0gdGhpcy52aWV3UG9ydEluc3RydWN0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmlld1BvcnRJbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkSW5zdHJ1Y3Rpb24gPSB2aWV3UG9ydEluc3RydWN0aW9uc1trZXldLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2guYXBwbHkoaW5zdHJ1Y3Rpb25zLCBjaGlsZEluc3RydWN0aW9uLmdldEFsbEluc3RydWN0aW9ucygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBpbnN0cnVjdGlvbiBhbmQgYWxsIGNoaWxkIGluc3RydWN0aW9ucyBmb3IgdGhlIHByZXZpb3VzIG5hdmlnYXRpb24uXHJcbiAgICAgKiBQcmV2aW91cyBpbnN0cnVjdGlvbnMgYXJlIG5vIGxvbmdlciBhdmFpbGFibGUgYWZ0ZXIgbmF2aWdhdGlvbiBjb21wbGV0ZXMuXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0QWxsUHJldmlvdXNJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsSW5zdHJ1Y3Rpb25zKCkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnByZXZpb3VzSW5zdHJ1Y3Rpb247IH0pLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYzsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5hZGRWaWV3UG9ydEluc3RydWN0aW9uID0gZnVuY3Rpb24gKG5hbWVPckluaXRPcHRpb25zLCBzdHJhdGVneSwgbW9kdWxlSWQsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9uO1xyXG4gICAgICAgIHZhciB2aWV3UG9ydE5hbWUgPSB0eXBlb2YgbmFtZU9ySW5pdE9wdGlvbnMgPT09ICdzdHJpbmcnID8gbmFtZU9ySW5pdE9wdGlvbnMgOiBuYW1lT3JJbml0T3B0aW9ucy5uYW1lO1xyXG4gICAgICAgIHZhciBsaWZlY3ljbGVBcmdzID0gdGhpcy5saWZlY3ljbGVBcmdzO1xyXG4gICAgICAgIHZhciBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBsaWZlY3ljbGVBcmdzWzFdLCB7IGN1cnJlbnRWaWV3UG9ydDogdmlld1BvcnROYW1lIH0pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9ySW5pdE9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lT3JJbml0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneSxcclxuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgY2hpbGRSb3V0ZXI6IGNvbXBvbmVudC5jaGlsZFJvdXRlcixcclxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZUFyZ3M6IFtsaWZlY3ljbGVBcmdzWzBdLCBjb25maWcsIGxpZmVjeWNsZUFyZ3NbMl1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2aWV3UG9ydEluc3RydWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogdmlld1BvcnROYW1lLFxyXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6IG5hbWVPckluaXRPcHRpb25zLnN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBuYW1lT3JJbml0T3B0aW9ucy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogbmFtZU9ySW5pdE9wdGlvbnMubW9kdWxlSWQsXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJvdXRlcjogbmFtZU9ySW5pdE9wdGlvbnMuY29tcG9uZW50LmNoaWxkUm91dGVyLFxyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlQXJnczogW2xpZmVjeWNsZUFyZ3NbMF0sIGNvbmZpZywgbGlmZWN5Y2xlQXJnc1syXV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXSA9IHZpZXdQb3J0SW5zdHJ1Y3Rpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSByb3V0ZSBwYXR0ZXJuJ3Mgd2lsZGNhcmQgcGFyYW1ldGVyLCBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICovXHJcbiAgICBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLmdldFdpbGRDYXJkTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB0b2RvOiBwb3RlbnRpYWwgaXNzdWUsIG9yIGF0IGxlYXN0IHVuc2FmZSB0eXBpbmdzXHJcbiAgICAgICAgdmFyIGNvbmZpZ1JvdXRlID0gdGhpcy5jb25maWcucm91dGU7XHJcbiAgICAgICAgdmFyIHdpbGRjYXJkSW5kZXggPSBjb25maWdSb3V0ZS5sYXN0SW5kZXhPZignKicpO1xyXG4gICAgICAgIHJldHVybiBjb25maWdSb3V0ZS5zdWJzdHIod2lsZGNhcmRJbmRleCArIDEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcGF0aCBhbmQgcXVlcnkgc3RyaW5nIGNyZWF0ZWQgYnkgZmlsbGluZyB0aGUgcm91dGVcclxuICAgICAqIHBhdHRlcm4ncyB3aWxkY2FyZCBwYXJhbWV0ZXIgd2l0aCB0aGUgbWF0Y2hpbmcgcGFyYW0uXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0V2lsZGNhcmRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWxkY2FyZE5hbWUgPSB0aGlzLmdldFdpbGRDYXJkTmFtZSgpO1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXJhbXNbd2lsZGNhcmROYW1lXSB8fCAnJztcclxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSB0aGlzLnF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgIGlmIChxdWVyeVN0cmluZykge1xyXG4gICAgICAgICAgICBwYXRoICs9ICc/JyArIHF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGluc3RydWN0aW9uJ3MgYmFzZSBVUkwsIGFjY291bnRpbmcgZm9yIHdpbGRjYXJkIHJvdXRlIHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0QmFzZVVybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAkZW5jb2RlVVJJID0gZW5jb2RlVVJJO1xyXG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmZyYWdtZW50KTtcclxuICAgICAgICBpZiAoZnJhZ21lbnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHZhciBub25FbXB0eVJvdXRlID0gdGhpcy5yb3V0ZXIucm91dGVzLmZpbmQoZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGUubmFtZSA9PT0gX3RoaXMuY29uZmlnLm5hbWUgJiZcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZS5yb3V0ZSAhPT0gJyc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAobm9uRW1wdHlSb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBub25FbXB0eVJvdXRlLnJvdXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICRlbmNvZGVVUkkoZnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2lsZGNhcmROYW1lID0gdGhpcy5nZXRXaWxkQ2FyZE5hbWUoKTtcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGFyYW1zW3dpbGRjYXJkTmFtZV0gfHwgJyc7XHJcbiAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkZW5jb2RlVVJJKGZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICRlbmNvZGVVUkkoZnJhZ21lbnQuc3Vic3RyKDAsIGZyYWdtZW50Lmxhc3RJbmRleE9mKHBhdGgpKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGl6ZSBhIHZpZXdwb3J0IGluc3RydWN0aW9uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5fY29tbWl0Q2hhbmdlcyA9IGZ1bmN0aW9uICh3YWl0VG9Td2FwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XHJcbiAgICAgICAgcm91dGVyLmN1cnJlbnRJbnN0cnVjdGlvbiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzSW5zdHJ1Y3Rpb24gPSB0aGlzLnByZXZpb3VzSW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgaWYgKHByZXZpb3VzSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgcHJldmlvdXNJbnN0cnVjdGlvbi5jb25maWcubmF2TW9kZWwuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25maWcubmF2TW9kZWwuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHJvdXRlci5yZWZyZXNoTmF2aWdhdGlvbigpO1xyXG4gICAgICAgIHZhciBsb2FkcyA9IFtdO1xyXG4gICAgICAgIHZhciBkZWxheVN3YXBzID0gW107XHJcbiAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb25zID0gdGhpcy52aWV3UG9ydEluc3RydWN0aW9ucztcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2aWV3UG9ydE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSB2aWV3UG9ydEluc3RydWN0aW9uc1t2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgdmlld1BvcnQgPSByb3V0ZXIudmlld1BvcnRzW3ZpZXdQb3J0TmFtZV07XHJcbiAgICAgICAgICAgIGlmICghdmlld1BvcnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBubyByb3V0ZXItdmlldyBmb3VuZCBpbiB0aGUgdmlldyBmb3IgXCIgKyB2aWV3UG9ydEluc3RydWN0aW9uLm1vZHVsZUlkICsgXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5hdkluc3RydWN0aW9uID0gdmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbjtcclxuICAgICAgICAgICAgaWYgKHZpZXdQb3J0SW5zdHJ1Y3Rpb24uc3RyYXRlZ3kgPT09IFwicmVwbGFjZVwiIC8qIFJlcGxhY2UgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5hdkluc3RydWN0aW9uICYmIGNoaWxkTmF2SW5zdHJ1Y3Rpb24ucGFyZW50Q2F0Y2hIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZHMucHVzaChjaGlsZE5hdkluc3RydWN0aW9uLl9jb21taXRDaGFuZ2VzKHdhaXRUb1N3YXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWl0VG9Td2FwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5U3dhcHMucHVzaCh7IHZpZXdQb3J0OiB2aWV3UG9ydCwgdmlld1BvcnRJbnN0cnVjdGlvbjogdmlld1BvcnRJbnN0cnVjdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZHMucHVzaCh2aWV3UG9ydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJvY2Vzcyh2aWV3UG9ydEluc3RydWN0aW9uLCB3YWl0VG9Td2FwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjaGlsZE5hdkluc3RydWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGROYXZJbnN0cnVjdGlvbi5fY29tbWl0Q2hhbmdlcyh3YWl0VG9Td2FwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpOyB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROYXZJbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRzLnB1c2goY2hpbGROYXZJbnN0cnVjdGlvbi5fY29tbWl0Q2hhbmdlcyh3YWl0VG9Td2FwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIHZpZXdQb3J0TmFtZSBpbiB2aWV3UG9ydEluc3RydWN0aW9ucykge1xyXG4gICAgICAgICAgICBfbG9vcF8xKHZpZXdQb3J0TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlXHJcbiAgICAgICAgICAgIC5hbGwobG9hZHMpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZGVsYXlTd2Fwcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZpZXdQb3J0LnN3YXAoeC52aWV3UG9ydEluc3RydWN0aW9uKTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBydW5lKF90aGlzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqQGludGVybmFsICovXHJcbiAgICBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5fYnVpbGRUaXRsZShyb3V0ZXIudGl0bGVTZXBhcmF0b3IpO1xyXG4gICAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICByb3V0ZXIuaGlzdG9yeS5zZXRUaXRsZSh0aXRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKkBpbnRlcm5hbCAqL1xyXG4gICAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5fYnVpbGRUaXRsZSA9IGZ1bmN0aW9uIChzZXBhcmF0b3IpIHtcclxuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gJyB8ICc7IH1cclxuICAgICAgICB2YXIgdGl0bGUgPSAnJztcclxuICAgICAgICB2YXIgY2hpbGRUaXRsZXMgPSBbXTtcclxuICAgICAgICB2YXIgbmF2TW9kZWxUaXRsZSA9IHRoaXMuY29uZmlnLm5hdk1vZGVsLnRpdGxlO1xyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvblJvdXRlciA9IHRoaXMucm91dGVyO1xyXG4gICAgICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9ucyA9IHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnM7XHJcbiAgICAgICAgaWYgKG5hdk1vZGVsVGl0bGUpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBpbnN0cnVjdGlvblJvdXRlci50cmFuc2Zvcm1UaXRsZShuYXZNb2RlbFRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHZpZXdQb3J0SW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9uID0gdmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkX25hdl9pbnN0cnVjdGlvbiA9IHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgIGlmIChjaGlsZF9uYXZfaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFRpdGxlID0gY2hpbGRfbmF2X2luc3RydWN0aW9uLl9idWlsZFRpdGxlKHNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVGl0bGVzLnB1c2goY2hpbGRUaXRsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkVGl0bGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aXRsZSA9IGNoaWxkVGl0bGVzLmpvaW4oc2VwYXJhdG9yKSArICh0aXRsZSA/IHNlcGFyYXRvciA6ICcnKSArIHRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25Sb3V0ZXIudGl0bGUpIHtcclxuICAgICAgICAgICAgdGl0bGUgKz0gKHRpdGxlID8gc2VwYXJhdG9yIDogJycpICsgaW5zdHJ1Y3Rpb25Sb3V0ZXIudHJhbnNmb3JtVGl0bGUoaW5zdHJ1Y3Rpb25Sb3V0ZXIudGl0bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGl0bGU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5hdmlnYXRpb25JbnN0cnVjdGlvbjtcclxufSgpKTtcclxudmFyIHBydW5lID0gZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICBpbnN0cnVjdGlvbi5wcmV2aW91c0luc3RydWN0aW9uID0gbnVsbDtcclxuICAgIGluc3RydWN0aW9uLnBsYW4gPSBudWxsO1xyXG59O1xuXG4vKipcclxuKiBDbGFzcyBmb3Igc3RvcmluZyBhbmQgaW50ZXJhY3Rpbmcgd2l0aCBhIHJvdXRlJ3MgbmF2aWdhdGlvbiBzZXR0aW5ncy5cclxuKi9cclxudmFyIE5hdk1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmF2TW9kZWwocm91dGVyLCByZWxhdGl2ZUhyZWYpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRydWUgaWYgdGhpcyBuYXYgaXRlbSBpcyBjdXJyZW50bHkgYWN0aXZlLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHRpdGxlLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGlzIG5hdiBpdGVtJ3MgYWJzb2x1dGUgaHJlZi5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaHJlZiA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGlzIG5hdiBpdGVtJ3MgcmVsYXRpdmUgaHJlZi5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVsYXRpdmVIcmVmID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIERhdGEgYXR0YWNoZWQgdG8gdGhlIHJvdXRlIGF0IGNvbmZpZ3VyYXRpb24gdGltZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSByb3V0ZSBjb25maWcuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5yZWxhdGl2ZUhyZWYgPSByZWxhdGl2ZUhyZWY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgcm91dGUncyB0aXRsZSBhbmQgdXBkYXRlcyBkb2N1bWVudC50aXRsZS5cclxuICAgICogIElmIHRoZSBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHRoZSBjaGFuZ2Ugd2lsbCBiZSBhcHBsaWVkXHJcbiAgICAqICB0byBkb2N1bWVudC50aXRsZSB3aGVuIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlcy5cclxuICAgICpcclxuICAgICogQHBhcmFtIHRpdGxlIFRoZSBuZXcgdGl0bGUuXHJcbiAgICAqL1xyXG4gICAgTmF2TW9kZWwucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLnVwZGF0ZVRpdGxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOYXZNb2RlbDtcclxufSgpKTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUFic29sdXRlUGF0aChwYXRoLCBoYXNQdXNoU3RhdGUsIGFic29sdXRlKSB7XHJcbiAgICBpZiAoYWJzb2x1dGUgPT09IHZvaWQgMCkgeyBhYnNvbHV0ZSA9IGZhbHNlOyB9XHJcbiAgICBpZiAoIWhhc1B1c2hTdGF0ZSAmJiBwYXRoWzBdICE9PSAnIycpIHtcclxuICAgICAgICBwYXRoID0gJyMnICsgcGF0aDtcclxuICAgIH1cclxuICAgIGlmIChoYXNQdXNoU3RhdGUgJiYgYWJzb2x1dGUpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSwgcGF0aC5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZVJvb3RlZFBhdGgoZnJhZ21lbnQsIGJhc2VVcmwsIGhhc1B1c2hTdGF0ZSwgYWJzb2x1dGUpIHtcclxuICAgIGlmIChpc0Fic29sdXRlVXJsLnRlc3QoZnJhZ21lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSAnJztcclxuICAgIGlmIChiYXNlVXJsLmxlbmd0aCAmJiBiYXNlVXJsWzBdICE9PSAnLycpIHtcclxuICAgICAgICBwYXRoICs9ICcvJztcclxuICAgIH1cclxuICAgIHBhdGggKz0gYmFzZVVybDtcclxuICAgIGlmICgoIXBhdGgubGVuZ3RoIHx8IHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nKSAmJiBmcmFnbWVudFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgcGF0aCArPSAnLyc7XHJcbiAgICB9XHJcbiAgICBpZiAocGF0aC5sZW5ndGggJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgJiYgZnJhZ21lbnRbMF0gPT09ICcvJykge1xyXG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9ub3JtYWxpemVBYnNvbHV0ZVBhdGgocGF0aCArIGZyYWdtZW50LCBoYXNQdXNoU3RhdGUsIGFic29sdXRlKTtcclxufVxyXG5mdW5jdGlvbiBfcmVzb2x2ZVVybChmcmFnbWVudCwgYmFzZVVybCwgaGFzUHVzaFN0YXRlKSB7XHJcbiAgICBpZiAoaXNSb290ZWRQYXRoLnRlc3QoZnJhZ21lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ub3JtYWxpemVBYnNvbHV0ZVBhdGgoZnJhZ21lbnQsIGhhc1B1c2hTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2NyZWF0ZVJvb3RlZFBhdGgoZnJhZ21lbnQsIGJhc2VVcmwsIGhhc1B1c2hTdGF0ZSk7XHJcbn1cclxuZnVuY3Rpb24gX2Vuc3VyZUFycmF5V2l0aFNpbmdsZVJvdXRlUGVyQ29uZmlnKGNvbmZpZykge1xyXG4gICAgdmFyIHJvdXRlQ29uZmlncyA9IFtdO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnJvdXRlKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbmZpZy5yb3V0ZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICAgICAgY3VycmVudC5yb3V0ZSA9IGNvbmZpZy5yb3V0ZVtpXTtcclxuICAgICAgICAgICAgcm91dGVDb25maWdzLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcm91dGVDb25maWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm91dGVDb25maWdzO1xyXG59XHJcbnZhciBpc1Jvb3RlZFBhdGggPSAvXiM/XFwvLztcclxudmFyIGlzQWJzb2x1dGVVcmwgPSAvXihbYS16XVthLXowLTkrXFwtLl0qOik/XFwvXFwvL2k7XG5cbi8qKlxyXG4gKiBDbGFzcyB1c2VkIHRvIGNvbmZpZ3VyZSBhIFtbUm91dGVyXV0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFJvdXRlckNvbmZpZ3VyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZXJDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5waXBlbGluZVN0ZXBzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGVwIHRvIGJlIHJ1biBkdXJpbmcgdGhlIFtbUm91dGVyXV0ncyBuYXZpZ2F0aW9uIHBpcGVsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwaXBlbGluZSBzbG90IHRvIGluc2VydCB0aGUgc3RlcCBpbnRvLlxyXG4gICAgICogQHBhcmFtIHN0ZXAgVGhlIHBpcGVsaW5lIHN0ZXAuXHJcbiAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIFJvdXRlckNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmFkZFBpcGVsaW5lU3RlcCA9IGZ1bmN0aW9uIChuYW1lLCBzdGVwKSB7XHJcbiAgICAgICAgaWYgKHN0ZXAgPT09IG51bGwgfHwgc3RlcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZWxpbmUgc3RlcCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGlwZWxpbmVTdGVwcy5wdXNoKHsgbmFtZTogbmFtZSwgc3RlcDogc3RlcCB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGVwIHRvIGJlIHJ1biBkdXJpbmcgdGhlIFtbUm91dGVyXV0ncyBhdXRob3JpemUgcGlwZWxpbmUgc2xvdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RlcCBUaGUgcGlwZWxpbmUgc3RlcC5cclxuICAgICAqIEBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYWRkQXV0aG9yaXplU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUGlwZWxpbmVTdGVwKFwiYXV0aG9yaXplXCIgLyogQXV0aG9yaXplICovLCBzdGVwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGVwIHRvIGJlIHJ1biBkdXJpbmcgdGhlIFtbUm91dGVyXV0ncyBwcmVBY3RpdmF0ZSBwaXBlbGluZSBzbG90LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGVwIFRoZSBwaXBlbGluZSBzdGVwLlxyXG4gICAgICogQGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRQcmVBY3RpdmF0ZVN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZFBpcGVsaW5lU3RlcChcInByZUFjdGl2YXRlXCIgLyogUHJlQWN0aXZhdGUgKi8sIHN0ZXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN0ZXAgdG8gYmUgcnVuIGR1cmluZyB0aGUgW1tSb3V0ZXJdXSdzIHByZVJlbmRlciBwaXBlbGluZSBzbG90LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGVwIFRoZSBwaXBlbGluZSBzdGVwLlxyXG4gICAgICogQGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRQcmVSZW5kZXJTdGVwID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRQaXBlbGluZVN0ZXAoXCJwcmVSZW5kZXJcIiAvKiBQcmVSZW5kZXIgKi8sIHN0ZXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN0ZXAgdG8gYmUgcnVuIGR1cmluZyB0aGUgW1tSb3V0ZXJdXSdzIHBvc3RSZW5kZXIgcGlwZWxpbmUgc2xvdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RlcCBUaGUgcGlwZWxpbmUgc3RlcC5cclxuICAgICAqIEBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYWRkUG9zdFJlbmRlclN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZFBpcGVsaW5lU3RlcChcInBvc3RSZW5kZXJcIiAvKiBQb3N0UmVuZGVyICovLCBzdGVwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgYSByb3V0ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBwcmV2aW91cyBsb2NhdGlvbiBhdmFpbGFibGUgb24gbmF2aWdhdGlvbiBjYW5jZWxsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZyYWdtZW50IFRoZSBVUkwgZnJhZ21lbnQgdG8gdXNlIGFzIHRoZSBuYXZpZ2F0aW9uIGRlc3RpbmF0aW9uLlxyXG4gICAgICogQGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5mYWxsYmFja1JvdXRlID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fZmFsbGJhY2tSb3V0ZSA9IGZyYWdtZW50O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBvbmUgb3IgbW9yZSByb3V0ZXMgdG8gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSByb3V0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvdXRlIFRoZSBbW1JvdXRlQ29uZmlnXV0gdG8gbWFwLCBvciBhbiBhcnJheSBvZiBbW1JvdXRlQ29uZmlnXV0gdG8gbWFwLlxyXG4gICAgICogQGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvdXRlKSkge1xyXG4gICAgICAgICAgICByb3V0ZS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy5tYXAocik7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwUm91dGUocm91dGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyBkZWZhdWx0cyB0byB1c2UgZm9yIGFueSB2aWV3IHBvcnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aWV3UG9ydENvbmZpZyBhIHZpZXcgcG9ydCBjb25maWd1cmF0aW9uIG9iamVjdCB0byB1c2UgYXMgYVxyXG4gICAgICogIGRlZmF1bHQsIG9mIHRoZSBmb3JtIHsgdmlld1BvcnROYW1lOiB7IG1vZHVsZUlkIH0gfS5cclxuICAgICAqIEBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUudXNlVmlld1BvcnREZWZhdWx0cyA9IGZ1bmN0aW9uICh2aWV3UG9ydENvbmZpZykge1xyXG4gICAgICAgIHRoaXMudmlld1BvcnREZWZhdWx0cyA9IHZpZXdQb3J0Q29uZmlnO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHNpbmdsZSByb3V0ZSB0byBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHJvdXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm91dGUgVGhlIFtbUm91dGVDb25maWddXSB0byBtYXAuXHJcbiAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIFJvdXRlckNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLm1hcFJvdXRlID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgICAgICB2YXIgcm91dGVDb25maWdzID0gX2Vuc3VyZUFycmF5V2l0aFNpbmdsZVJvdXRlUGVyQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHZhciBuYXZNb2RlbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcm91dGVDb25maWdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3V0ZUNvbmZpZyA9IHJvdXRlQ29uZmlnc1tpXTtcclxuICAgICAgICAgICAgICAgIHJvdXRlQ29uZmlnLnNldHRpbmdzID0gcm91dGVDb25maWcuc2V0dGluZ3MgfHwge307XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hdk1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmF2TW9kZWwgPSByb3V0ZXIuY3JlYXRlTmF2TW9kZWwocm91dGVDb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm91dGVyLmFkZFJvdXRlKHJvdXRlQ29uZmlnLCBuYXZNb2RlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiB1bmtub3duIHJvdXRlIGhhbmRsZXIgdG8gYmUgcnVuIHdoZW4gdGhlIFVSTCBmcmFnbWVudCBkb2Vzbid0IG1hdGNoIGFueSByZWdpc3RlcmVkIHJvdXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSBtb2R1bGVJZCB0byBsb2FkLCBvciBhIFtbUm91dGVDb25maWddXSwgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZVxyXG4gICAgICogIFtbTmF2aWdhdGlvbkluc3RydWN0aW9uXV0gYW5kIHNlbGVjdHMgYSBtb2R1bGVJZCB0byBsb2FkLlxyXG4gICAgICogQGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5tYXBVbmtub3duUm91dGVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMudW5rbm93blJvdXRlQ29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIHRvIHRoZSBzcGVjaWZpZWQgW1tSb3V0ZXJdXS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm91dGVyIFRoZSBbW1JvdXRlcl1dIHRvIGFwcGx5IHRoZSBjb25maWd1cmF0aW9uIHRvLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5leHBvcnRUb1JvdXRlciA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2ldKHJvdXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRpdGxlID0gX2EudGl0bGUsIHRpdGxlU2VwYXJhdG9yID0gX2EudGl0bGVTZXBhcmF0b3IsIHVua25vd25Sb3V0ZUNvbmZpZyA9IF9hLnVua25vd25Sb3V0ZUNvbmZpZywgX2ZhbGxiYWNrUm91dGUgPSBfYS5fZmFsbGJhY2tSb3V0ZSwgdmlld1BvcnREZWZhdWx0cyA9IF9hLnZpZXdQb3J0RGVmYXVsdHM7XHJcbiAgICAgICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGl0bGVTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcm91dGVyLnRpdGxlU2VwYXJhdG9yID0gdGl0bGVTZXBhcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmtub3duUm91dGVDb25maWcpIHtcclxuICAgICAgICAgICAgcm91dGVyLmhhbmRsZVVua25vd25Sb3V0ZXModW5rbm93blJvdXRlQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9mYWxsYmFja1JvdXRlKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci5mYWxsYmFja1JvdXRlID0gX2ZhbGxiYWNrUm91dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3UG9ydERlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci51c2VWaWV3UG9ydERlZmF1bHRzKHZpZXdQb3J0RGVmYXVsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKHJvdXRlci5vcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBwaXBlbGluZVN0ZXBzID0gdGhpcy5waXBlbGluZVN0ZXBzO1xyXG4gICAgICAgIHZhciBwaXBlbGluZVN0ZXBDb3VudCA9IHBpcGVsaW5lU3RlcHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwaXBlbGluZVN0ZXBDb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoIXJvdXRlci5pc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZWxpbmUgc3RlcHMgY2FuIG9ubHkgYmUgYWRkZWQgdG8gdGhlIHJvb3Qgcm91dGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBpcGVsaW5lUHJvdmlkZXIgPSByb3V0ZXIucGlwZWxpbmVQcm92aWRlcjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGlwZWxpbmVTdGVwQ291bnQ7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBwaXBlbGluZVN0ZXBzW2ldLCBuYW1lXzEgPSBfYi5uYW1lLCBzdGVwID0gX2Iuc3RlcDtcclxuICAgICAgICAgICAgICAgIHBpcGVsaW5lUHJvdmlkZXIuYWRkU3RlcChuYW1lXzEsIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSb3V0ZXJDb25maWd1cmF0aW9uO1xyXG59KCkpO1xuXG4vKipcclxuICogVGhlIHByaW1hcnkgY2xhc3MgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHJvdXRpbmcgYW5kIG5hdmlnYXRpb24uXHJcbiAqL1xyXG52YXIgUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIFRoZSBbW0NvbnRhaW5lcl1dIHRvIHVzZSB3aGVuIGNoaWxkIHJvdXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gaGlzdG9yeSBUaGUgW1tIaXN0b3J5XV0gaW1wbGVtZW50YXRpb24gdG8gZGVsZWdhdGUgbmF2aWdhdGlvbiByZXF1ZXN0cyB0by5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUm91dGVyKGNvbnRhaW5lciwgaGlzdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBhcmVudCByb3V0ZXIsIG9yIG51bGwgaWYgdGhpcyBpbnN0YW5jZSBpcyBub3QgYSBjaGlsZCByb3V0ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0cyB1c2VkIHdoZW4gYSB2aWV3cG9ydCBsYWNrcyBzcGVjaWZpZWQgY29udGVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlld1BvcnREZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4dGVuc2lvbiBwb2ludCB0byB0cmFuc2Zvcm0gdGhlIGRvY3VtZW50IHRpdGxlIGJlZm9yZSBpdCBpcyBidWlsdCBhbmQgZGlzcGxheWVkLlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGNoaWxkIHJvdXRlcnMgZGVsZWdhdGUgdG8gdGhlIHBhcmVudCByb3V0ZXIsIGFuZCB0aGUgYXBwIHJvdXRlclxyXG4gICAgICAgICAqIHJldHVybnMgdGhlIHRpdGxlIHVuY2hhbmdlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybVRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wYXJlbnQudHJhbnNmb3JtVGl0bGUodGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aXRsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGdWxseSByZXNldHMgdGhlIHJvdXRlcidzIGludGVybmFsIHN0YXRlLiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBmcmFtZXdvcmsgd2hlbiBtdWx0aXBsZSBjYWxscyB0byBzZXRSb290IGFyZSBtYWRlLlxyXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiAoYWN0dWFsbHksIGF2b2lkIHVzaW5nIHRoaXMpLiBEbyBub3QgdXNlIHRoaXMgdG8gc2ltcGx5IGNoYW5nZSB5b3VyIG5hdmlnYXRpb24gbW9kZWwuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnZpZXdQb3J0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMucm91dGVzID0gW107XHJcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gJyc7XHJcbiAgICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzTmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNFeHBsaWNpdE5hdmlnYXRpb24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRXhwbGljaXROYXZpZ2F0aW9uQmFjayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOYXZpZ2F0aW5nRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzTmF2aWdhdGluZ05ldyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOYXZpZ2F0aW5nUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOYXZpZ2F0aW5nRm9yd2FyZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOYXZpZ2F0aW5nQmFjayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY291bGREZWFjdGl2YXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gW107XHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlld1BvcnREZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrT3JkZXIgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5fcmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcclxuICAgICAgICB0aGlzLl9jaGlsZFJlY29nbml6ZXIgPSBuZXcgUm91dGVSZWNvZ25pemVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlndXJlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZUNvbmZpZ3VyZWRQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyLnByb3RvdHlwZSwgXCJpc1Jvb3RcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgW1tSb3V0ZXJdXSBpcyB0aGUgcm9vdCBpbiB0aGUgcm91dGVyIHRyZWUuIEkuZS4sIGl0IGhhcyBubyBwYXJlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIHZpZXdQb3J0IHRvIGJlIHVzZWQgYXMgYSByZW5kZXJpbmcgdGFyZ2V0IGZvciBhY3RpdmF0ZWQgcm91dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aWV3UG9ydCBUaGUgdmlld1BvcnQuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmlld1BvcnQuICdkZWZhdWx0JyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5yZWdpc3RlclZpZXdQb3J0ID0gZnVuY3Rpb24gKHZpZXdQb3J0LCBuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMudmlld1BvcnRzW25hbWVdID0gdmlld1BvcnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJvdXRlciBpcyBjb25maWd1cmVkLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmVuc3VyZUNvbmZpZ3VyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZWRQcm9taXNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgcm91dGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja09yQ29uZmlnIFRoZSBbW1JvdXRlckNvbmZpZ3VyYXRpb25dXSBvciBhIGNhbGxiYWNrIHRoYXQgdGFrZXMgYSBbW1JvdXRlckNvbmZpZ3VyYXRpb25dXS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAoY2FsbGJhY2tPckNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFja09yQ29uZmlnO1xyXG4gICAgICAgIHZhciBjb25maWc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja09yQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBSb3V0ZXJDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrT3JDb25maWcoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VcclxuICAgICAgICAgICAgLnJlc29sdmUocmVzdWx0KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICBpZiAoYyAmJiBjLmV4cG9ydFRvUm91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbmZpZy5leHBvcnRUb1JvdXRlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmlzQ29uZmlndXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlQ29uZmlndXJlZFByb21pc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyB0byBhIG5ldyBsb2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnQgVGhlIFVSTCBmcmFnbWVudCB0byB1c2UgYXMgdGhlIG5hdmlnYXRpb24gZGVzdGluYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgbmF2aWdhdGlvbiBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKGZyYWdtZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29uZmlndXJlZCAmJiB0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzRXhwbGljaXROYXZpZ2F0aW9uID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaXN0b3J5Lm5hdmlnYXRlKF9yZXNvbHZlVXJsKGZyYWdtZW50LCB0aGlzLmJhc2VVcmwsIHRoaXMuaGlzdG9yeS5faGFzUHVzaFN0YXRlKSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gYSBuZXcgbG9jYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgcm91dGUgYW5kIHBhcmFtcyBzcGVjaWZpZWQuIEVxdWl2YWxsZW50IHRvIFtbUm91dGVyLmdlbmVyYXRlXV0gZm9sbG93ZWRcclxuICAgICAqIGJ5IFtbUm91dGVyLm5hdmlnYXRlXV0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvdXRlIFRoZSBuYW1lIG9mIHRoZSByb3V0ZSB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBuYXZpZ2F0aW9uIGxvY2F0aW9uLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcm91dGUgcGFyYW1ldGVycyB0byBiZSB1c2VkIHdoZW4gcG9wdWxhdGluZyB0aGUgcm91dGUgcGF0dGVybi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBuYXZpZ2F0aW9uIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVUb1JvdXRlID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2VuZXJhdGUocm91dGUsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGUocGF0aCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgYmFjayB0byB0aGUgbW9zdCByZWNlbnQgbG9jYXRpb24gaW4gaGlzdG9yeS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0TmF2aWdhdGlvbkJhY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeS5uYXZpZ2F0ZUJhY2soKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCByb3V0ZXIgb2YgdGhlIGN1cnJlbnQgcm91dGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgVGhlIFtbQ29udGFpbmVyXV0gdG8gcHJvdmlkZSB0byB0aGUgY2hpbGQgcm91dGVyLiBVc2VzIHRoZSBjdXJyZW50IFtbUm91dGVyXV0ncyBbW0NvbnRhaW5lcl1dIGlmIHVuc3BlY2lmaWVkLlxyXG4gICAgICogQHJldHVybnMge1JvdXRlcn0gVGhlIG5ldyBjaGlsZCBSb3V0ZXIuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuY3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUm91dGVyID0gbmV3IFJvdXRlcihjb250YWluZXIgfHwgdGhpcy5jb250YWluZXIuY3JlYXRlQ2hpbGQoKSwgdGhpcy5oaXN0b3J5KTtcclxuICAgICAgICBjaGlsZFJvdXRlci5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBjaGlsZFJvdXRlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmcmFnbWVudCBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHJvdXRlIHBhdHRlcm4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHJvdXRlIHdob3NlIHBhdHRlcm4gc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGZyYWdtZW50LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcm91dGUgcGFyYW1zIHRvIGJlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHJvdXRlIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJZiBvcHRpb25zLmFic29sdXRlID0gdHJ1ZSwgdGhlbiBhYnNvbHV0ZSB1cmwgd2lsbCBiZSBnZW5lcmF0ZWQ7IG90aGVyd2lzZSwgaXQgd2lsbCBiZSByZWxhdGl2ZSB1cmwuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgVVJMIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKG5hbWVPclJvdXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIC8vIEEgY2hpbGQgcmVjb2duaXplciBnZW5lcmF0ZXMgcm91dGVzIGZvciBwb3RlbnRpYWwgY2hpbGQgcm91dGVzLiBBbnkgcG90ZW50aWFsIGNoaWxkIHJvdXRlIGlzIGFkZGVkXHJcbiAgICAgICAgLy8gdG8gdGhlIGNoaWxkUm91dGUgcHJvcGVydHkgb2YgcGFyYW1zIGZvciB0aGUgY2hpbGRSb3V0ZXIgdG8gcmVjb2duaXplLiBXaGVuIGdlbmVyYXRpbmcgcm91dGVzLCB3ZVxyXG4gICAgICAgIC8vIHVzZSB0aGUgY2hpbGRSZWNvZ25pemVyIHdoZW4gY2hpbGRSb3V0ZSBwYXJhbXMgYXJlIGF2YWlsYWJsZSB0byBnZW5lcmF0ZSBhIGNoaWxkIHJvdXRlciBlbmFibGVkIHJvdXRlLlxyXG4gICAgICAgIHZhciByZWNvZ25pemVyID0gJ2NoaWxkUm91dGUnIGluIHBhcmFtcyA/IHRoaXMuX2NoaWxkUmVjb2duaXplciA6IHRoaXMuX3JlY29nbml6ZXI7XHJcbiAgICAgICAgdmFyIGhhc1JvdXRlID0gcmVjb2duaXplci5oYXNSb3V0ZShuYW1lT3JSb3V0ZSk7XHJcbiAgICAgICAgaWYgKCFoYXNSb3V0ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZW5lcmF0ZShuYW1lT3JSb3V0ZSwgcGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lT3JSb3V0ZSArIFwiJyBjb3VsZCBub3QgYmUgZm91bmQuIENoZWNrIHRoYXQgYG5hbWU6ICdcIiArIG5hbWVPclJvdXRlICsgXCInYCB3YXMgc3BlY2lmaWVkIGluIHRoZSByb3V0ZSdzIGNvbmZpZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gcmVjb2duaXplci5nZW5lcmF0ZShuYW1lT3JSb3V0ZSwgcGFyYW1zKTtcclxuICAgICAgICB2YXIgcm9vdGVkUGF0aCA9IF9jcmVhdGVSb290ZWRQYXRoKHBhdGgsIHRoaXMuYmFzZVVybCwgdGhpcy5oaXN0b3J5Ll9oYXNQdXNoU3RhdGUsIG9wdGlvbnMuYWJzb2x1dGUpO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmFic29sdXRlID8gXCJcIiArIHRoaXMuaGlzdG9yeS5nZXRBYnNvbHV0ZVJvb3QoKSArIHJvb3RlZFBhdGggOiByb290ZWRQYXRoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFtbTmF2TW9kZWxdXSBmb3IgdGhlIHNwZWNpZmllZCByb3V0ZSBjb25maWcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgcm91dGUgY29uZmlnLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmNyZWF0ZU5hdk1vZGVsID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBuYXZNb2RlbCA9IG5ldyBOYXZNb2RlbCh0aGlzLCAnaHJlZicgaW4gY29uZmlnXHJcbiAgICAgICAgICAgID8gY29uZmlnLmhyZWZcclxuICAgICAgICAgICAgLy8gcG90ZW50aWFsIGVycm9yIHdoZW4gY29uZmlnLnJvdXRlIGlzIGEgc3RyaW5nW10gP1xyXG4gICAgICAgICAgICA6IGNvbmZpZy5yb3V0ZSk7XHJcbiAgICAgICAgbmF2TW9kZWwudGl0bGUgPSBjb25maWcudGl0bGU7XHJcbiAgICAgICAgbmF2TW9kZWwub3JkZXIgPSBjb25maWcubmF2O1xyXG4gICAgICAgIG5hdk1vZGVsLmhyZWYgPSBjb25maWcuaHJlZjtcclxuICAgICAgICBuYXZNb2RlbC5zZXR0aW5ncyA9IGNvbmZpZy5zZXR0aW5ncztcclxuICAgICAgICBuYXZNb2RlbC5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgcmV0dXJuIG5hdk1vZGVsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHJvdXRlIHdpdGggdGhlIHJvdXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBbW1JvdXRlQ29uZmlnXV0uXHJcbiAgICAgKiBAcGFyYW0gbmF2TW9kZWwgVGhlIFtbTmF2TW9kZWxdXSB0byB1c2UgZm9yIHRoZSByb3V0ZS4gTWF5IGJlIG9taXR0ZWQgZm9yIHNpbmdsZS1wYXR0ZXJuIHJvdXRlcy5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZSA9IGZ1bmN0aW9uIChjb25maWcsIG5hdk1vZGVsKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnJvdXRlKSkge1xyXG4gICAgICAgICAgICB2YXIgcm91dGVDb25maWdzID0gX2Vuc3VyZUFycmF5V2l0aFNpbmdsZVJvdXRlUGVyQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgaXMgd3JvbmcuIHRvZG86IGZpeCB0aGlzIGFmdGVyIFRTIHJlZmFjdG9yaW5nIHJlbGVhc2VcclxuICAgICAgICAgICAgcm91dGVDb25maWdzLmZvckVhY2godGhpcy5hZGRSb3V0ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZVJvdXRlQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKCEoJ3ZpZXdQb3J0cycgaW4gY29uZmlnKSAmJiAhY29uZmlnLm5hdmlnYXRpb25TdHJhdGVneSkge1xyXG4gICAgICAgICAgICBjb25maWcudmlld1BvcnRzID0ge1xyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGNvbmZpZy5tb2R1bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb25maWcudmlld1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5hdk1vZGVsKSB7XHJcbiAgICAgICAgICAgIG5hdk1vZGVsID0gdGhpcy5jcmVhdGVOYXZNb2RlbChjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvdXRlcy5wdXNoKGNvbmZpZyk7XHJcbiAgICAgICAgdmFyIHBhdGggPSBjb25maWcucm91dGU7XHJcbiAgICAgICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FzZVNlbnNpdGl2ZSA9IGNvbmZpZy5jYXNlU2Vuc2l0aXZlID09PSB0cnVlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlY29nbml6ZXIuYWRkKHtcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgaGFuZGxlcjogY29uZmlnLFxyXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBjYXNlU2Vuc2l0aXZlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gY29uZmlnLnNldHRpbmdzO1xyXG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLnNldHRpbmdzO1xyXG4gICAgICAgICAgICB2YXIgd2l0aENoaWxkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25maWcpKTtcclxuICAgICAgICAgICAgY29uZmlnLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHdpdGhDaGlsZC5yb3V0ZSA9IHBhdGggKyBcIi8qY2hpbGRSb3V0ZVwiO1xyXG4gICAgICAgICAgICB3aXRoQ2hpbGQuaGFzQ2hpbGRSb3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGlsZFJlY29nbml6ZXIuYWRkKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IHdpdGhDaGlsZC5yb3V0ZSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IHdpdGhDaGlsZCxcclxuICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGNhc2VTZW5zaXRpdmVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdpdGhDaGlsZC5uYXZNb2RlbCA9IG5hdk1vZGVsO1xyXG4gICAgICAgICAgICB3aXRoQ2hpbGQuc2V0dGluZ3MgPSBjb25maWcuc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHdpdGhDaGlsZC5uYXZpZ2F0aW9uU3RyYXRlZ3kgPSBjb25maWcubmF2aWdhdGlvblN0cmF0ZWd5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcubmF2TW9kZWwgPSBuYXZNb2RlbDtcclxuICAgICAgICB2YXIgbmF2aWdhdGlvbiA9IHRoaXMubmF2aWdhdGlvbjtcclxuICAgICAgICBpZiAoKG5hdk1vZGVsLm9yZGVyIHx8IG5hdk1vZGVsLm9yZGVyID09PSAwKSAmJiBuYXZpZ2F0aW9uLmluZGV4T2YobmF2TW9kZWwpID09PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoKCFuYXZNb2RlbC5ocmVmICYmIG5hdk1vZGVsLmhyZWYgIT09ICcnKSAmJiAoc3RhdGUudHlwZXMuZHluYW1pY3MgfHwgc3RhdGUudHlwZXMuc3RhcnMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm91dGUgY29uZmlnIGZvciBcIicgKyBjb25maWcucm91dGUgKyAnXCIgOiBkeW5hbWljIHJvdXRlcyBtdXN0IHNwZWNpZnkgYW4gXCJocmVmOlwiIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuYXZpZ2F0aW9uIG1vZGVsLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2TW9kZWwub3JkZXIgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBuYXZNb2RlbC5vcmRlciA9ICsrdGhpcy5fZmFsbGJhY2tPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uLnB1c2gobmF2TW9kZWwpO1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcG90ZW50aWFsIGVycm9yIC8gaW5jb25zaXN0ZW5jeSBiZXR3ZWVuIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxyXG4gICAgICAgICAgICAvLyBJZiBjb21wYXJlRnVuY3Rpb24oYSwgYikgcmV0dXJucyAwLCBsZWF2ZSBhIGFuZCBiIHVuY2hhbmdlZCB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlcixcclxuICAgICAgICAgICAgLy8gYnV0IHNvcnRlZCB3aXRoIHJlc3BlY3QgdG8gYWxsIGRpZmZlcmVudCBlbGVtZW50cy5cclxuICAgICAgICAgICAgLy8gTm90ZTogdGhlIEVDTUFzY3JpcHQgc3RhbmRhcmQgZG9lcyBub3QgZ3VhcmFudGVlIHRoaXMgYmVoYXZpb3VyLFxyXG4gICAgICAgICAgICAvLyBhbmQgdGh1cyBub3QgYWxsIGJyb3dzZXJzIChlLmcuIE1vemlsbGEgdmVyc2lvbnMgZGF0aW5nIGJhY2sgdG8gYXQgbGVhc3QgMjAwMykgcmVzcGVjdCB0aGlzLlxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFtbUm91dGVyXV0gb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGEgcm91dGUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcm91dGUgdG8gY2hlY2suXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuaGFzUm91dGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLl9yZWNvZ25pemVyLmhhc1JvdXRlKG5hbWUpIHx8IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmhhc1JvdXRlKG5hbWUpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgW1tSb3V0ZXJdXSBoYXMgYSByb3V0ZSByZWdpc3RlcmVkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByb3V0ZSB0byBjaGVjay5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5oYXNPd25Sb3V0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuaGFzUm91dGUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGluY29taW5nIFVSTCBmcmFnbWVudCBkb2Vzbid0IG1hdGNoIGFueSByZWdpc3RlcmVkIHJvdXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBtb2R1bGVJZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHNlbGVjdHMgdGhlIG1vZHVsZUlkLCBvciBhIFtbUm91dGVDb25maWddXS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5oYW5kbGVVbmtub3duUm91dGVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFjb25maWcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVua25vd24gcm91dGUgaGFuZGxlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhdGNoQWxsSGFuZGxlciA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXNcclxuICAgICAgICAgICAgICAgIC5fY3JlYXRlUm91dGVDb25maWcoY29uZmlnLCBpbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb25maWcgPSBjO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZG9jdW1lbnQgdGl0bGUgdXNpbmcgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBpbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50Um91dGVyID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudFJvdXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Um91dGVyLnVwZGF0ZVRpdGxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdXJyZW50SW5zdHJ1Y3Rpb24gPSB0aGlzLmN1cnJlbnRJbnN0cnVjdGlvbjtcclxuICAgICAgICBpZiAoY3VycmVudEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJbnN0cnVjdGlvbi5fdXBkYXRlVGl0bGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIG5hdmlnYXRpb24gcm91dGVzIHdpdGggaHJlZnMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24uXHJcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCB3aWxsIGxpa2VseSBtb3ZlIHRvIGEgcGx1Z2luIGluIGEgZnV0dXJlIHJlbGVhc2UuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVmcmVzaE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2aWdhdGlvbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBuYXYubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG5hdltpXTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50LmNvbmZpZy5ocmVmKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmhyZWYgPSBfY3JlYXRlUm9vdGVkUGF0aChjdXJyZW50LnJlbGF0aXZlSHJlZiwgdGhpcy5iYXNlVXJsLCB0aGlzLmhpc3RvcnkuX2hhc1B1c2hTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmhyZWYgPSBfbm9ybWFsaXplQWJzb2x1dGVQYXRoKGN1cnJlbnQuY29uZmlnLmhyZWYsIHRoaXMuaGlzdG9yeS5faGFzUHVzaFN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgdGhlIHZpZXcgcG9ydHMuIFRoaXMgc3BlY2lmaWVzIGhvdyB0b1xyXG4gICAgICogIHBvcHVsYXRlIGEgdmlldyBwb3J0IGZvciB3aGljaCBubyBtb2R1bGUgaXMgc3BlY2lmaWVkLiBUaGUgZGVmYXVsdCBpc1xyXG4gICAgICogIGFuIGVtcHR5IHZpZXcvdmlldy1tb2RlbCBwYWlyLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLnVzZVZpZXdQb3J0RGVmYXVsdHMgPSBmdW5jdGlvbiAoJHZpZXdQb3J0RGVmYXVsdHMpIHtcclxuICAgICAgICAvLyBhIHdvcmthcm91bmQgdG8gaGF2ZSBzdHJvbmcgdHlwaW5ncyB3aGlsZSBub3QgcmVxdWlyaW5nIHRvIGV4cG9zZSBpbnRlcmZhY2UgVmlld1BvcnRJbnN0cnVjdGlvblxyXG4gICAgICAgIHZhciB2aWV3UG9ydERlZmF1bHRzID0gJHZpZXdQb3J0RGVmYXVsdHM7XHJcbiAgICAgICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHZpZXdQb3J0RGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdQb3J0Q29uZmlnID0gdmlld1BvcnREZWZhdWx0c1t2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdQb3J0RGVmYXVsdHNbdmlld1BvcnROYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiB2aWV3UG9ydENvbmZpZy5tb2R1bGVJZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX3JlZnJlc2hCYXNlVXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRSb3V0ZXIgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50Um91dGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVVybCA9IGdlbmVyYXRlQmFzZVVybChwYXJlbnRSb3V0ZXIsIHBhcmVudFJvdXRlci5jdXJyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NyZWF0ZU5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh1cmwsIHBhcmVudEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gdm9pZCAwKSB7IHVybCA9ICcnOyB9XHJcbiAgICAgICAgaWYgKHBhcmVudEluc3RydWN0aW9uID09PSB2b2lkIDApIHsgcGFyZW50SW5zdHJ1Y3Rpb24gPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gdXJsO1xyXG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9ICcnO1xyXG4gICAgICAgIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgICAgICBpZiAocXVlcnlJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSB1cmwuc3Vic3RyKDAsIHF1ZXJ5SW5kZXgpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHVybC5zdWJzdHIocXVlcnlJbmRleCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsUmVjb2duaXphdGlvblJlc3VsdHMgPSB0aGlzLl9yZWNvZ25pemVyLnJlY29nbml6ZSh1cmwpO1xyXG4gICAgICAgIGlmICghdXJsUmVjb2duaXphdGlvblJlc3VsdHMgfHwgIXVybFJlY29nbml6YXRpb25SZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1cmxSZWNvZ25pemF0aW9uUmVzdWx0cyA9IHRoaXMuX2NoaWxkUmVjb2duaXplci5yZWNvZ25pemUodXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uSW5pdCA9IHtcclxuICAgICAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxyXG4gICAgICAgICAgICBxdWVyeVN0cmluZzogcXVlcnlTdHJpbmcsXHJcbiAgICAgICAgICAgIGNvbmZpZzogbnVsbCxcclxuICAgICAgICAgICAgcGFyZW50SW5zdHJ1Y3Rpb246IHBhcmVudEluc3RydWN0aW9uLFxyXG4gICAgICAgICAgICBwcmV2aW91c0luc3RydWN0aW9uOiB0aGlzLmN1cnJlbnRJbnN0cnVjdGlvbixcclxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlUXVlcnlQYXJhbXM6IHRoaXMub3B0aW9ucy5jb21wYXJlUXVlcnlQYXJhbXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAodXJsUmVjb2duaXphdGlvblJlc3VsdHMgJiYgdXJsUmVjb2duaXphdGlvblJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHVybFJlY29nbml6YXRpb25SZXN1bHRzWzBdO1xyXG4gICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBuZXcgTmF2aWdhdGlvbkluc3RydWN0aW9uKE9iamVjdC5hc3NpZ24oe30sIGluc3RydWN0aW9uSW5pdCwge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBmaXJzdC5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogZmlyc3QucXVlcnlQYXJhbXMgfHwgdXJsUmVjb2duaXphdGlvblJlc3VsdHMucXVlcnlQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBjb25maWc6IGZpcnN0LmNvbmZpZyB8fCBmaXJzdC5oYW5kbGVyXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdC5oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU5hdmlnYXRpb25TdHJhdGVneShpbnN0cnVjdGlvbiwgZmlyc3QuaGFuZGxlciwgZmlyc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0LmhhbmRsZXIgJiYgdHlwZW9mIGZpcnN0LmhhbmRsZXIubmF2aWdhdGlvblN0cmF0ZWd5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU5hdmlnYXRpb25TdHJhdGVneShpbnN0cnVjdGlvbiwgZmlyc3QuaGFuZGxlci5uYXZpZ2F0aW9uU3RyYXRlZ3ksIGZpcnN0LmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKGluc3RydWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhdGNoQWxsSGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBuZXcgTmF2aWdhdGlvbkluc3RydWN0aW9uKE9iamVjdC5hc3NpZ24oe30sIGluc3RydWN0aW9uSW5pdCwge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7IHBhdGg6IGZyYWdtZW50IH0sXHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogdXJsUmVjb2duaXphdGlvblJlc3VsdHMgPyB1cmxSZWNvZ25pemF0aW9uUmVzdWx0cy5xdWVyeVBhcmFtcyA6IHt9LFxyXG4gICAgICAgICAgICAgICAgY29uZmlnOiBudWxsIC8vIGNvbmZpZyB3aWxsIGJlIGNyZWF0ZWQgYnkgdGhlIGNhdGNoQWxsSGFuZGxlclxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTmF2aWdhdGlvblN0cmF0ZWd5KGluc3RydWN0aW9uLCB0aGlzLmNhdGNoQWxsSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLl9wYXJlbnRDYXRjaEFsbEhhbmRsZXIodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgICAgICBpZiAocm91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGFyZW50SW5zdHJ1Y3Rpb24gPSB0aGlzLl9maW5kUGFyZW50SW5zdHJ1Y3Rpb25Gcm9tUm91dGVyKHJvdXRlciwgcGFyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RydWN0aW9uID0gbmV3IE5hdmlnYXRpb25JbnN0cnVjdGlvbihPYmplY3QuYXNzaWduKHt9LCBpbnN0cnVjdGlvbkluaXQsIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgcGF0aDogZnJhZ21lbnQgfSxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogdXJsUmVjb2duaXphdGlvblJlc3VsdHMgPyB1cmxSZWNvZ25pemF0aW9uUmVzdWx0cy5xdWVyeVBhcmFtcyA6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogcm91dGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RydWN0aW9uOiBuZXdQYXJlbnRJbnN0cnVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDYXRjaEhhbmRsZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBudWxsIC8vIGNvbmZpZyB3aWxsIGJlIGNyZWF0ZWQgYnkgdGhlIGNoYWluZWQgcGFyZW50IGNhdGNoQWxsSGFuZGxlclxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVOYXZpZ2F0aW9uU3RyYXRlZ3koaW5zdHJ1Y3Rpb24sIHJvdXRlci5jYXRjaEFsbEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcGFyZW50SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVXJsID0gZ2VuZXJhdGVCYXNlVXJsKHRoaXMucGFyZW50LCBwYXJlbnRJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUm91dGUgbm90IGZvdW5kOiBcIiArIHVybCkpO1xyXG4gICAgfTtcclxuICAgIC8qKkBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fZmluZFBhcmVudEluc3RydWN0aW9uRnJvbVJvdXRlciA9IGZ1bmN0aW9uIChyb3V0ZXIsIGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluc3RydWN0aW9uLnJvdXRlciA9PT0gcm91dGVyKSB7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmZyYWdtZW50ID0gcm91dGVyLmJhc2VVcmw7IC8vIG5lZWQgdG8gY2hhbmdlIHRoZSBmcmFnbWVudCBpbiBjYXNlIG9mIGEgcmVkaXJlY3QgaW5zdGVhZCBvZiBtb2R1bGVJZFxyXG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uLnBhcmVudEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kUGFyZW50SW5zdHJ1Y3Rpb25Gcm9tUm91dGVyKHJvdXRlciwgaW5zdHJ1Y3Rpb24ucGFyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8qKkBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fcGFyZW50Q2F0Y2hBbGxIYW5kbGVyID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIGlmIChyb3V0ZXIuY2F0Y2hBbGxIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJvdXRlci5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudENhdGNoQWxsSGFuZGxlcihyb3V0ZXIucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NyZWF0ZVJvdXRlQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZywgaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXHJcbiAgICAgICAgICAgIC5yZXNvbHZlKGNvbmZpZylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9kdWxlSWQ6IGMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMoaW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIHR5cGluZyBoZXJlIGNvdWxkIGJlIGVpdGhlciBSb3V0ZUNvbmZpZyBvciBSZWRpcmVjdENvbmZpZ1xyXG4gICAgICAgICAgICAvLyBidXQgdGVtcG9yYXJpbHkgdHJlYXQgYm90aCBhcyBSb3V0ZUNvbmZpZ1xyXG4gICAgICAgICAgICAvLyB0b2RvOiBpbXByb3ZlIHR5cGluZ3MgcHJlY2lzaW9uXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyB7IG1vZHVsZUlkOiBjIH0gOiBjOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICBjLnJvdXRlID0gaW5zdHJ1Y3Rpb24ucGFyYW1zLnBhdGg7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlUm91dGVDb25maWcoYyk7XHJcbiAgICAgICAgICAgIGlmICghYy5uYXZNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgYy5uYXZNb2RlbCA9IF90aGlzLmNyZWF0ZU5hdk1vZGVsKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSb3V0ZXI7XHJcbn0oKSk7XHJcbi8qIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nICovXHJcbnZhciBnZW5lcmF0ZUJhc2VVcmwgPSBmdW5jdGlvbiAocm91dGVyLCBpbnN0cnVjdGlvbikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyAocm91dGVyLmJhc2VVcmwgfHwgJycpICsgKGluc3RydWN0aW9uLmdldEJhc2VVcmwoKSB8fCAnJyk7XHJcbn07XHJcbi8qIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nICovXHJcbnZhciB2YWxpZGF0ZVJvdXRlQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJvdXRlIENvbmZpZycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25maWcucm91dGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IGNvbmZpZy5uYW1lIHx8ICcobm8gbmFtZSknO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSb3V0ZSBDb25maWcgZm9yIFwiJyArIG5hbWVfMSArICdcIjogWW91IG11c3Qgc3BlY2lmeSBhIFwicm91dGU6XCIgcGF0dGVybi4nKTtcclxuICAgIH1cclxuICAgIGlmICghKCdyZWRpcmVjdCcgaW4gY29uZmlnIHx8IGNvbmZpZy5tb2R1bGVJZCB8fCBjb25maWcubmF2aWdhdGlvblN0cmF0ZWd5IHx8IGNvbmZpZy52aWV3UG9ydHMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJvdXRlIENvbmZpZyBmb3IgXCInICsgY29uZmlnLnJvdXRlICsgJ1wiOiBZb3UgbXVzdCBzcGVjaWZ5IGEgXCJtb2R1bGVJZDpcIiwgXCJyZWRpcmVjdDpcIiwgXCJuYXZpZ2F0aW9uU3RyYXRlZ3k6XCIsIG9yIFwidmlld1BvcnRzOlwiLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZyAqL1xyXG52YXIgZXZhbHVhdGVOYXZpZ2F0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIGV2YWx1YXRvciwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIFByb21pc2VcclxuICAgICAgICAucmVzb2x2ZShldmFsdWF0b3IuY2FsbChjb250ZXh0LCBpbnN0cnVjdGlvbikpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKCd2aWV3UG9ydHMnIGluIGluc3RydWN0aW9uLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29uZmlnLnZpZXdQb3J0cyA9IHtcclxuICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBpbnN0cnVjdGlvbi5jb25maWcubW9kdWxlSWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xyXG4gICAgfSk7XHJcbn07XG5cbi8qKkBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nICovXHJcbnZhciBjcmVhdGVOZXh0Rm4gPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIHN0ZXBzKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RlcCA9IHN0ZXBzW2luZGV4XTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U3RlcChpbnN0cnVjdGlvbiwgbmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LnJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQuY29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbmV4dC5jb21wbGV0ZSA9IGNyZWF0ZUNvbXBsZXRpb25IYW5kbGVyKG5leHQsIFwiY29tcGxldGVkXCIgLyogQ29tcGxldGVkICovKTtcclxuICAgIG5leHQuY2FuY2VsID0gY3JlYXRlQ29tcGxldGlvbkhhbmRsZXIobmV4dCwgXCJjYW5jZWxlZFwiIC8qIENhbmNlbGVkICovKTtcclxuICAgIG5leHQucmVqZWN0ID0gY3JlYXRlQ29tcGxldGlvbkhhbmRsZXIobmV4dCwgXCJyZWplY3RlZFwiIC8qIFJlamVjdGVkICovKTtcclxuICAgIHJldHVybiBuZXh0O1xyXG59O1xyXG4vKipAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZyAqL1xyXG52YXIgY3JlYXRlQ29tcGxldGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAobmV4dCwgc3RhdHVzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gUHJvbWlzZVxyXG4gICAgICAgIC5yZXNvbHZlKHtcclxuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICBvdXRwdXQ6IG91dHB1dCxcclxuICAgICAgICBjb21wbGV0ZWQ6IHN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIiAvKiBDb21wbGV0ZWQgKi9cclxuICAgIH0pOyB9O1xyXG59O1xuXG4vKipcclxuICogVGhlIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyBhbmQgcHJvY2Vzc2luZyB0aGUgbmF2aWdhdGlvbiBwaXBlbGluZS5cclxuICovXHJcbnZhciBQaXBlbGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBpcGVsaW5lKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwaXBlbGluZSBzdGVwcy4gQW5kIHN0ZXBzIGFkZGVkIHZpYSBhZGRTdGVwIHdpbGwgYmUgY29udmVydGVkIHRvIGEgZnVuY3Rpb25cclxuICAgICAgICAgKiBUaGUgYWN0dWFseSBydW5uaW5nIGZ1bmN0aW9ucyB3aXRoIGNvcnJlY3Qgc3RlcCBjb250ZXh0cyBvZiB0aGlzIHBpcGVsaW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc3RlcCB0byB0aGUgcGlwZWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0ZXAgVGhlIHBpcGVsaW5lIHN0ZXAuXHJcbiAgICAgKi9cclxuICAgIFBpcGVsaW5lLnByb3RvdHlwZS5hZGRTdGVwID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICB2YXIgcnVuO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RlcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBydW4gPSBzdGVwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RlcC5nZXRTdGVwcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBnZXRTdGVwcyBpcyB0byBlbmFibGUgc3VwcG9ydCBvcGVuIHNsb3RzXHJcbiAgICAgICAgICAgIC8vIHdoZXJlIGRldnMgY2FuIGFkZCBtdWx0aXBsZSBzdGVwcyBpbnRvIHRoZSBzYW1lIHNsb3QgbmFtZVxyXG4gICAgICAgICAgICB2YXIgc3RlcHMgPSBzdGVwLmdldFN0ZXBzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RlcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcnVuID0gc3RlcC5ydW4uYmluZChzdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHJ1bik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSBwaXBlbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gVGhlIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb24gdG8gcHJvY2Vzcy5cclxuICAgICAqL1xyXG4gICAgUGlwZWxpbmUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBuZXh0Rm4gPSBjcmVhdGVOZXh0Rm4oaW5zdHJ1Y3Rpb24sIHRoaXMuc3RlcHMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0Rm4oKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGlwZWxpbmU7XHJcbn0oKSk7XG5cbi8qKlxyXG4qIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhIG5hdmlnYXRpb24gY29tbWFuZC5cclxuKiBBIG5hdmlnYXRpb24gY29tbWFuZCBpcyBhbnl0aGluZyB3aXRoIGEgbmF2aWdhdGUgbWV0aG9kLlxyXG4qXHJcbiogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4qL1xyXG5mdW5jdGlvbiBpc05hdmlnYXRpb25Db21tYW5kKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5hdmlnYXRlID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8qKlxyXG4qIFVzZWQgZHVyaW5nIHRoZSBhY3RpdmF0aW9uIGxpZmVjeWNsZSB0byBjYXVzZSBhIHJlZGlyZWN0LlxyXG4qL1xyXG52YXIgUmVkaXJlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCBmcmFnbWVudCB0byB1c2UgYXMgdGhlIG5hdmlnYXRpb24gZGVzdGluYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgbmF2aWdhdGlvbiBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZWRpcmVjdCh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0cmlnZ2VyOiB0cnVlLCByZXBsYWNlOiB0cnVlIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkQ29udGludWVQcm9jZXNzaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBieSB0aGUgYWN0aXZhdGlvbiBzeXN0ZW0gdG8gc2V0IHRoZSBjaGlsZCByb3V0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvdXRlciBUaGUgcm91dGVyLlxyXG4gICAgICovXHJcbiAgICBSZWRpcmVjdC5wcm90b3R5cGUuc2V0Um91dGVyID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBuYXZpZ2F0aW9uIHBpcGVsaW5lIHRvIG5hdmlnYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhcHBSb3V0ZXIgVGhlIHJvdXRlciB0byBiZSByZWRpcmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBSZWRpcmVjdC5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAoYXBwUm91dGVyKSB7XHJcbiAgICAgICAgdmFyIG5hdmlnYXRpbmdSb3V0ZXIgPSB0aGlzLm9wdGlvbnMudXNlQXBwUm91dGVyID8gYXBwUm91dGVyIDogKHRoaXMucm91dGVyIHx8IGFwcFJvdXRlcik7XHJcbiAgICAgICAgbmF2aWdhdGluZ1JvdXRlci5uYXZpZ2F0ZSh0aGlzLnVybCwgdGhpcy5vcHRpb25zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVkaXJlY3Q7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBVc2VkIGR1cmluZyB0aGUgYWN0aXZhdGlvbiBsaWZlY3ljbGUgdG8gY2F1c2UgYSByZWRpcmVjdCB0byBhIG5hbWVkIHJvdXRlLlxyXG4gKi9cclxudmFyIFJlZGlyZWN0VG9Sb3V0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJvdXRlIFRoZSBuYW1lIG9mIHRoZSByb3V0ZS5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gYmUgc2VudCB0byB0aGUgYWN0aXZhdGlvbiBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIG5hdmlnYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlZGlyZWN0VG9Sb3V0ZShyb3V0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHRyaWdnZXI6IHRydWUsIHJlcGxhY2U6IHRydWUgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW51ZVByb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBhY3RpdmF0aW9uIHN5c3RlbSB0byBzZXQgdGhlIGNoaWxkIHJvdXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm91dGVyIFRoZSByb3V0ZXIuXHJcbiAgICAgKi9cclxuICAgIFJlZGlyZWN0VG9Sb3V0ZS5wcm90b3R5cGUuc2V0Um91dGVyID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBuYXZpZ2F0aW9uIHBpcGVsaW5lIHRvIG5hdmlnYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhcHBSb3V0ZXIgVGhlIHJvdXRlciB0byBiZSByZWRpcmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBSZWRpcmVjdFRvUm91dGUucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKGFwcFJvdXRlcikge1xyXG4gICAgICAgIHZhciBuYXZpZ2F0aW5nUm91dGVyID0gdGhpcy5vcHRpb25zLnVzZUFwcFJvdXRlciA/IGFwcFJvdXRlciA6ICh0aGlzLnJvdXRlciB8fCBhcHBSb3V0ZXIpO1xyXG4gICAgICAgIG5hdmlnYXRpbmdSb3V0ZXIubmF2aWdhdGVUb1JvdXRlKHRoaXMucm91dGUsIHRoaXMucGFyYW1zLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWRpcmVjdFRvUm91dGU7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxuZnVuY3Rpb24gX2J1aWxkTmF2aWdhdGlvblBsYW4oaW5zdHJ1Y3Rpb24sIGZvcmNlTGlmZWN5Y2xlTWluaW11bSkge1xyXG4gICAgdmFyIGNvbmZpZyA9IGluc3RydWN0aW9uLmNvbmZpZztcclxuICAgIGlmICgncmVkaXJlY3QnIGluIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBidWlsZFJlZGlyZWN0UGxhbihpbnN0cnVjdGlvbik7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJldkluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24ucHJldmlvdXNJbnN0cnVjdGlvbjtcclxuICAgIHZhciBkZWZhdWx0Vmlld1BvcnRDb25maWdzID0gaW5zdHJ1Y3Rpb24ucm91dGVyLnZpZXdQb3J0RGVmYXVsdHM7XHJcbiAgICBpZiAocHJldkluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkVHJhbnNpdGlvblBsYW5zKGluc3RydWN0aW9uLCBwcmV2SW5zdHJ1Y3Rpb24sIGRlZmF1bHRWaWV3UG9ydENvbmZpZ3MsIGZvcmNlTGlmZWN5Y2xlTWluaW11bSk7XHJcbiAgICB9XHJcbiAgICAvLyBmaXJzdCBuYXZpZ2F0aW9uLCBvbmx5IG5lZWQgdG8gcHJlcGFyZSBhIGZldyBpbmZvcm1hdGlvbiBmb3IgZWFjaCB2aWV3cG9ydCBwbGFuXHJcbiAgICB2YXIgdmlld1BvcnRQbGFucyA9IHt9O1xyXG4gICAgdmFyIHZpZXdQb3J0Q29uZmlncyA9IGNvbmZpZy52aWV3UG9ydHM7XHJcbiAgICBmb3IgKHZhciB2aWV3UG9ydE5hbWUgaW4gdmlld1BvcnRDb25maWdzKSB7XHJcbiAgICAgICAgdmFyIHZpZXdQb3J0Q29uZmlnID0gdmlld1BvcnRDb25maWdzW3ZpZXdQb3J0TmFtZV07XHJcbiAgICAgICAgaWYgKHZpZXdQb3J0Q29uZmlnLm1vZHVsZUlkID09PSBudWxsICYmIHZpZXdQb3J0TmFtZSBpbiBkZWZhdWx0Vmlld1BvcnRDb25maWdzKSB7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0Q29uZmlnID0gZGVmYXVsdFZpZXdQb3J0Q29uZmlnc1t2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3UG9ydFBsYW5zW3ZpZXdQb3J0TmFtZV0gPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHZpZXdQb3J0TmFtZSxcclxuICAgICAgICAgICAgc3RyYXRlZ3k6IFwicmVwbGFjZVwiIC8qIFJlcGxhY2UgKi8sXHJcbiAgICAgICAgICAgIGNvbmZpZzogdmlld1BvcnRDb25maWdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2aWV3UG9ydFBsYW5zKTtcclxufVxyXG4vKipcclxuICogQnVpbGQgcmVkaXJlY3QgcGxhbiBiYXNlZCBvbiBjb25maWcgb2YgYSBuYXZpZ2F0aW9uIGluc3RydWN0aW9uXHJcbiAqIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG52YXIgYnVpbGRSZWRpcmVjdFBsYW4gPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgIHZhciBjb25maWcgPSBpbnN0cnVjdGlvbi5jb25maWc7XHJcbiAgICB2YXIgcm91dGVyID0gaW5zdHJ1Y3Rpb24ucm91dGVyO1xyXG4gICAgcmV0dXJuIHJvdXRlclxyXG4gICAgICAgIC5fY3JlYXRlTmF2aWdhdGlvbkluc3RydWN0aW9uKGNvbmZpZy5yZWRpcmVjdClcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVkaXJlY3RJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICB2YXIgb3JpZ2luYWxJbnN0cnVjdGlvblBhcmFtcyA9IGluc3RydWN0aW9uLnBhcmFtcztcclxuICAgICAgICB2YXIgcmVkaXJlY3RJbnN0cnVjdGlvblBhcmFtcyA9IHJlZGlyZWN0SW5zdHJ1Y3Rpb24ucGFyYW1zO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiByZWRpcmVjdEluc3RydWN0aW9uUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbSBvbiB0aGUgcmVkaXJlY3QgcG9pbnRzIHRvIGFub3RoZXIgcGFyYW0sIGUuZy4geyByb3V0ZTogZmlyc3QvOnRoaXMsIHJlZGlyZWN0OiBzZWNvbmQvOnRoaXMgfVxyXG4gICAgICAgICAgICB2YXIgdmFsID0gcmVkaXJlY3RJbnN0cnVjdGlvblBhcmFtc1trZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIC8vIEFuZCBpZiB0aGF0IHBhcmFtIGlzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBpbnN0cnVjdGlvbiB0aGVuIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbiBvcmlnaW5hbEluc3RydWN0aW9uUGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBvcmlnaW5hbEluc3RydWN0aW9uUGFyYW1zW3ZhbF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHJlZGlyZWN0SW5zdHJ1Y3Rpb25QYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVkaXJlY3RMb2NhdGlvbiA9IHJvdXRlci5nZW5lcmF0ZShyZWRpcmVjdEluc3RydWN0aW9uLmNvbmZpZywgcGFyYW1zLCBpbnN0cnVjdGlvbi5vcHRpb25zKTtcclxuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBjaGlsZCByb3V0ZXNcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3JpZ2luYWxJbnN0cnVjdGlvblBhcmFtcykge1xyXG4gICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uID0gcmVkaXJlY3RMb2NhdGlvbi5yZXBsYWNlKFwiOlwiICsga2V5LCBvcmlnaW5hbEluc3RydWN0aW9uUGFyYW1zW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBpbnN0cnVjdGlvbi5xdWVyeVN0cmluZztcclxuICAgICAgICBpZiAocXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbiArPSAnPycgKyBxdWVyeVN0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgUmVkaXJlY3QocmVkaXJlY3RMb2NhdGlvbikpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gdmlld1BvcnRQbGFucyB0aGUgUGxhbiByZWNvcmQgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCBidWlsdCBwbGFuc1xyXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIGJ1aWxkVHJhbnNpdGlvblBsYW5zID0gZnVuY3Rpb24gKGN1cnJlbnRJbnN0cnVjdGlvbiwgcHJldmlvdXNJbnN0cnVjdGlvbiwgZGVmYXVsdFZpZXdQb3J0Q29uZmlncywgZm9yY2VMaWZlY3ljbGVNaW5pbXVtKSB7XHJcbiAgICB2YXIgdmlld1BvcnRQbGFucyA9IHt9O1xyXG4gICAgdmFyIG5ld0luc3RydWN0aW9uQ29uZmlnID0gY3VycmVudEluc3RydWN0aW9uLmNvbmZpZztcclxuICAgIHZhciBoYXNOZXdQYXJhbXMgPSBoYXNEaWZmZXJlbnRQYXJhbWV0ZXJWYWx1ZXMocHJldmlvdXNJbnN0cnVjdGlvbiwgY3VycmVudEluc3RydWN0aW9uKTtcclxuICAgIHZhciBwZW5kaW5nID0gW107XHJcbiAgICB2YXIgcHJldmlvdXNWaWV3UG9ydEluc3RydWN0aW9ucyA9IHByZXZpb3VzSW5zdHJ1Y3Rpb24udmlld1BvcnRJbnN0cnVjdGlvbnM7XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2aWV3UG9ydE5hbWUpIHtcclxuICAgICAgICB2YXIgcHJldlZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSBwcmV2aW91c1ZpZXdQb3J0SW5zdHJ1Y3Rpb25zW3ZpZXdQb3J0TmFtZV07XHJcbiAgICAgICAgdmFyIHByZXZWaWV3UG9ydENvbXBvbmVudCA9IHByZXZWaWV3UG9ydEluc3RydWN0aW9uLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgbmV3SW5zdHJ1Y3Rpb25WaWV3UG9ydENvbmZpZ3MgPSBuZXdJbnN0cnVjdGlvbkNvbmZpZy52aWV3UG9ydHM7XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnZva2VkIG9uIGEgdmlld3BvcnQgd2l0aG91dCBhbnkgY2hhbmdlcywgYmFzZWQgb24gbmV3IHVybCxcclxuICAgICAgICAvLyBuZXdWaWV3UG9ydENvbmZpZyB3aWxsIGJlIHRoZSBleGlzdGluZyB2aWV3cG9ydCBpbnN0cnVjdGlvblxyXG4gICAgICAgIHZhciBuZXh0Vmlld1BvcnRDb25maWcgPSB2aWV3UG9ydE5hbWUgaW4gbmV3SW5zdHJ1Y3Rpb25WaWV3UG9ydENvbmZpZ3NcclxuICAgICAgICAgICAgPyBuZXdJbnN0cnVjdGlvblZpZXdQb3J0Q29uZmlnc1t2aWV3UG9ydE5hbWVdXHJcbiAgICAgICAgICAgIDogcHJldlZpZXdQb3J0SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgaWYgKG5leHRWaWV3UG9ydENvbmZpZy5tb2R1bGVJZCA9PT0gbnVsbCAmJiB2aWV3UG9ydE5hbWUgaW4gZGVmYXVsdFZpZXdQb3J0Q29uZmlncykge1xyXG4gICAgICAgICAgICBuZXh0Vmlld1BvcnRDb25maWcgPSBkZWZhdWx0Vmlld1BvcnRDb25maWdzW3ZpZXdQb3J0TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2aWV3UG9ydEFjdGl2YXRpb25TdHJhdGVneSA9IGRldGVybWluZUFjdGl2YXRpb25TdHJhdGVneShjdXJyZW50SW5zdHJ1Y3Rpb24sIHByZXZWaWV3UG9ydEluc3RydWN0aW9uLCBuZXh0Vmlld1BvcnRDb25maWcsIGhhc05ld1BhcmFtcywgZm9yY2VMaWZlY3ljbGVNaW5pbXVtKTtcclxuICAgICAgICB2YXIgdmlld1BvcnRQbGFuID0gdmlld1BvcnRQbGFuc1t2aWV3UG9ydE5hbWVdID0ge1xyXG4gICAgICAgICAgICBuYW1lOiB2aWV3UG9ydE5hbWUsXHJcbiAgICAgICAgICAgIC8vIFZpZXdQb3J0SW5zdHJ1Y3Rpb24gY2FuIHF1YWNrIGxpa2UgYSBSb3V0ZUNvbmZpZ1xyXG4gICAgICAgICAgICBjb25maWc6IG5leHRWaWV3UG9ydENvbmZpZyxcclxuICAgICAgICAgICAgcHJldkNvbXBvbmVudDogcHJldlZpZXdQb3J0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwcmV2TW9kdWxlSWQ6IHByZXZWaWV3UG9ydEluc3RydWN0aW9uLm1vZHVsZUlkLFxyXG4gICAgICAgICAgICBzdHJhdGVneTogdmlld1BvcnRBY3RpdmF0aW9uU3RyYXRlZ3lcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIG5hdiBwbGFucyBmb3IgYWxsIGV4aXN0aW5nIGNoaWxkIHJvdXRlcnMvdmlld3BvcnRzIG9mIHRoaXMgdmlld3BvcnRcclxuICAgICAgICAvLyB0aGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgZXhpc3RpbmcgY2hpbGQgdmlld3BvcnRzIGFuZCByb3V0ZXJzIGFscmVhZHkgaGF2ZSBuZWNlc3NhcnkgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyB0byBwcm9jZXNzIHRoZSB3aWxkY2FyZCBwYXRoIGZyb20gcGFyZW50IGluc3RydWN0aW9uXHJcbiAgICAgICAgaWYgKHZpZXdQb3J0QWN0aXZhdGlvblN0cmF0ZWd5ICE9PSBcInJlcGxhY2VcIiAvKiBSZXBsYWNlICovICYmIHByZXZWaWV3UG9ydEluc3RydWN0aW9uLmNoaWxkUm91dGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gY3VycmVudEluc3RydWN0aW9uLmdldFdpbGRjYXJkUGF0aCgpO1xyXG4gICAgICAgICAgICB2YXIgdGFzayA9IHByZXZWaWV3UG9ydEluc3RydWN0aW9uXHJcbiAgICAgICAgICAgICAgICAuY2hpbGRSb3V0ZXJcclxuICAgICAgICAgICAgICAgIC5fY3JlYXRlTmF2aWdhdGlvbkluc3RydWN0aW9uKHBhdGgsIGN1cnJlbnRJbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjaGlsZEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3UG9ydFBsYW4uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24gPSBjaGlsZEluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9idWlsZE5hdmlnYXRpb25QbGFuKGNoaWxkSW5zdHJ1Y3Rpb24sIFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgaXQgc2FmZSB0byBhc3N1bWUgdmlld1BvcnRQbGFuIGhhcyBub3QgYmVlbiBjaGFuZ2VkIGZyb20gcHJldmlvdXMgYXNzaWdubWVudD9cclxuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBjYW4ganVzdCB1c2UgbG9jYWwgdmFyaWFibGUgdmlld1BvcnRQbGFuU3RyYXRlZ3lcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGNvdWxkIGJlIHVzZXIgY29kZSBtb2RpZnlpbmcgdmlld3BvcnQgcGxhbiBkdXJpbmcgX2NyZWF0ZU5hdmlnYXRpb25JbnN0cnVjdGlvbj9cclxuICAgICAgICAgICAgICAgIHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9PT0gXCJpbnZva2UtbGlmZWN5Y2xlXCIgLyogSW52b2tlTGlmZWN5Y2xlICovKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjaGlsZFBsYW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRQbGFuIGluc3RhbmNlb2YgUmVkaXJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNoaWxkUGxhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb24ucGxhbiA9IGNoaWxkUGxhbjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYmx1ZWJpcmQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwZW5kaW5nLnB1c2godGFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIHZpZXdQb3J0TmFtZSBpbiBwcmV2aW91c1ZpZXdQb3J0SW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgX2xvb3BfMSh2aWV3UG9ydE5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlld1BvcnRQbGFuczsgfSk7XHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gbmV3Vmlld1BvcnRDb25maWcgaWYgdGhpcyBpcyBpbnZva2VkIG9uIGEgdmlld3BvcnQgd2l0aG91dCBhbnkgY2hhbmdlcywgYmFzZWQgb24gbmV3IHVybCwgbmV3Vmlld1BvcnRDb25maWcgd2lsbCBiZSB0aGUgZXhpc3Rpbmcgdmlld3BvcnQgaW5zdHJ1Y3Rpb25cclxuICogQGludGVybmFsIGV4cG9ydGVkIGZvciB1bml0IHRlc3RpbmdcclxuICovXHJcbnZhciBkZXRlcm1pbmVBY3RpdmF0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiAoY3VycmVudE5hdkluc3RydWN0aW9uLCBwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbiwgbmV3Vmlld1BvcnRDb25maWcsIFxyXG4vLyBpbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBkaWZmZXJlbmNlIGJldHdlZW4gb2xkIGFuZCBuZXcgdXJsIHBhcmFtc1xyXG5oYXNOZXdQYXJhbXMsIGZvcmNlTGlmZWN5Y2xlTWluaW11bSkge1xyXG4gICAgdmFyIG5ld0luc3RydWN0aW9uQ29uZmlnID0gY3VycmVudE5hdkluc3RydWN0aW9uLmNvbmZpZztcclxuICAgIHZhciBwcmV2Vmlld1BvcnRWaWV3TW9kZWwgPSBwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnQudmlld01vZGVsO1xyXG4gICAgdmFyIHZpZXdQb3J0UGxhblN0cmF0ZWd5O1xyXG4gICAgaWYgKHByZXZWaWV3UG9ydEluc3RydWN0aW9uLm1vZHVsZUlkICE9PSBuZXdWaWV3UG9ydENvbmZpZy5tb2R1bGVJZCkge1xyXG4gICAgICAgIHZpZXdQb3J0UGxhblN0cmF0ZWd5ID0gXCJyZXBsYWNlXCIgLyogUmVwbGFjZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkZXRlcm1pbmVBY3RpdmF0aW9uU3RyYXRlZ3knIGluIHByZXZWaWV3UG9ydFZpZXdNb2RlbCkge1xyXG4gICAgICAgIHZpZXdQb3J0UGxhblN0cmF0ZWd5ID0gcHJldlZpZXdQb3J0Vmlld01vZGVsLmRldGVybWluZUFjdGl2YXRpb25TdHJhdGVneS5hcHBseShwcmV2Vmlld1BvcnRWaWV3TW9kZWwsIGN1cnJlbnROYXZJbnN0cnVjdGlvbi5saWZlY3ljbGVBcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5ld0luc3RydWN0aW9uQ29uZmlnLmFjdGl2YXRpb25TdHJhdGVneSkge1xyXG4gICAgICAgIHZpZXdQb3J0UGxhblN0cmF0ZWd5ID0gbmV3SW5zdHJ1Y3Rpb25Db25maWcuYWN0aXZhdGlvblN0cmF0ZWd5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzTmV3UGFyYW1zIHx8IGZvcmNlTGlmZWN5Y2xlTWluaW11bSkge1xyXG4gICAgICAgIHZpZXdQb3J0UGxhblN0cmF0ZWd5ID0gXCJpbnZva2UtbGlmZWN5Y2xlXCIgLyogSW52b2tlTGlmZWN5Y2xlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld1BvcnRQbGFuU3RyYXRlZ3kgPSBcIm5vLWNoYW5nZVwiIC8qIE5vQ2hhbmdlICovO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdQb3J0UGxhblN0cmF0ZWd5O1xyXG59O1xyXG4vKipAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZyAqL1xyXG52YXIgaGFzRGlmZmVyZW50UGFyYW1ldGVyVmFsdWVzID0gZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcclxuICAgIHZhciBwcmV2UGFyYW1zID0gcHJldi5wYXJhbXM7XHJcbiAgICB2YXIgbmV4dFBhcmFtcyA9IG5leHQucGFyYW1zO1xyXG4gICAgdmFyIG5leHRXaWxkQ2FyZE5hbWUgPSBuZXh0LmNvbmZpZy5oYXNDaGlsZFJvdXRlciA/IG5leHQuZ2V0V2lsZENhcmROYW1lKCkgOiBudWxsO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG5leHRQYXJhbXMpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBuZXh0V2lsZENhcmROYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlBhcmFtc1trZXldICE9PSBuZXh0UGFyYW1zW2tleV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIHByZXZQYXJhbXMpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBuZXh0V2lsZENhcmROYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlBhcmFtc1trZXldICE9PSBuZXh0UGFyYW1zW2tleV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFuZXh0Lm9wdGlvbnMuY29tcGFyZVF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIHByZXZRdWVyeVBhcmFtcyA9IHByZXYucXVlcnlQYXJhbXM7XHJcbiAgICB2YXIgbmV4dFF1ZXJ5UGFyYW1zID0gbmV4dC5xdWVyeVBhcmFtcztcclxuICAgIGZvciAodmFyIGtleSBpbiBuZXh0UXVlcnlQYXJhbXMpIHtcclxuICAgICAgICBpZiAocHJldlF1ZXJ5UGFyYW1zW2tleV0gIT09IG5leHRRdWVyeVBhcmFtc1trZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiBwcmV2UXVlcnlQYXJhbXMpIHtcclxuICAgICAgICBpZiAocHJldlF1ZXJ5UGFyYW1zW2tleV0gIT09IG5leHRRdWVyeVBhcmFtc1trZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcblxuLyoqXHJcbiAqIFRyYW5zZm9ybSBhIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb24gaW50byB2aWV3cG9ydCBwbGFuIHJlY29yZCBvYmplY3QsXHJcbiAqIG9yIGEgcmVkaXJlY3QgcmVxdWVzdCBpZiB1c2VyIHZpZXdtb2RlbCBkZW1hbmRzXHJcbiAqL1xyXG52YXIgQnVpbGROYXZpZ2F0aW9uUGxhblN0ZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcCgpIHtcclxuICAgIH1cclxuICAgIEJ1aWxkTmF2aWdhdGlvblBsYW5TdGVwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAobmF2aWdhdGlvbkluc3RydWN0aW9uLCBuZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9idWlsZE5hdmlnYXRpb25QbGFuKG5hdmlnYXRpb25JbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHBsYW4pIHtcclxuICAgICAgICAgICAgaWYgKHBsYW4gaW5zdGFuY2VvZiBSZWRpcmVjdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuY2FuY2VsKHBsYW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hdmlnYXRpb25JbnN0cnVjdGlvbi5wbGFuID0gcGxhbjtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2gobmV4dC5jYW5jZWwpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcDtcclxufSgpKTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbCBFeHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG52YXIgbG9hZE5ld1JvdXRlID0gZnVuY3Rpb24gKHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcclxuICAgIHZhciBsb2FkaW5nUGxhbnMgPSBkZXRlcm1pbmVMb2FkaW5nUGxhbnMobmF2aWdhdGlvbkluc3RydWN0aW9uKTtcclxuICAgIHZhciBsb2FkUHJvbWlzZXMgPSBsb2FkaW5nUGxhbnMubWFwKGZ1bmN0aW9uIChsb2FkaW5nUGxhbikgeyByZXR1cm4gbG9hZFJvdXRlKHJvdXRlTG9hZGVyLCBsb2FkaW5nUGxhbi5uYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGxvYWRpbmdQbGFuLnZpZXdQb3J0UGxhbik7IH0pO1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRQcm9taXNlcyk7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgRXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIGRldGVybWluZUxvYWRpbmdQbGFucyA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGxvYWRpbmdQbGFucykge1xyXG4gICAgaWYgKGxvYWRpbmdQbGFucyA9PT0gdm9pZCAwKSB7IGxvYWRpbmdQbGFucyA9IFtdOyB9XHJcbiAgICB2YXIgdmlld1BvcnRQbGFucyA9IG5hdmlnYXRpb25JbnN0cnVjdGlvbi5wbGFuO1xyXG4gICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHZpZXdQb3J0UGxhbnMpIHtcclxuICAgICAgICB2YXIgdmlld1BvcnRQbGFuID0gdmlld1BvcnRQbGFuc1t2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgIHZhciBjaGlsZE5hdkluc3RydWN0aW9uID0gdmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uO1xyXG4gICAgICAgIGlmICh2aWV3UG9ydFBsYW4uc3RyYXRlZ3kgPT09IFwicmVwbGFjZVwiIC8qIFJlcGxhY2UgKi8pIHtcclxuICAgICAgICAgICAgbG9hZGluZ1BsYW5zLnB1c2goeyB2aWV3UG9ydFBsYW46IHZpZXdQb3J0UGxhbiwgbmF2aWdhdGlvbkluc3RydWN0aW9uOiBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24gfSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZE5hdkluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmVMb2FkaW5nUGxhbnMoY2hpbGROYXZJbnN0cnVjdGlvbiwgbG9hZGluZ1BsYW5zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24uYWRkVmlld1BvcnRJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB2aWV3UG9ydE5hbWUsXHJcbiAgICAgICAgICAgICAgICBzdHJhdGVneTogdmlld1BvcnRQbGFuLnN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IHZpZXdQb3J0UGxhbi5wcmV2TW9kdWxlSWQsXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHZpZXdQb3J0UGxhbi5wcmV2Q29tcG9uZW50XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGROYXZJbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IGNoaWxkTmF2SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmVMb2FkaW5nUGxhbnMoY2hpbGROYXZJbnN0cnVjdGlvbiwgbG9hZGluZ1BsYW5zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsb2FkaW5nUGxhbnM7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgRXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIGxvYWRSb3V0ZSA9IGZ1bmN0aW9uIChyb3V0ZUxvYWRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9uLCB2aWV3UG9ydFBsYW4pIHtcclxuICAgIHZhciBwbGFuQ29uZmlnID0gdmlld1BvcnRQbGFuLmNvbmZpZztcclxuICAgIHZhciBtb2R1bGVJZCA9IHBsYW5Db25maWcgPyBwbGFuQ29uZmlnLm1vZHVsZUlkIDogbnVsbDtcclxuICAgIHJldHVybiBsb2FkQ29tcG9uZW50KHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIHBsYW5Db25maWcpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9uID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLmFkZFZpZXdQb3J0SW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgICAgICBuYW1lOiB2aWV3UG9ydFBsYW4ubmFtZSxcclxuICAgICAgICAgICAgc3RyYXRlZ3k6IHZpZXdQb3J0UGxhbi5zdHJhdGVneSxcclxuICAgICAgICAgICAgbW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBjaGlsZFJvdXRlciA9IGNvbXBvbmVudC5jaGlsZFJvdXRlcjtcclxuICAgICAgICBpZiAoY2hpbGRSb3V0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24uZ2V0V2lsZGNhcmRQYXRoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFJvdXRlclxyXG4gICAgICAgICAgICAgICAgLl9jcmVhdGVOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ocGF0aCwgbmF2aWdhdGlvbkluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNoaWxkSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZpZXdQb3J0UGxhbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IGNoaWxkSW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2J1aWxkTmF2aWdhdGlvblBsYW4oY2hpbGRJbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2hpbGRQbGFuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkUGxhbiBpbnN0YW5jZW9mIFJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjaGlsZFBsYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEluc3RydWN0aW9uLnBsYW4gPSBjaGlsZFBsYW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IGNoaWxkSW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWROZXdSb3V0ZShyb3V0ZUxvYWRlciwgY2hpbGRJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRzIGNvbXBsYWlucyB3aXRob3V0IHRoaXMsIHRob3VnaCB0aGV5IGFyZSBzYW1lXHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH0pO1xyXG59O1xyXG4vKipcclxuICogTG9hZCBhIHJvdXRlZC1jb21wb25lbnQgYmFzZWQgb24gbmF2aWdhdGlvbiBpbnN0cnVjdGlvbiBhbmQgcm91dGUgY29uZmlnXHJcbiAqIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nIG9ubHlcclxuICovXHJcbnZhciBsb2FkQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGNvbmZpZykge1xyXG4gICAgdmFyIHJvdXRlciA9IG5hdmlnYXRpb25JbnN0cnVjdGlvbi5yb3V0ZXI7XHJcbiAgICB2YXIgbGlmZWN5Y2xlQXJncyA9IG5hdmlnYXRpb25JbnN0cnVjdGlvbi5saWZlY3ljbGVBcmdzO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVMb2FkZXIubG9hZFJvdXRlKHJvdXRlciwgY29uZmlnLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pOyB9KVxyXG4gICAgICAgIC50aGVuKFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IGFuIG9iamVjdCBjYXJyeWluZyBpbmZvcm1hdGlvbiBhYm91dCBsb2FkZWQgcm91dGVcclxuICAgICAqIHR5cGljYWxseSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB2aWV3IG1vZGVsLCBjaGlsZENvbnRhaW5lciwgdmlldyBhbmQgcm91dGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgdmlld01vZGVsID0gY29tcG9uZW50LnZpZXdNb2RlbCwgY2hpbGRDb250YWluZXIgPSBjb21wb25lbnQuY2hpbGRDb250YWluZXI7XHJcbiAgICAgICAgY29tcG9uZW50LnJvdXRlciA9IHJvdXRlcjtcclxuICAgICAgICBjb21wb25lbnQuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIGlmICgnY29uZmlndXJlUm91dGVyJyBpbiB2aWV3TW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUm91dGVyXzEgPSBjaGlsZENvbnRhaW5lci5nZXRDaGlsZFJvdXRlcigpO1xyXG4gICAgICAgICAgICBjb21wb25lbnQuY2hpbGRSb3V0ZXIgPSBjaGlsZFJvdXRlcl8xO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRSb3V0ZXJfMVxyXG4gICAgICAgICAgICAgICAgLmNvbmZpZ3VyZShmdW5jdGlvbiAoYykgeyByZXR1cm4gdmlld01vZGVsLmNvbmZpZ3VyZVJvdXRlcihjLCBjaGlsZFJvdXRlcl8xLCBsaWZlY3ljbGVBcmdzWzBdLCBsaWZlY3ljbGVBcmdzWzFdLCBsaWZlY3ljbGVBcmdzWzJdKTsgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudDsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgICB9KTtcclxufTtcblxuLyoqXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgdmlldyAvIHZpZXcgbW9kZWwgZnJvbSBhIHJvdXRlIGNvbmZpZ1xyXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjYW4gYmUgZm91bmQgaW4gYGF1cmVsaWEtdGVtcGxhdGluZy1yb3V0ZXJgXHJcbiAqL1xyXG52YXIgUm91dGVMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZUxvYWRlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHJvdXRlIGNvbmZpZyBiYXNlZCBvbiBpdHMgdmlld21vZGVsIC8gdmlldyBjb25maWd1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIC8vIHJldHVybiB0eXBpbmc6IHJldHVybiB0eXBpbmdzIHVzZWQgdG8gYmUgbmV2ZXJcclxuICAgIC8vIGFzIGl0IHdhcyBhIHRocm93LiBDaGFuZ2luZyBpdCB0byBQcm9taXNlPGFueT4gc2hvdWxkIG5vdCBjYXVzZSBhbnkgaXNzdWVzXHJcbiAgICBSb3V0ZUxvYWRlci5wcm90b3R5cGUubG9hZFJvdXRlID0gZnVuY3Rpb24gKHJvdXRlciwgY29uZmlnLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlIGxvYWRlcnMgbXVzdCBpbXBsZW1lbnQgXCJsb2FkUm91dGUocm91dGVyLCBjb25maWcsIG5hdmlnYXRpb25JbnN0cnVjdGlvbilcIi4nKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm91dGVMb2FkZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBBIHBpcGVsaW5lIHN0ZXAgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgYSByb3V0ZSBjb25maWcgb2YgYSBuYXZpZ2F0aW9uIGluc3RydWN0aW9uXHJcbiAqL1xyXG52YXIgTG9hZFJvdXRlU3RlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvYWRSb3V0ZVN0ZXAocm91dGVMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLnJvdXRlTG9hZGVyID0gcm91dGVMb2FkZXI7XHJcbiAgICB9XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIExvYWRSb3V0ZVN0ZXAuaW5qZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1JvdXRlTG9hZGVyXTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogUnVuIHRoZSBpbnRlcm5hbCB0byBsb2FkIHJvdXRlIGNvbmZpZyBvZiBhIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb24gdG8gcHJlcGFyZSBmb3IgbmV4dCBzdGVwcyBpbiB0aGUgcGlwZWxpbmVcclxuICAgICAqL1xyXG4gICAgTG9hZFJvdXRlU3RlcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgbmV4dCkge1xyXG4gICAgICAgIHJldHVybiBsb2FkTmV3Um91dGUodGhpcy5yb3V0ZUxvYWRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICAudGhlbihuZXh0LCBuZXh0LmNhbmNlbCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvYWRSb3V0ZVN0ZXA7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBBIHBpcGVsaW5lIHN0ZXAgZm9yIGluc3RydWN0aW5nIGEgcGllcGxpbmUgdG8gY29tbWl0IGNoYW5nZXMgb24gYSBuYXZpZ2F0aW9uIGluc3RydWN0aW9uXHJcbiAqL1xyXG52YXIgQ29tbWl0Q2hhbmdlc1N0ZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21taXRDaGFuZ2VzU3RlcCgpIHtcclxuICAgIH1cclxuICAgIENvbW1pdENoYW5nZXNTdGVwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAobmF2aWdhdGlvbkluc3RydWN0aW9uLCBuZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRpb25JbnN0cnVjdGlvblxyXG4gICAgICAgICAgICAuX2NvbW1pdENoYW5nZXMoLyp3YWl0IHRvIHN3YXA/Ki8gdHJ1ZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24uX3VwZGF0ZVRpdGxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbW1pdENoYW5nZXNTdGVwO1xyXG59KCkpO1xuXG4vKipcclxuICogQW4gb3B0aW9uYWwgaW50ZXJmYWNlIGRlc2NyaWJpbmcgdGhlIGF2YWlsYWJsZSBhY3RpdmF0aW9uIHN0cmF0ZWdpZXMuXHJcbiAqIEBpbnRlcm5hbCBVc2VkIGludGVybmFsbHkuXHJcbiAqL1xyXG52YXIgSW50ZXJuYWxBY3RpdmF0aW9uU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoSW50ZXJuYWxBY3RpdmF0aW9uU3RyYXRlZ3kpIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV1c2UgdGhlIGV4aXN0aW5nIHZpZXcgbW9kZWwsIHdpdGhvdXQgaW52b2tpbmcgUm91dGVyIGxpZmVjeWNsZSBob29rcy5cclxuICAgICAqL1xyXG4gICAgSW50ZXJuYWxBY3RpdmF0aW9uU3RyYXRlZ3lbXCJOb0NoYW5nZVwiXSA9IFwibm8tY2hhbmdlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJldXNlIHRoZSBleGlzdGluZyB2aWV3IG1vZGVsLCBpbnZva2luZyBSb3V0ZXIgbGlmZWN5Y2xlIGhvb2tzLlxyXG4gICAgICovXHJcbiAgICBJbnRlcm5hbEFjdGl2YXRpb25TdHJhdGVneVtcIkludm9rZUxpZmVjeWNsZVwiXSA9IFwiaW52b2tlLWxpZmVjeWNsZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBleGlzdGluZyB2aWV3IG1vZGVsLCBpbnZva2luZyBSb3V0ZXIgbGlmZWN5Y2xlIGhvb2tzLlxyXG4gICAgICovXHJcbiAgICBJbnRlcm5hbEFjdGl2YXRpb25TdHJhdGVneVtcIlJlcGxhY2VcIl0gPSBcInJlcGxhY2VcIjtcclxufSkoSW50ZXJuYWxBY3RpdmF0aW9uU3RyYXRlZ3kgfHwgKEludGVybmFsQWN0aXZhdGlvblN0cmF0ZWd5ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBzdHJhdGVneSB0byB1c2Ugd2hlbiBhY3RpdmF0aW5nIG1vZHVsZXMgZHVyaW5nIG5hdmlnYXRpb24uXHJcbiAqL1xyXG4vLyBrZXB0IGZvciBjb21wYXQgcmVhc29uXHJcbnZhciBhY3RpdmF0aW9uU3RyYXRlZ3kgPSB7XHJcbiAgICBub0NoYW5nZTogXCJuby1jaGFuZ2VcIiAvKiBOb0NoYW5nZSAqLyxcclxuICAgIGludm9rZUxpZmVjeWNsZTogXCJpbnZva2UtbGlmZWN5Y2xlXCIgLyogSW52b2tlTGlmZWN5Y2xlICovLFxyXG4gICAgcmVwbGFjZTogXCJyZXBsYWNlXCIgLyogUmVwbGFjZSAqL1xyXG59O1xuXG4vKipcclxuICogUmVjdXJzaXZlbHkgZmluZCBsaXN0IG9mIGRlYWN0aXZhdGUtYWJsZSB2aWV3IG1vZGVsc1xyXG4gKiBhbmQgaW52b2tlIHRoZSBlaXRoZXIgJ2NhbkRlYWN0aXZhdGUnIG9yICdkZWFjdGl2YXRlJyBvbiBlYWNoXHJcbiAqIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG52YXIgcHJvY2Vzc0RlYWN0aXZhdGFibGUgPSBmdW5jdGlvbiAobmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUsIG5leHQsIGlnbm9yZVJlc3VsdCkge1xyXG4gICAgdmFyIHBsYW4gPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucGxhbjtcclxuICAgIHZhciBpbmZvcyA9IGZpbmREZWFjdGl2YXRhYmxlKHBsYW4sIGNhbGxiYWNrTmFtZSk7XHJcbiAgICB2YXIgaSA9IGluZm9zLmxlbmd0aDsgLy8gcXVlcnkgZnJvbSBpbnNpZGUgb3V0XHJcbiAgICBmdW5jdGlvbiBpbnNwZWN0KHZhbCkge1xyXG4gICAgICAgIGlmIChpZ25vcmVSZXN1bHQgfHwgc2hvdWxkQ29udGludWUodmFsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dC5jYW5jZWwodmFsKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XHJcbiAgICAgICAgaWYgKGktLSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZXdNb2RlbCA9IGluZm9zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZpZXdNb2RlbFtjYWxsYmFja05hbWVdKG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1BvdGVudGlhbChyZXN1bHQsIGluc3BlY3QsIG5leHQuY2FuY2VsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmNhbmNlbChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9uLnJvdXRlci5jb3VsZERlYWN0aXZhdGUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlcmF0ZSgpO1xyXG59O1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgZmluZCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgZGVhY3RpdmF0ZS1hYmxlIHZpZXcgbW9kZWxzXHJcbiAqIEBpbnRlcm5hbCBleHBvcnRlZCBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG52YXIgZmluZERlYWN0aXZhdGFibGUgPSBmdW5jdGlvbiAocGxhbiwgY2FsbGJhY2tOYW1lLCBsaXN0KSB7XHJcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7IGxpc3QgPSBbXTsgfVxyXG4gICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHBsYW4pIHtcclxuICAgICAgICB2YXIgdmlld1BvcnRQbGFuID0gcGxhblt2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgIHZhciBwcmV2Q29tcG9uZW50ID0gdmlld1BvcnRQbGFuLnByZXZDb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCh2aWV3UG9ydFBsYW4uc3RyYXRlZ3kgPT09IGFjdGl2YXRpb25TdHJhdGVneS5pbnZva2VMaWZlY3ljbGUgfHwgdmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kucmVwbGFjZSlcclxuICAgICAgICAgICAgJiYgcHJldkNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdmlld01vZGVsID0gcHJldkNvbXBvbmVudC52aWV3TW9kZWw7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja05hbWUgaW4gdmlld01vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmlld01vZGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kucmVwbGFjZSAmJiBwcmV2Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGFkZFByZXZpb3VzRGVhY3RpdmF0YWJsZShwcmV2Q29tcG9uZW50LCBjYWxsYmFja05hbWUsIGxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2aWV3UG9ydFBsYW4uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgZmluZERlYWN0aXZhdGFibGUodmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uLnBsYW4sIGNhbGxiYWNrTmFtZSwgbGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIGFkZFByZXZpb3VzRGVhY3RpdmF0YWJsZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGNhbGxiYWNrTmFtZSwgbGlzdCkge1xyXG4gICAgdmFyIGNoaWxkUm91dGVyID0gY29tcG9uZW50LmNoaWxkUm91dGVyO1xyXG4gICAgaWYgKGNoaWxkUm91dGVyICYmIGNoaWxkUm91dGVyLmN1cnJlbnRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9ucyA9IGNoaWxkUm91dGVyLmN1cnJlbnRJbnN0cnVjdGlvbi52aWV3UG9ydEluc3RydWN0aW9ucztcclxuICAgICAgICBmb3IgKHZhciB2aWV3UG9ydE5hbWUgaW4gdmlld1BvcnRJbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSB2aWV3UG9ydEluc3RydWN0aW9uc1t2aWV3UG9ydE5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgcHJldkNvbXBvbmVudCA9IHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgcHJldlZpZXdNb2RlbCA9IHByZXZDb21wb25lbnQudmlld01vZGVsO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tOYW1lIGluIHByZXZWaWV3TW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChwcmV2Vmlld01vZGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRQcmV2aW91c0RlYWN0aXZhdGFibGUocHJldkNvbXBvbmVudCwgY2FsbGJhY2tOYW1lLCBsaXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIHByb2Nlc3NBY3RpdmF0YWJsZSA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGNhbGxiYWNrTmFtZSwgbmV4dCwgaWdub3JlUmVzdWx0KSB7XHJcbiAgICB2YXIgaW5mb3MgPSBmaW5kQWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUpO1xyXG4gICAgdmFyIGxlbmd0aCA9IGluZm9zLmxlbmd0aDtcclxuICAgIHZhciBpID0gLTE7IC8vIHF1ZXJ5IGZyb20gdG9wIGRvd25cclxuICAgIGZ1bmN0aW9uIGluc3BlY3QodmFsLCByb3V0ZXIpIHtcclxuICAgICAgICBpZiAoaWdub3JlUmVzdWx0IHx8IHNob3VsZENvbnRpbnVlKHZhbCwgcm91dGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dC5jYW5jZWwodmFsKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGkrKztcclxuICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfMSA9IGluZm9zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IChfYSA9IGN1cnJlbnRfMS52aWV3TW9kZWwpW2NhbGxiYWNrTmFtZV0uYXBwbHkoX2EsIGN1cnJlbnRfMS5saWZlY3ljbGVBcmdzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzUG90ZW50aWFsKHJlc3VsdCwgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gaW5zcGVjdCh2YWwsIGN1cnJlbnRfMS5yb3V0ZXIpOyB9LCBuZXh0LmNhbmNlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5jYW5jZWwoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlcmF0ZSgpO1xyXG59O1xyXG4vKipcclxuICogRmluZCBsaXN0IG9mIGFjdGl2YXRhYmxlIHZpZXcgbW9kZWwgYW5kIGFkZCB0byBsaXN0ICgzcmQgcGFyYW1ldGVyKVxyXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKi9cclxudmFyIGZpbmRBY3RpdmF0YWJsZSA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGNhbGxiYWNrTmFtZSwgbGlzdCwgcm91dGVyKSB7XHJcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7IGxpc3QgPSBbXTsgfVxyXG4gICAgdmFyIHBsYW4gPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucGxhbjtcclxuICAgIE9iamVjdFxyXG4gICAgICAgIC5rZXlzKHBsYW4pXHJcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHZpZXdQb3J0TmFtZSkge1xyXG4gICAgICAgIHZhciB2aWV3UG9ydFBsYW4gPSBwbGFuW3ZpZXdQb3J0TmFtZV07XHJcbiAgICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24udmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXTtcclxuICAgICAgICB2YXIgdmlld1BvcnRDb21wb25lbnQgPSB2aWV3UG9ydEluc3RydWN0aW9uLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlld01vZGVsID0gdmlld1BvcnRDb21wb25lbnQudmlld01vZGVsO1xyXG4gICAgICAgIGlmICgodmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kuaW52b2tlTGlmZWN5Y2xlXHJcbiAgICAgICAgICAgIHx8IHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9PT0gYWN0aXZhdGlvblN0cmF0ZWd5LnJlcGxhY2UpXHJcbiAgICAgICAgICAgICYmIGNhbGxiYWNrTmFtZSBpbiB2aWV3TW9kZWwpIHtcclxuICAgICAgICAgICAgbGlzdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZpZXdNb2RlbDogdmlld01vZGVsLFxyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlQXJnczogdmlld1BvcnRJbnN0cnVjdGlvbi5saWZlY3ljbGVBcmdzLFxyXG4gICAgICAgICAgICAgICAgcm91dGVyOiByb3V0ZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZE5hdkluc3RydWN0aW9uID0gdmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uO1xyXG4gICAgICAgIGlmIChjaGlsZE5hdkluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGZpbmRBY3RpdmF0YWJsZShjaGlsZE5hdkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUsIGxpc3QsIHZpZXdQb3J0Q29tcG9uZW50LmNoaWxkUm91dGVyIHx8IHJvdXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbGlzdDtcclxufTtcclxudmFyIHNob3VsZENvbnRpbnVlID0gZnVuY3Rpb24gKG91dHB1dCwgcm91dGVyKSB7XHJcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOYXZpZ2F0aW9uQ29tbWFuZChvdXRwdXQpKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQuc2V0Um91dGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5zZXRSb3V0ZXIocm91dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICEhb3V0cHV0LnNob3VsZENvbnRpbnVlUHJvY2Vzc2luZztcclxuICAgIH1cclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuLyoqXHJcbiAqIHdyYXBzIGEgc3Vic2NyaXB0aW9uLCBhbGxvd2luZyB1bnN1YnNjcmliZSBjYWxscyBldmVuIGlmXHJcbiAqIHRoZSBmaXJzdCB2YWx1ZSBjb21lcyBzeW5jaHJvbm91c2x5XHJcbiAqL1xyXG52YXIgU2FmZVN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uRnVuYykge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbkZ1bmModGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2FmZVN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwic3Vic2NyaWJlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2FmZVN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmliZWQgJiYgdGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpcHRpb247XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2Nlc3MgcmV0dXJuIHZhbHVlIGZyb20gYGFjdGl2YXRlYC9gY2FuQWN0aXZhdGVgIHN0ZXBzXHJcbiAqIFN1cHBvcnRzIG9ic2VydmFibGUvcHJvbWlzZVxyXG4gKlxyXG4gKiBGb3Igb2JzZXJ2YWJsZSwgcmVzb2x2ZSBhdCBmaXJzdCBuZXh0KCkgb3Igb24gY29tcGxldGUoKVxyXG4gKi9cclxudmFyIHByb2Nlc3NQb3RlbnRpYWwgPSBmdW5jdGlvbiAob2JqLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgIC8vIGlmIHByb21pc2UgbGlrZVxyXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaikudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgb2JzZXJ2YWJsZVxyXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhciBvYnNfMSA9IG9iajtcclxuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdWJzY3JpcHRpb24oZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gb2JzXzEuc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gZWxzZSBqdXN0IHJlc29sdmVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUob2JqKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQSBwaXBlbGluZSBzdGVwIHJlc3BvbnNpYmxlIGZvciBmaW5kaW5nIGFuZCBhY3RpdmF0aW5nIG1ldGhvZCBgY2FuRGVhY3RpdmF0ZWAgb24gYSB2aWV3IG1vZGVsIG9mIGEgcm91dGVcclxuICovXHJcbnZhciBDYW5EZWFjdGl2YXRlUHJldmlvdXNTdGVwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FuRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCgpIHtcclxuICAgIH1cclxuICAgIENhbkRlYWN0aXZhdGVQcmV2aW91c1N0ZXAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIG5leHQpIHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc0RlYWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCAnY2FuRGVhY3RpdmF0ZScsIG5leHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYW5EZWFjdGl2YXRlUHJldmlvdXNTdGVwO1xyXG59KCkpO1xyXG4vKipcclxuICogQSBwaXBlbGluZSBzdGVwIHJlc3BvbnNpYmxlIGZvciBmaW5kaW5nIGFuZCBhY3RpdmF0aW5nIG1ldGhvZCBgY2FuQWN0aXZhdGVgIG9uIGEgdmlldyBtb2RlbCBvZiBhIHJvdXRlXHJcbiAqL1xyXG52YXIgQ2FuQWN0aXZhdGVOZXh0U3RlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhbkFjdGl2YXRlTmV4dFN0ZXAoKSB7XHJcbiAgICB9XHJcbiAgICBDYW5BY3RpdmF0ZU5leHRTdGVwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAobmF2aWdhdGlvbkluc3RydWN0aW9uLCBuZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NBY3RpdmF0YWJsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sICdjYW5BY3RpdmF0ZScsIG5leHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYW5BY3RpdmF0ZU5leHRTdGVwO1xyXG59KCkpO1xyXG4vKipcclxuICogQSBwaXBlbGluZSBzdGVwIHJlc3BvbnNpYmxlIGZvciBmaW5kaW5nIGFuZCBhY3RpdmF0aW5nIG1ldGhvZCBgZGVhY3RpdmF0ZWAgb24gYSB2aWV3IG1vZGVsIG9mIGEgcm91dGVcclxuICovXHJcbnZhciBEZWFjdGl2YXRlUHJldmlvdXNTdGVwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCgpIHtcclxuICAgIH1cclxuICAgIERlYWN0aXZhdGVQcmV2aW91c1N0ZXAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIG5leHQpIHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc0RlYWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCAnZGVhY3RpdmF0ZScsIG5leHQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWFjdGl2YXRlUHJldmlvdXNTdGVwO1xyXG59KCkpO1xyXG4vKipcclxuICogQSBwaXBlbGluZSBzdGVwIHJlc3BvbnNpYmxlIGZvciBmaW5kaW5nIGFuZCBhY3RpdmF0aW5nIG1ldGhvZCBgYWN0aXZhdGVgIG9uIGEgdmlldyBtb2RlbCBvZiBhIHJvdXRlXHJcbiAqL1xyXG52YXIgQWN0aXZhdGVOZXh0U3RlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2YXRlTmV4dFN0ZXAoKSB7XHJcbiAgICB9XHJcbiAgICBBY3RpdmF0ZU5leHRTdGVwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAobmF2aWdhdGlvbkluc3RydWN0aW9uLCBuZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NBY3RpdmF0YWJsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sICdhY3RpdmF0ZScsIG5leHQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3RpdmF0ZU5leHRTdGVwO1xyXG59KCkpO1xuXG4vKipcclxuICogQSBtdWx0aS1zbG90cyBQaXBlbGluZSBQbGFjZWhvbGRlciBTdGVwIGZvciBob29raW5nIGludG8gYSBwaXBlbGluZSBleGVjdXRpb25cclxuICovXHJcbnZhciBQaXBlbGluZVNsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaXBlbGluZVNsb3QoY29udGFpbmVyLCBuYW1lLCBhbGlhcykge1xyXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLnNsb3ROYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnNsb3RBbGlhcyA9IGFsaWFzO1xyXG4gICAgfVxyXG4gICAgUGlwZWxpbmVTbG90LnByb3RvdHlwZS5nZXRTdGVwcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuY29udGFpbmVyLmdldCh4KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBpcGVsaW5lU2xvdDtcclxufSgpKTtcclxuLyoqXHJcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgbmF2aWdhdGlvbiBwaXBlbGluZS5cclxuICovXHJcbnZhciBQaXBlbGluZVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGlwZWxpbmVQcm92aWRlcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLnN0ZXBzID0gW1xyXG4gICAgICAgICAgICBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcCxcclxuICAgICAgICAgICAgQ2FuRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCxcclxuICAgICAgICAgICAgTG9hZFJvdXRlU3RlcCxcclxuICAgICAgICAgICAgY3JlYXRlUGlwZWxpbmVTbG90KGNvbnRhaW5lciwgXCJhdXRob3JpemVcIiAvKiBBdXRob3JpemUgKi8pLFxyXG4gICAgICAgICAgICBDYW5BY3RpdmF0ZU5leHRTdGVwLFxyXG4gICAgICAgICAgICBjcmVhdGVQaXBlbGluZVNsb3QoY29udGFpbmVyLCBcInByZUFjdGl2YXRlXCIgLyogUHJlQWN0aXZhdGUgKi8sICdtb2RlbGJpbmQnKSxcclxuICAgICAgICAgICAgLy8gTk9URTogYXBwIHN0YXRlIGNoYW5nZXMgc3RhcnQgYmVsb3cgLSBwb2ludCBvZiBubyByZXR1cm5cclxuICAgICAgICAgICAgRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCxcclxuICAgICAgICAgICAgQWN0aXZhdGVOZXh0U3RlcCxcclxuICAgICAgICAgICAgY3JlYXRlUGlwZWxpbmVTbG90KGNvbnRhaW5lciwgXCJwcmVSZW5kZXJcIiAvKiBQcmVSZW5kZXIgKi8sICdwcmVjb21taXQnKSxcclxuICAgICAgICAgICAgQ29tbWl0Q2hhbmdlc1N0ZXAsXHJcbiAgICAgICAgICAgIGNyZWF0ZVBpcGVsaW5lU2xvdChjb250YWluZXIsIFwicG9zdFJlbmRlclwiIC8qIFBvc3RSZW5kZXIgKi8sICdwb3N0Y29tcGxldGUnKVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIFBpcGVsaW5lUHJvdmlkZXIuaW5qZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW0NvbnRhaW5lcl07IH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgbmF2aWdhdGlvbiBwaXBlbGluZS5cclxuICAgICAqL1xyXG4gICAgUGlwZWxpbmVQcm92aWRlci5wcm90b3R5cGUuY3JlYXRlUGlwZWxpbmUgPSBmdW5jdGlvbiAodXNlQ2FuRGVhY3RpdmF0ZVN0ZXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh1c2VDYW5EZWFjdGl2YXRlU3RlcCA9PT0gdm9pZCAwKSB7IHVzZUNhbkRlYWN0aXZhdGVTdGVwID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBwaXBlbGluZSA9IG5ldyBQaXBlbGluZSgpO1xyXG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAodXNlQ2FuRGVhY3RpdmF0ZVN0ZXAgfHwgc3RlcCAhPT0gQ2FuRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgcGlwZWxpbmUuYWRkU3RlcChfdGhpcy5jb250YWluZXIuZ2V0KHN0ZXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwaXBlbGluZTtcclxuICAgIH07XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIFBpcGVsaW5lUHJvdmlkZXIucHJvdG90eXBlLl9maW5kU3RlcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgLy8gU3RlcHMgdGhhdCBhcmUgbm90IFBpcGVsaW5lU2xvdHMgYXJlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucywgYW5kIHRoZXkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhaWwuIFByb2JhYmx5LlxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmZpbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2xvdE5hbWUgPT09IG5hbWUgfHwgeC5zbG90QWxpYXMgPT09IG5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN0ZXAgaW50byB0aGUgcGlwZWxpbmUgYXQgYSBrbm93biBzbG90IGxvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBQaXBlbGluZVByb3ZpZGVyLnByb3RvdHlwZS5hZGRTdGVwID0gZnVuY3Rpb24gKG5hbWUsIHN0ZXApIHtcclxuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLl9maW5kU3RlcChuYW1lKTtcclxuICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgdmFyIHNsb3RTdGVwcyA9IGZvdW5kLnN0ZXBzO1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgaWYgKCFzbG90U3RlcHMuaW5jbHVkZXMoc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RTdGVwcy5wdXNoKHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBpcGVsaW5lIHNsb3QgbmFtZTogXCIgKyBuYW1lICsgXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBzdGVwIGZyb20gYSBzbG90IGluIHRoZSBwaXBlbGluZVxyXG4gICAgICovXHJcbiAgICBQaXBlbGluZVByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVTdGVwID0gZnVuY3Rpb24gKG5hbWUsIHN0ZXApIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuX2ZpbmRTdGVwKG5hbWUpO1xyXG4gICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgIHZhciBzbG90U3RlcHMgPSBzbG90LnN0ZXBzO1xyXG4gICAgICAgICAgICBzbG90U3RlcHMuc3BsaWNlKHNsb3RTdGVwcy5pbmRleE9mKHN0ZXApLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHN0ZXBzIGZyb20gYSBzbG90IGluIHRoZSBwaXBlbGluZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIFBpcGVsaW5lUHJvdmlkZXIucHJvdG90eXBlLl9jbGVhclN0ZXBzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5fZmluZFN0ZXAobmFtZSk7XHJcbiAgICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgc2xvdC5zdGVwcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBhbGwgcGlwZWxpbmUgc2xvdHNcclxuICAgICAqL1xyXG4gICAgUGlwZWxpbmVQcm92aWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJTdGVwcyhcImF1dGhvcml6ZVwiIC8qIEF1dGhvcml6ZSAqLyk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJTdGVwcyhcInByZUFjdGl2YXRlXCIgLyogUHJlQWN0aXZhdGUgKi8pO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyU3RlcHMoXCJwcmVSZW5kZXJcIiAvKiBQcmVSZW5kZXIgKi8pO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyU3RlcHMoXCJwb3N0UmVuZGVyXCIgLyogUG9zdFJlbmRlciAqLyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBpcGVsaW5lUHJvdmlkZXI7XHJcbn0oKSk7XHJcbi8qKkBpbnRlcm5hbCAqL1xyXG52YXIgY3JlYXRlUGlwZWxpbmVTbG90ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgbmFtZSwgYWxpYXMpIHtcclxuICAgIHJldHVybiBuZXcgUGlwZWxpbmVTbG90KGNvbnRhaW5lciwgbmFtZSwgYWxpYXMpO1xyXG59O1xuXG52YXIgbG9nZ2VyID0gZ2V0TG9nZ2VyKCdhcHAtcm91dGVyJyk7XHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBhcHBsaWNhdGlvbiByb3V0ZXIuXHJcbiAqL1xyXG52YXIgQXBwUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFwcFJvdXRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFwcFJvdXRlcihjb250YWluZXIsIGhpc3RvcnksIHBpcGVsaW5lUHJvdmlkZXIsIGV2ZW50cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lciwgaGlzdG9yeSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5waXBlbGluZVByb3ZpZGVyID0gcGlwZWxpbmVQcm92aWRlcjtcclxuICAgICAgICBfdGhpcy5ldmVudHMgPSBldmVudHM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqQGludGVybmFsICovXHJcbiAgICBBcHBSb3V0ZXIuaW5qZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW0NvbnRhaW5lciwgSGlzdG9yeSwgUGlwZWxpbmVQcm92aWRlciwgRXZlbnRBZ2dyZWdhdG9yXTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogRnVsbHkgcmVzZXRzIHRoZSByb3V0ZXIncyBpbnRlcm5hbCBzdGF0ZS4gUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseSBieSB0aGUgZnJhbWV3b3JrIHdoZW4gbXVsdGlwbGUgY2FsbHMgdG8gc2V0Um9vdCBhcmUgbWFkZS5cclxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24gKGFjdHVhbGx5LCBhdm9pZCB1c2luZyB0aGlzKS4gRG8gbm90IHVzZSB0aGlzIHRvIHNpbXBseSBjaGFuZ2UgeW91ciBuYXZpZ2F0aW9uIG1vZGVsLlxyXG4gICAgICovXHJcbiAgICBBcHBSb3V0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm1heEluc3RydWN0aW9uQ291bnQgPSAxMDtcclxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBzcGVjaWZpZWQgVVJMLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCBmcmFnbWVudCB0byBsb2FkLlxyXG4gICAgICovXHJcbiAgICBBcHBSb3V0ZXIucHJvdG90eXBlLmxvYWRVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICAuX2NyZWF0ZU5hdmlnYXRpb25JbnN0cnVjdGlvbih1cmwpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikgeyByZXR1cm4gX3RoaXMuX3F1ZXVlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pOyB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIHJlc3RvcmVQcmV2aW91c0xvY2F0aW9uKF90aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIHZpZXdQb3J0IHRvIGJlIHVzZWQgYXMgYSByZW5kZXJpbmcgdGFyZ2V0IGZvciBhY3RpdmF0ZWQgcm91dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aWV3UG9ydCBUaGUgdmlld1BvcnQuIFRoaXMgaXMgdHlwaWNhbGx5IGEgPHJvdXRlci12aWV3Lz4gZWxlbWVudCBpbiBBdXJlbGlhIGRlZmF1bHQgaW1wbFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZpZXdQb3J0LiAnZGVmYXVsdCcgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIEFwcFJvdXRlci5wcm90b3R5cGUucmVnaXN0ZXJWaWV3UG9ydCA9IGZ1bmN0aW9uICh2aWV3UG9ydCwgbmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gaGF2aW5nIHN0cm9uZyB0eXBpbmcgd2l0aG91dCBjaGFuZ2luZyBwdWJsaWMgQVBJXHJcbiAgICAgICAgdmFyICR2aWV3UG9ydCA9IHZpZXdQb3J0O1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVnaXN0ZXJWaWV3UG9ydC5jYWxsKHRoaXMsICR2aWV3UG9ydCwgbmFtZSk7XHJcbiAgICAgICAgLy8gYmVzaWRlIGFkZGluZyB2aWV3cG9ydCB0byB0aGUgcmVnaXN0cnkgb2YgdGhpcyBpbnN0YW5jZVxyXG4gICAgICAgIC8vIEFwcFJvdXRlciBhbHNvIGNvbmZpZ3VyZSByb3V0aW5nL2hpc3RvcnkgdG8gc3RhcnQgcm91dGluZyBmdW5jdGlvbmFsaXR5XHJcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpdHVhdGlvbiB3aGVyZSB0aGVyZSBhcmUgbW9yZSB0aGFuIDEgPHJvdXRlci12aWV3Lz4gZWxlbWVudCBhdCByb290IHZpZXdcclxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHN0aWxsIG9ubHkgYWN0aXZhdGUgb25jZSB2aWEgdGhlIGZvbGxvd2luZyBndWFyZFxyXG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmlld01vZGVsXzEgPSB0aGlzLl9maW5kVmlld01vZGVsKCR2aWV3UG9ydCk7XHJcbiAgICAgICAgICAgIGlmICgnY29uZmlndXJlUm91dGVyJyBpbiB2aWV3TW9kZWxfMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgPHJvdXRlci12aWV3Lz4gZWxlbWVudCBhdCByb290IHZpZXdcclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGlzIGZsYWcgdG8gZ3VhcmQgYWdhaW5zdCBjb25maWd1cmUgbWV0aG9kIGJlaW5nIGludm9rZWQgbXVsdGlwbGUgdGltZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBzZXQgaW5zaWRlIG1ldGhvZCBjb25maWd1cmVcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0NvbmZpZ3VyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSByZWFsIHJlc29sdmUgd2l0aCBhIG5vb3AgdG8gZ3VhcmFudGVlIHRoYXQgYW55IGFjdGlvbiBpbiBiYXNlIGNsYXNzIFJvdXRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvbid0IHJlc29sdmUgdGhlIGNvbmZpZ3VyZVByb21pc2UgcHJlbWF0dXJlbHlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUNvbmZpZ3VyZWRQcm9taXNlXzEgPSB0aGlzLl9yZXNvbHZlQ29uZmlndXJlZFByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUNvbmZpZ3VyZWRQcm9taXNlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25maWd1cmUoZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlc29sdmUodmlld01vZGVsXzEuY29uZmlndXJlUm91dGVyKGNvbmZpZywgX3RoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaXNzdWUgd2l0aCBjb25maWd1cmUgaW50ZXJmYWNlLiBTaG91bGQgYmUgZml4ZWQgdGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IGZpeCB0aGlzIHZpYSBjb25maWd1cmUgaW50ZXJmYWNlIGluIHJvdXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDb25maWd1cmVkUHJvbWlzZV8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2hlbiBhIHZpZXdwb3J0IGlzIGFkZGVkIGR5bmFtaWNhbGx5IHRvIGEgcm9vdCB2aWV3IHRoYXQgaXMgYWxyZWFkeSBhY3RpdmF0ZWRcclxuICAgICAgICAvLyBqdXN0IHByb2Nlc3MgdGhlIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb25cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZUluc3RydWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyB0aGUgcm91dGVyLiBUaGlzIGluc3RydWN0cyB0aGUgcm91dGVyIHRvIGJlZ2luIGxpc3RlbmluZyBmb3IgaGlzdG9yeSBjaGFuZ2VzIGFuZCBwcm9jZXNzaW5nIGluc3RydWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW1zIG9wdGlvbnMgVGhlIHNldCBvZiBvcHRpb25zIHRvIGFjdGl2YXRlIHRoZSByb3V0ZXIgd2l0aC5cclxuICAgICAqL1xyXG4gICAgQXBwUm91dGVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAvLyByb3V0ZSBoYW5kbGVyIHByb3BlcnR5IGlzIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB1cmwgY2hhbmdlXHJcbiAgICAgICAgLy8gdGhlIGludGVyZmFjZSBvZiBhdXJlbGlhLWhpc3RvcnkgaXNuJ3QgY2xlYXIgb24gdGhpcyBwZXJzcGVjdGl2ZVxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyByb3V0ZUhhbmRsZXI6IHRoaXMubG9hZFVybC5iaW5kKHRoaXMpIH0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5LmFjdGl2YXRlKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fZGVxdWV1ZUluc3RydWN0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgcm91dGVyLlxyXG4gICAgICovXHJcbiAgICBBcHBSb3V0ZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeS5kZWFjdGl2YXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqQGludGVybmFsICovXHJcbiAgICBBcHBSb3V0ZXIucHJvdG90eXBlLl9xdWV1ZUluc3RydWN0aW9uID0gZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9xdWV1ZS51bnNoaWZ0KGluc3RydWN0aW9uKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RlcXVldWVJbnN0cnVjdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKkBpbnRlcm5hbCAqL1xyXG4gICAgQXBwUm91dGVyLnByb3RvdHlwZS5fZGVxdWV1ZUluc3RydWN0aW9uID0gZnVuY3Rpb24gKGluc3RydWN0aW9uQ291bnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpbnN0cnVjdGlvbkNvdW50ID09PSB2b2lkIDApIHsgaW5zdHJ1Y3Rpb25Db3VudCA9IDA7IH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc05hdmlnYXRpbmcgJiYgIWluc3RydWN0aW9uQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzIGNvbXBsYWlucyBhYm91dCBpbmNvbnNpc3RlbnQgcmV0dXJucyB3aXRob3V0IHZvaWQgMFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBfdGhpcy5fcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgX3RoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzIGNvbXBsYWlucyBhYm91dCBpbmNvbnNpc3RlbnQgcmV0dXJucyB3aXRob3V0IHZvaWQgMFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5pc05hdmlnYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgbmF2dHJhY2tlciA9IF90aGlzLmhpc3RvcnkuZ2V0U3RhdGUoJ05hdmlnYXRpb25UcmFja2VyJyk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50TmF2VHJhY2tlciA9IF90aGlzLmN1cnJlbnROYXZpZ2F0aW9uVHJhY2tlcjtcclxuICAgICAgICAgICAgaWYgKCFuYXZ0cmFja2VyICYmICFjdXJyZW50TmF2VHJhY2tlcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNOYXZpZ2F0aW5nRmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNOYXZpZ2F0aW5nTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghbmF2dHJhY2tlcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNOYXZpZ2F0aW5nTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghY3VycmVudE5hdlRyYWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmlzTmF2aWdhdGluZ1JlZnJlc2ggPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnROYXZUcmFja2VyIDwgbmF2dHJhY2tlcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNOYXZpZ2F0aW5nRm9yd2FyZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE5hdlRyYWNrZXIgPiBuYXZ0cmFja2VyKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc05hdmlnYXRpbmdCYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5hdnRyYWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIG5hdnRyYWNrZXIgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaGlzdG9yeS5zZXRTdGF0ZSgnTmF2aWdhdGlvblRyYWNrZXInLCBuYXZ0cmFja2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF2aWdhdGlvblRyYWNrZXIgPSBuYXZ0cmFja2VyO1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5wcmV2aW91c0luc3RydWN0aW9uID0gX3RoaXMuY3VycmVudEluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgbWF4SW5zdHJ1Y3Rpb25Db3VudCA9IF90aGlzLm1heEluc3RydWN0aW9uQ291bnQ7XHJcbiAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb25Db3VudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRzLnB1Ymxpc2goXCJyb3V0ZXI6bmF2aWdhdGlvbjpwcm9jZXNzaW5nXCIgLyogUHJvY2Vzc2luZyAqLywgeyBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25Db3VudCA9PT0gbWF4SW5zdHJ1Y3Rpb25Db3VudCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihpbnN0cnVjdGlvbkNvdW50ICsgMSArIFwiIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb25zIGhhdmUgYmVlbiBhdHRlbXB0ZWQgd2l0aG91dCBzdWNjZXNzLiBSZXN0b3JpbmcgbGFzdCBrbm93biBnb29kIGxvY2F0aW9uLlwiKTtcclxuICAgICAgICAgICAgICAgIHJlc3RvcmVQcmV2aW91c0xvY2F0aW9uKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVxdWV1ZUluc3RydWN0aW9uKGluc3RydWN0aW9uQ291bnQgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbkNvdW50ID4gbWF4SW5zdHJ1Y3Rpb25Db3VudCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG5hdmlnYXRpb24gYXR0ZW1wdHMgZXhjZWVkZWQuIEdpdmluZyB1cC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGlwZWxpbmUgPSBfdGhpcy5waXBlbGluZVByb3ZpZGVyLmNyZWF0ZVBpcGVsaW5lKCFfdGhpcy5jb3VsZERlYWN0aXZhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlwZWxpbmVcclxuICAgICAgICAgICAgICAgIC5ydW4oaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBwcm9jZXNzUmVzdWx0KGluc3RydWN0aW9uLCByZXN1bHQsIGluc3RydWN0aW9uQ291bnQsIF90aGlzKTsgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG91dHB1dDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKSB9O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzb2x2ZUluc3RydWN0aW9uKGluc3RydWN0aW9uLCByZXN1bHQsICEhaW5zdHJ1Y3Rpb25Db3VudCwgX3RoaXMpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipAaW50ZXJuYWwgKi9cclxuICAgIEFwcFJvdXRlci5wcm90b3R5cGUuX2ZpbmRWaWV3TW9kZWwgPSBmdW5jdGlvbiAodmlld1BvcnQpIHtcclxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIudmlld01vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci52aWV3TW9kZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3UG9ydC5jb250YWluZXIpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHZpZXdQb3J0LmNvbnRhaW5lcjtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci52aWV3TW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci52aWV3TW9kZWwgPSBjb250YWluZXIudmlld01vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIudmlld01vZGVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBcHBSb3V0ZXI7XHJcbn0oUm91dGVyKSk7XHJcbnZhciBwcm9jZXNzUmVzdWx0ID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCByZXN1bHQsIGluc3RydWN0aW9uQ291bnQsIHJvdXRlcikge1xyXG4gICAgaWYgKCEocmVzdWx0ICYmICdjb21wbGV0ZWQnIGluIHJlc3VsdCAmJiAnb3V0cHV0JyBpbiByZXN1bHQpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xyXG4gICAgICAgIHJlc3VsdC5vdXRwdXQgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByb3V0ZXIgcGlwZWxpbmUgdG8gcmV0dXJuIGEgbmF2aWdhdGlvbiByZXN1bHQsIGJ1dCBnb3QgW1wiICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSArIFwiXSBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuICAgIHZhciBmaW5hbFJlc3VsdCA9IG51bGw7XHJcbiAgICB2YXIgbmF2aWdhdGlvbkNvbW1hbmRSZXN1bHQgPSBudWxsO1xyXG4gICAgaWYgKGlzTmF2aWdhdGlvbkNvbW1hbmQocmVzdWx0Lm91dHB1dCkpIHtcclxuICAgICAgICBuYXZpZ2F0aW9uQ29tbWFuZFJlc3VsdCA9IHJlc3VsdC5vdXRwdXQubmF2aWdhdGUocm91dGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpbmFsUmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIGlmICghcmVzdWx0LmNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lm91dHB1dCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IocmVzdWx0Lm91dHB1dC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN0b3JlUHJldmlvdXNMb2NhdGlvbihyb3V0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmF2aWdhdGlvbkNvbW1hbmRSZXN1bHQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIHJvdXRlci5fZGVxdWV1ZUluc3RydWN0aW9uKGluc3RydWN0aW9uQ291bnQgKyAxKTsgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5uZXJSZXN1bHQpIHsgcmV0dXJuIGZpbmFsUmVzdWx0IHx8IGlubmVyUmVzdWx0IHx8IHJlc3VsdDsgfSk7XHJcbn07XHJcbnZhciByZXNvbHZlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIHJlc3VsdCwgaXNJbm5lckluc3RydWN0aW9uLCByb3V0ZXIpIHtcclxuICAgIGluc3RydWN0aW9uLnJlc29sdmUocmVzdWx0KTtcclxuICAgIHZhciBldmVudEFnZ3JlZ2F0b3IgPSByb3V0ZXIuZXZlbnRzO1xyXG4gICAgdmFyIGV2ZW50QXJncyA9IHsgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9uLCByZXN1bHQ6IHJlc3VsdCB9O1xyXG4gICAgaWYgKCFpc0lubmVySW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICByb3V0ZXIuaXNOYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcm91dGVyLmlzRXhwbGljaXROYXZpZ2F0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgcm91dGVyLmlzRXhwbGljaXROYXZpZ2F0aW9uQmFjayA9IGZhbHNlO1xyXG4gICAgICAgIHJvdXRlci5pc05hdmlnYXRpbmdGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIHJvdXRlci5pc05hdmlnYXRpbmdOZXcgPSBmYWxzZTtcclxuICAgICAgICByb3V0ZXIuaXNOYXZpZ2F0aW5nUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHJvdXRlci5pc05hdmlnYXRpbmdGb3J3YXJkID0gZmFsc2U7XHJcbiAgICAgICAgcm91dGVyLmlzTmF2aWdhdGluZ0JhY2sgPSBmYWxzZTtcclxuICAgICAgICByb3V0ZXIuY291bGREZWFjdGl2YXRlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHZvaWQgMDtcclxuICAgICAgICBpZiAocmVzdWx0Lm91dHB1dCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwicm91dGVyOm5hdmlnYXRpb246ZXJyb3JcIiAvKiBFcnJvciAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXJlc3VsdC5jb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJyb3V0ZXI6bmF2aWdhdGlvbjpjYW5jZWxlZFwiIC8qIENhbmNlbGVkICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gaW5zdHJ1Y3Rpb24ucXVlcnlTdHJpbmcgPyAoJz8nICsgaW5zdHJ1Y3Rpb24ucXVlcnlTdHJpbmcpIDogJyc7XHJcbiAgICAgICAgICAgIHJvdXRlci5oaXN0b3J5LnByZXZpb3VzTG9jYXRpb24gPSBpbnN0cnVjdGlvbi5mcmFnbWVudCArIHF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBcInJvdXRlcjpuYXZpZ2F0aW9uOnN1Y2Nlc3NcIiAvKiBTdWNjZXNzICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudEFnZ3JlZ2F0b3IucHVibGlzaChldmVudE5hbWUsIGV2ZW50QXJncyk7XHJcbiAgICAgICAgZXZlbnRBZ2dyZWdhdG9yLnB1Ymxpc2goXCJyb3V0ZXI6bmF2aWdhdGlvbjpjb21wbGV0ZVwiIC8qIENvbXBsZXRlICovLCBldmVudEFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXZlbnRBZ2dyZWdhdG9yLnB1Ymxpc2goXCJyb3V0ZXI6bmF2aWdhdGlvbjpjaGlsZDpjb21wbGV0ZVwiIC8qIENoaWxkQ29tcGxldGUgKi8sIGV2ZW50QXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG52YXIgcmVzdG9yZVByZXZpb3VzTG9jYXRpb24gPSBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICB2YXIgcHJldmlvdXNMb2NhdGlvbiA9IHJvdXRlci5oaXN0b3J5LnByZXZpb3VzTG9jYXRpb247XHJcbiAgICBpZiAocHJldmlvdXNMb2NhdGlvbikge1xyXG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZShwcmV2aW91c0xvY2F0aW9uLCB7IHRyaWdnZXI6IGZhbHNlLCByZXBsYWNlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocm91dGVyLmZhbGxiYWNrUm91dGUpIHtcclxuICAgICAgICByb3V0ZXIubmF2aWdhdGUocm91dGVyLmZhbGxiYWNrUm91dGUsIHsgdHJpZ2dlcjogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcignUm91dGVyIG5hdmlnYXRpb24gZmFpbGVkLCBhbmQgbm8gcHJldmlvdXMgbG9jYXRpb24gb3IgZmFsbGJhY2tSb3V0ZSBjb3VsZCBiZSByZXN0b3JlZC4nKTtcclxuICAgIH1cclxufTtcblxuLyoqXHJcbiogVGhlIHN0YXR1cyBvZiBhIFBpcGVsaW5lLlxyXG4qL1xyXG52YXIgUGlwZWxpbmVTdGF0dXM7XHJcbihmdW5jdGlvbiAoUGlwZWxpbmVTdGF0dXMpIHtcclxuICAgIFBpcGVsaW5lU3RhdHVzW1wiQ29tcGxldGVkXCJdID0gXCJjb21wbGV0ZWRcIjtcclxuICAgIFBpcGVsaW5lU3RhdHVzW1wiQ2FuY2VsZWRcIl0gPSBcImNhbmNlbGVkXCI7XHJcbiAgICBQaXBlbGluZVN0YXR1c1tcIlJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xyXG4gICAgUGlwZWxpbmVTdGF0dXNbXCJSdW5uaW5nXCJdID0gXCJydW5uaW5nXCI7XHJcbn0pKFBpcGVsaW5lU3RhdHVzIHx8IChQaXBlbGluZVN0YXR1cyA9IHt9KSk7XG5cbi8qKlxyXG4gKiBBIGxpc3Qgb2Yga25vd24gcm91dGVyIGV2ZW50cyB1c2VkIGJ5IHRoZSBBdXJlbGlhIHJvdXRlclxyXG4gKiB0byBzaWduYWwgdGhlIHBpcGVsaW5lIGhhcyBjb21lIHRvIGEgY2VydGFpbiBzdGF0ZVxyXG4gKi9cclxuLy8gY29uc3QgZW51bSBpcyBwcmVzZXJ2ZWQgaW4gdHNjb25maWdcclxudmFyIFJvdXRlckV2ZW50O1xyXG4oZnVuY3Rpb24gKFJvdXRlckV2ZW50KSB7XHJcbiAgICBSb3V0ZXJFdmVudFtcIlByb2Nlc3NpbmdcIl0gPSBcInJvdXRlcjpuYXZpZ2F0aW9uOnByb2Nlc3NpbmdcIjtcclxuICAgIFJvdXRlckV2ZW50W1wiRXJyb3JcIl0gPSBcInJvdXRlcjpuYXZpZ2F0aW9uOmVycm9yXCI7XHJcbiAgICBSb3V0ZXJFdmVudFtcIkNhbmNlbGVkXCJdID0gXCJyb3V0ZXI6bmF2aWdhdGlvbjpjYW5jZWxlZFwiO1xyXG4gICAgUm91dGVyRXZlbnRbXCJDb21wbGV0ZVwiXSA9IFwicm91dGVyOm5hdmlnYXRpb246Y29tcGxldGVcIjtcclxuICAgIFJvdXRlckV2ZW50W1wiU3VjY2Vzc1wiXSA9IFwicm91dGVyOm5hdmlnYXRpb246c3VjY2Vzc1wiO1xyXG4gICAgUm91dGVyRXZlbnRbXCJDaGlsZENvbXBsZXRlXCJdID0gXCJyb3V0ZXI6bmF2aWdhdGlvbjpjaGlsZDpjb21wbGV0ZVwiO1xyXG59KShSb3V0ZXJFdmVudCB8fCAoUm91dGVyRXZlbnQgPSB7fSkpO1xuXG4vKipcclxuICogQXZhaWxhYmxlIHBpcGVsaW5lIHNsb3QgbmFtZXMgdG8gaW5zZXJ0IGludGVyY2VwdG9yIGludG8gcm91dGVyIHBpcGVsaW5lXHJcbiAqL1xyXG4vLyBjb25zdCBlbnVtIGlzIHByZXNlcnZlZCBpbiB0c2NvbmZpZ1xyXG52YXIgUGlwZWxpbmVTbG90TmFtZTtcclxuKGZ1bmN0aW9uIChQaXBlbGluZVNsb3ROYW1lKSB7XHJcbiAgICAvKipcclxuICAgICAqIEF1dGhvcml6YXRpb24gc2xvdC4gSW52b2tlZCBlYXJseSBpbiB0aGUgcGlwZWxpbmUsXHJcbiAgICAgKiBiZWZvcmUgYGNhbkFjdGl2YXRlYCBob29rIG9mIGluY29taW5nIHJvdXRlXHJcbiAgICAgKi9cclxuICAgIFBpcGVsaW5lU2xvdE5hbWVbXCJBdXRob3JpemVcIl0gPSBcImF1dGhvcml6ZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmUtYWN0aXZhdGlvbiBzbG90LiBJbnZva2VkIGVhcmx5IGluIHRoZSBwaXBlbGluZSxcclxuICAgICAqIEludm9rZWQgdGltaW5nOlxyXG4gICAgICogICAtIGFmdGVyIEF1dGhvcml6YXRpb24gc2xvdFxyXG4gICAgICogICAtIGFmdGVyIGNhbkFjdGl2YXRlIGhvb2sgb24gbmV3IHZpZXcgbW9kZWxcclxuICAgICAqICAgLSBiZWZvcmUgZGVhY3RpdmF0ZSBob29rIG9uIG9sZCB2aWV3IG1vZGVsXHJcbiAgICAgKiAgIC0gYmVmb3JlIGFjdGl2YXRlIGhvb2sgb24gbmV3IHZpZXcgbW9kZWxcclxuICAgICAqL1xyXG4gICAgUGlwZWxpbmVTbG90TmFtZVtcIlByZUFjdGl2YXRlXCJdID0gXCJwcmVBY3RpdmF0ZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmUtcmVuZGVyIHNsb3QuIEludm9rZWQgbGF0ZXIgaW4gdGhlIHBpcGVsaW5lXHJcbiAgICAgKiBJbnZva2NhdGlvbiB0aW1pbmc6XHJcbiAgICAgKiAgIC0gYWZ0ZXIgYWN0aXZhdGUgaG9vayBvbiBuZXcgdmlldyBtb2RlbFxyXG4gICAgICogICAtIGJlZm9yZSBjb21taXQgc3RlcCBvbiBuZXcgbmF2aWdhdGlvbiBpbnN0cnVjdGlvblxyXG4gICAgICovXHJcbiAgICBQaXBlbGluZVNsb3ROYW1lW1wiUHJlUmVuZGVyXCJdID0gXCJwcmVSZW5kZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUG9zdC1yZW5kZXIgc2xvdC4gSW52b2tlZCBsYXN0IGluIHRoZSBwaXBlbGluZVxyXG4gICAgICovXHJcbiAgICBQaXBlbGluZVNsb3ROYW1lW1wiUG9zdFJlbmRlclwiXSA9IFwicG9zdFJlbmRlclwiO1xyXG59KShQaXBlbGluZVNsb3ROYW1lIHx8IChQaXBlbGluZVNsb3ROYW1lID0ge30pKTtcblxuZXhwb3J0IHsgQWN0aXZhdGVOZXh0U3RlcCwgQXBwUm91dGVyLCBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcCwgQ2FuQWN0aXZhdGVOZXh0U3RlcCwgQ2FuRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCwgQ29tbWl0Q2hhbmdlc1N0ZXAsIERlYWN0aXZhdGVQcmV2aW91c1N0ZXAsIExvYWRSb3V0ZVN0ZXAsIE5hdk1vZGVsLCBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIFBpcGVsaW5lLCBQaXBlbGluZVByb3ZpZGVyLCBQaXBlbGluZVNsb3ROYW1lLCBQaXBlbGluZVN0YXR1cywgUmVkaXJlY3QsIFJlZGlyZWN0VG9Sb3V0ZSwgUm91dGVMb2FkZXIsIFJvdXRlciwgUm91dGVyQ29uZmlndXJhdGlvbiwgUm91dGVyRXZlbnQsIGFjdGl2YXRpb25TdHJhdGVneSwgaXNOYXZpZ2F0aW9uQ29tbWFuZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVyZWxpYS1yb3V0ZXIuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4ysu\n");

/***/ })

}]);