(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-validation~6903c527"],{

/***/ "aurelia-validation":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-validation/dist/native-modules/aurelia-validation.js ***!
  \***********************************************************************************/
/*! exports provided: AureliaValidationConfiguration, configure, getTargetDOMElement, getPropertyInfo, PropertyAccessorParser, getAccessorExpression, ValidateBindingBehavior, ValidateManuallyBindingBehavior, ValidateOnBlurBindingBehavior, ValidateOnChangeBindingBehavior, ValidateOnChangeOrBlurBindingBehavior, ValidateEvent, ValidateResult, validateTrigger, ValidationController, ValidationControllerFactory, ValidationErrorsCustomAttribute, ValidationRendererCustomAttribute, Validator, Rules, StandardValidator, validationMessages, ValidationMessageProvider, ValidationMessageParser, MessageExpressionValidator, FluentRuleCustomizer, FluentRules, FluentEnsure, ValidationRules */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AureliaValidationConfiguration\", function() { return AureliaValidationConfiguration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTargetDOMElement\", function() { return getTargetDOMElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPropertyInfo\", function() { return getPropertyInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyAccessorParser\", function() { return PropertyAccessorParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAccessorExpression\", function() { return getAccessorExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateBindingBehavior\", function() { return ValidateBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateManuallyBindingBehavior\", function() { return ValidateManuallyBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnBlurBindingBehavior\", function() { return ValidateOnBlurBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnChangeBindingBehavior\", function() { return ValidateOnChangeBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnChangeOrBlurBindingBehavior\", function() { return ValidateOnChangeOrBlurBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateEvent\", function() { return ValidateEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateResult\", function() { return ValidateResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTrigger\", function() { return validateTrigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationController\", function() { return ValidationController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationControllerFactory\", function() { return ValidationControllerFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationErrorsCustomAttribute\", function() { return ValidationErrorsCustomAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationRendererCustomAttribute\", function() { return ValidationRendererCustomAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Validator\", function() { return Validator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rules\", function() { return Rules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StandardValidator\", function() { return StandardValidator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validationMessages\", function() { return validationMessages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationMessageProvider\", function() { return ValidationMessageProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationMessageParser\", function() { return ValidationMessageParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageExpressionValidator\", function() { return MessageExpressionValidator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentRuleCustomizer\", function() { return FluentRuleCustomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentRules\", function() { return FluentRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentEnsure\", function() { return FluentEnsure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationRules\", function() { return ValidationRules; });\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\n/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-binding */ \"X5gX\");\n/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-dependency-injection */ \"3U8n\");\n/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-task-queue */ \"K/SW\");\n/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n\n\n\n\n\n\n\n/**\r\n * Gets the DOM element associated with the data-binding. Most of the time it's\r\n * the binding.target but sometimes binding.target is an aurelia custom element,\r\n * or custom attribute which is a javascript \"class\" instance, so we need to use\r\n * the controller's container to retrieve the actual DOM element.\r\n */\r\nfunction getTargetDOMElement(binding, view) {\r\n    var target = binding.target;\r\n    // DOM element\r\n    if (target instanceof Element) {\r\n        return target;\r\n    }\r\n    // custom element or custom attribute\r\n    // tslint:disable-next-line:prefer-const\r\n    for (var i = 0, ii = view.controllers.length; i < ii; i++) {\r\n        var controller = view.controllers[i];\r\n        if (controller.viewModel === target) {\r\n            var element = controller.container.get(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"DOM\"].Element);\r\n            if (element) {\r\n                return element;\r\n            }\r\n            throw new Error(\"Unable to locate target element for \\\"\" + binding.sourceExpression + \"\\\".\");\r\n        }\r\n    }\r\n    throw new Error(\"Unable to locate target element for \\\"\" + binding.sourceExpression + \"\\\".\");\r\n}\n\nfunction getObject(expression, objectExpression, source) {\r\n    var value = objectExpression.evaluate(source, null);\r\n    if (value === null || value === undefined || value instanceof Object) {\r\n        return value;\r\n    }\r\n    // tslint:disable-next-line:max-line-length\r\n    throw new Error(\"The '\" + objectExpression + \"' part of '\" + expression + \"' evaluates to \" + value + \" instead of an object, null or undefined.\");\r\n}\r\n/**\r\n * Retrieves the object and property name for the specified expression.\r\n * @param expression The expression\r\n * @param source The scope\r\n */\r\nfunction getPropertyInfo(expression, source) {\r\n    var originalExpression = expression;\r\n    while (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"BindingBehavior\"] || expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"ValueConverter\"]) {\r\n        expression = expression.expression;\r\n    }\r\n    var object;\r\n    var propertyName;\r\n    if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]) {\r\n        object = Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"getContextFor\"])(expression.name, source, expression.ancestor);\r\n        propertyName = expression.name;\r\n    }\r\n    else if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessMember\"]) {\r\n        object = getObject(originalExpression, expression.object, source);\r\n        propertyName = expression.name;\r\n    }\r\n    else if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessKeyed\"]) {\r\n        object = getObject(originalExpression, expression.object, source);\r\n        propertyName = expression.key.evaluate(source);\r\n    }\r\n    else {\r\n        throw new Error(\"Expression '\" + originalExpression + \"' is not compatible with the validate binding-behavior.\");\r\n    }\r\n    if (object === null || object === undefined) {\r\n        return null;\r\n    }\r\n    return { object: object, propertyName: propertyName };\r\n}\n\nfunction isString(value) {\r\n    return Object.prototype.toString.call(value) === '[object String]';\r\n}\r\nfunction isNumber(value) {\r\n    return Object.prototype.toString.call(value) === '[object Number]';\r\n}\n\nvar PropertyAccessorParser = /** @class */ (function () {\r\n    function PropertyAccessorParser(parser) {\r\n        this.parser = parser;\r\n    }\r\n    PropertyAccessorParser.prototype.parse = function (property) {\r\n        if (isString(property) || isNumber(property)) {\r\n            return property;\r\n        }\r\n        var accessorText = getAccessorExpression(property.toString());\r\n        var accessor = this.parser.parse(accessorText);\r\n        if (accessor instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]\r\n            || accessor instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessMember\"] && accessor.object instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]) {\r\n            return accessor.name;\r\n        }\r\n        throw new Error(\"Invalid property expression: \\\"\" + accessor + \"\\\"\");\r\n    };\r\n    PropertyAccessorParser.inject = [aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Parser\"]];\r\n    return PropertyAccessorParser;\r\n}());\r\nfunction getAccessorExpression(fn) {\r\n    /* tslint:disable:max-line-length */\r\n    var classic = /^function\\s*\\([$_\\w\\d]+\\)\\s*\\{(?:\\s*\"use strict\";)?\\s*(?:[$_\\w\\d.['\"\\]+;]+)?\\s*return\\s+[$_\\w\\d]+\\.([$_\\w\\d]+)\\s*;?\\s*\\}$/;\r\n    /* tslint:enable:max-line-length */\r\n    var arrow = /^\\(?[$_\\w\\d]+\\)?\\s*=>\\s*[$_\\w\\d]+\\.([$_\\w\\d]+)$/;\r\n    var match = classic.exec(fn) || arrow.exec(fn);\r\n    if (match === null) {\r\n        throw new Error(\"Unable to parse accessor function:\\n\" + fn);\r\n    }\r\n    return match[1];\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\n\n/**\r\n * Validation triggers.\r\n */\r\nvar validateTrigger;\r\n(function (validateTrigger) {\r\n    /**\r\n     * Manual validation.  Use the controller's `validate()` and  `reset()` methods\r\n     * to validate all bindings.\r\n     */\r\n    validateTrigger[validateTrigger[\"manual\"] = 0] = \"manual\";\r\n    /**\r\n     * Validate the binding when the binding's target element fires a DOM \"blur\" event.\r\n     */\r\n    validateTrigger[validateTrigger[\"blur\"] = 1] = \"blur\";\r\n    /**\r\n     * Validate the binding when it updates the model due to a change in the view.\r\n     */\r\n    validateTrigger[validateTrigger[\"change\"] = 2] = \"change\";\r\n    /**\r\n     * Validate the binding when the binding's target element fires a DOM \"blur\" event and\r\n     * when it updates the model due to a change in the view.\r\n     */\r\n    validateTrigger[validateTrigger[\"changeOrBlur\"] = 3] = \"changeOrBlur\";\r\n})(validateTrigger || (validateTrigger = {}));\n\n/**\r\n * Validates objects and properties.\r\n */\r\nvar Validator = /** @class */ (function () {\r\n    function Validator() {\r\n    }\r\n    return Validator;\r\n}());\n\n/**\r\n * The result of validating an individual validation rule.\r\n */\r\nvar ValidateResult = /** @class */ (function () {\r\n    /**\r\n     * @param rule The rule associated with the result. Validator implementation specific.\r\n     * @param object The object that was validated.\r\n     * @param propertyName The name of the property that was validated.\r\n     * @param error The error, if the result is a validation error.\r\n     */\r\n    function ValidateResult(rule, object, propertyName, valid, message) {\r\n        if (message === void 0) { message = null; }\r\n        this.rule = rule;\r\n        this.object = object;\r\n        this.propertyName = propertyName;\r\n        this.valid = valid;\r\n        this.message = message;\r\n        this.id = ValidateResult.nextId++;\r\n    }\r\n    ValidateResult.prototype.toString = function () {\r\n        return this.valid ? 'Valid.' : this.message;\r\n    };\r\n    ValidateResult.nextId = 0;\r\n    return ValidateResult;\r\n}());\n\nvar ValidateEvent = /** @class */ (function () {\r\n    function ValidateEvent(\r\n    /**\r\n     * The type of validate event. Either \"validate\" or \"reset\".\r\n     */\r\n    type, \r\n    /**\r\n     * The controller's current array of errors. For an array containing both\r\n     * failed rules and passed rules, use the \"results\" property.\r\n     */\r\n    errors, \r\n    /**\r\n     * The controller's current array of validate results. This\r\n     * includes both passed rules and failed rules. For an array of only failed rules,\r\n     * use the \"errors\" property.\r\n     */\r\n    results, \r\n    /**\r\n     * The instruction passed to the \"validate\" or \"reset\" event. Will be null when\r\n     * the controller's validate/reset method was called with no instruction argument.\r\n     */\r\n    instruction, \r\n    /**\r\n     * In events with type === \"validate\", this property will contain the result\r\n     * of validating the instruction (see \"instruction\" property). Use the controllerValidateResult\r\n     * to access the validate results specific to the call to \"validate\"\r\n     * (as opposed to using the \"results\" and \"errors\" properties to access the controller's entire\r\n     * set of results/errors).\r\n     */\r\n    controllerValidateResult) {\r\n        this.type = type;\r\n        this.errors = errors;\r\n        this.results = results;\r\n        this.instruction = instruction;\r\n        this.controllerValidateResult = controllerValidateResult;\r\n    }\r\n    return ValidateEvent;\r\n}());\n\n/**\r\n * Orchestrates validation.\r\n * Manages a set of bindings, renderers and objects.\r\n * Exposes the current list of validation results for binding purposes.\r\n */\r\nvar ValidationController = /** @class */ (function () {\r\n    function ValidationController(validator, propertyParser) {\r\n        this.validator = validator;\r\n        this.propertyParser = propertyParser;\r\n        // Registered bindings (via the validate binding behavior)\r\n        this.bindings = new Map();\r\n        // Renderers that have been added to the controller instance.\r\n        this.renderers = [];\r\n        /**\r\n         * Validation results that have been rendered by the controller.\r\n         */\r\n        this.results = [];\r\n        /**\r\n         * Validation errors that have been rendered by the controller.\r\n         */\r\n        this.errors = [];\r\n        /**\r\n         *  Whether the controller is currently validating.\r\n         */\r\n        this.validating = false;\r\n        // Elements related to validation results that have been rendered.\r\n        this.elements = new Map();\r\n        // Objects that have been added to the controller instance (entity-style validation).\r\n        this.objects = new Map();\r\n        /**\r\n         * The trigger that will invoke automatic validation of a property used in a binding.\r\n         */\r\n        this.validateTrigger = validateTrigger.blur;\r\n        // Promise that resolves when validation has completed.\r\n        this.finishValidating = Promise.resolve();\r\n        this.eventCallbacks = [];\r\n    }\r\n    /**\r\n     * Subscribe to controller validate and reset events. These events occur when the\r\n     * controller's \"validate\"\" and \"reset\" methods are called.\r\n     * @param callback The callback to be invoked when the controller validates or resets.\r\n     */\r\n    ValidationController.prototype.subscribe = function (callback) {\r\n        var _this = this;\r\n        this.eventCallbacks.push(callback);\r\n        return {\r\n            dispose: function () {\r\n                var index = _this.eventCallbacks.indexOf(callback);\r\n                if (index === -1) {\r\n                    return;\r\n                }\r\n                _this.eventCallbacks.splice(index, 1);\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * Adds an object to the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.\r\n     */\r\n    ValidationController.prototype.addObject = function (object, rules) {\r\n        this.objects.set(object, rules);\r\n    };\r\n    /**\r\n     * Removes an object from the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     */\r\n    ValidationController.prototype.removeObject = function (object) {\r\n        this.objects.delete(object);\r\n        this.processResultDelta('reset', this.results.filter(function (result) { return result.object === object; }), []);\r\n    };\r\n    /**\r\n     * Adds and renders an error.\r\n     */\r\n    ValidationController.prototype.addError = function (message, object, propertyName) {\r\n        if (propertyName === void 0) { propertyName = null; }\r\n        var resolvedPropertyName;\r\n        if (propertyName === null) {\r\n            resolvedPropertyName = propertyName;\r\n        }\r\n        else {\r\n            resolvedPropertyName = this.propertyParser.parse(propertyName);\r\n        }\r\n        var result = new ValidateResult({ __manuallyAdded__: true }, object, resolvedPropertyName, false, message);\r\n        this.processResultDelta('validate', [], [result]);\r\n        return result;\r\n    };\r\n    /**\r\n     * Removes and unrenders an error.\r\n     */\r\n    ValidationController.prototype.removeError = function (result) {\r\n        if (this.results.indexOf(result) !== -1) {\r\n            this.processResultDelta('reset', [result], []);\r\n        }\r\n    };\r\n    /**\r\n     * Adds a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.addRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.push(renderer);\r\n        renderer.render({\r\n            kind: 'validate',\r\n            render: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); }),\r\n            unrender: []\r\n        });\r\n    };\r\n    /**\r\n     * Removes a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.removeRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.splice(this.renderers.indexOf(renderer), 1);\r\n        renderer.render({\r\n            kind: 'reset',\r\n            render: [],\r\n            unrender: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); })\r\n        });\r\n    };\r\n    /**\r\n     * Registers a binding with the controller.\r\n     * @param binding The binding instance.\r\n     * @param target The DOM element.\r\n     * @param rules (optional) rules associated with the binding. Validator implementation specific.\r\n     */\r\n    ValidationController.prototype.registerBinding = function (binding, target, rules) {\r\n        this.bindings.set(binding, { target: target, rules: rules, propertyInfo: null });\r\n    };\r\n    /**\r\n     * Unregisters a binding with the controller.\r\n     * @param binding The binding instance.\r\n     */\r\n    ValidationController.prototype.unregisterBinding = function (binding) {\r\n        this.resetBinding(binding);\r\n        this.bindings.delete(binding);\r\n    };\r\n    /**\r\n     * Interprets the instruction and returns a predicate that will identify\r\n     * relevant results in the list of rendered validation results.\r\n     */\r\n    ValidationController.prototype.getInstructionPredicate = function (instruction) {\r\n        var _this = this;\r\n        if (instruction) {\r\n            var object_1 = instruction.object, propertyName_1 = instruction.propertyName, rules_1 = instruction.rules;\r\n            var predicate_1;\r\n            if (instruction.propertyName) {\r\n                predicate_1 = function (x) { return x.object === object_1 && x.propertyName === propertyName_1; };\r\n            }\r\n            else {\r\n                predicate_1 = function (x) { return x.object === object_1; };\r\n            }\r\n            if (rules_1) {\r\n                return function (x) { return predicate_1(x) && _this.validator.ruleExists(rules_1, x.rule); };\r\n            }\r\n            return predicate_1;\r\n        }\r\n        else {\r\n            return function () { return true; };\r\n        }\r\n    };\r\n    /**\r\n     * Validates and renders results.\r\n     * @param instruction Optional. Instructions on what to validate. If undefined, all\r\n     * objects and bindings will be validated.\r\n     */\r\n    ValidationController.prototype.validate = function (instruction) {\r\n        var _this = this;\r\n        // Get a function that will process the validation instruction.\r\n        var execute;\r\n        if (instruction) {\r\n            // tslint:disable-next-line:prefer-const\r\n            var object_2 = instruction.object, propertyName_2 = instruction.propertyName, rules_2 = instruction.rules;\r\n            // if rules were not specified, check the object map.\r\n            rules_2 = rules_2 || this.objects.get(object_2);\r\n            // property specified?\r\n            if (instruction.propertyName === undefined) {\r\n                // validate the specified object.\r\n                execute = function () { return _this.validator.validateObject(object_2, rules_2); };\r\n            }\r\n            else {\r\n                // validate the specified property.\r\n                execute = function () { return _this.validator.validateProperty(object_2, propertyName_2, rules_2); };\r\n            }\r\n        }\r\n        else {\r\n            // validate all objects and bindings.\r\n            execute = function () {\r\n                var promises = [];\r\n                for (var _i = 0, _a = Array.from(_this.objects); _i < _a.length; _i++) {\r\n                    var _b = _a[_i], object = _b[0], rules = _b[1];\r\n                    promises.push(_this.validator.validateObject(object, rules));\r\n                }\r\n                for (var _c = 0, _d = Array.from(_this.bindings); _c < _d.length; _c++) {\r\n                    var _e = _d[_c], binding = _e[0], rules = _e[1].rules;\r\n                    var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n                    if (!propertyInfo || _this.objects.has(propertyInfo.object)) {\r\n                        continue;\r\n                    }\r\n                    promises.push(_this.validator.validateProperty(propertyInfo.object, propertyInfo.propertyName, rules));\r\n                }\r\n                return Promise.all(promises).then(function (resultSets) { return resultSets.reduce(function (a, b) { return a.concat(b); }, []); });\r\n            };\r\n        }\r\n        // Wait for any existing validation to finish, execute the instruction, render the results.\r\n        this.validating = true;\r\n        var returnPromise = this.finishValidating\r\n            .then(execute)\r\n            .then(function (newResults) {\r\n            var predicate = _this.getInstructionPredicate(instruction);\r\n            var oldResults = _this.results.filter(predicate);\r\n            _this.processResultDelta('validate', oldResults, newResults);\r\n            if (returnPromise === _this.finishValidating) {\r\n                _this.validating = false;\r\n            }\r\n            var result = {\r\n                instruction: instruction,\r\n                valid: newResults.find(function (x) { return !x.valid; }) === undefined,\r\n                results: newResults\r\n            };\r\n            _this.invokeCallbacks(instruction, result);\r\n            return result;\r\n        })\r\n            .catch(function (exception) {\r\n            // recover, to enable subsequent calls to validate()\r\n            _this.validating = false;\r\n            _this.finishValidating = Promise.resolve();\r\n            return Promise.reject(exception);\r\n        });\r\n        this.finishValidating = returnPromise;\r\n        return returnPromise;\r\n    };\r\n    /**\r\n     * Resets any rendered validation results (unrenders).\r\n     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered results\r\n     * will be unrendered.\r\n     */\r\n    ValidationController.prototype.reset = function (instruction) {\r\n        var predicate = this.getInstructionPredicate(instruction);\r\n        var oldResults = this.results.filter(predicate);\r\n        this.processResultDelta('reset', oldResults, []);\r\n        this.invokeCallbacks(instruction, null);\r\n    };\r\n    /**\r\n     * Gets the elements associated with an object and propertyName (if any).\r\n     */\r\n    ValidationController.prototype.getAssociatedElements = function (_a) {\r\n        var object = _a.object, propertyName = _a.propertyName;\r\n        var elements = [];\r\n        for (var _i = 0, _b = Array.from(this.bindings); _i < _b.length; _i++) {\r\n            var _c = _b[_i], binding = _c[0], target = _c[1].target;\r\n            var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n            if (propertyInfo && propertyInfo.object === object && propertyInfo.propertyName === propertyName) {\r\n                elements.push(target);\r\n            }\r\n        }\r\n        return elements;\r\n    };\r\n    ValidationController.prototype.processResultDelta = function (kind, oldResults, newResults) {\r\n        // prepare the instruction.\r\n        var instruction = {\r\n            kind: kind,\r\n            render: [],\r\n            unrender: []\r\n        };\r\n        // create a shallow copy of newResults so we can mutate it without causing side-effects.\r\n        newResults = newResults.slice(0);\r\n        var _loop_1 = function (oldResult) {\r\n            // get the elements associated with the old result.\r\n            var elements = this_1.elements.get(oldResult);\r\n            // remove the old result from the element map.\r\n            this_1.elements.delete(oldResult);\r\n            // create the unrender instruction.\r\n            instruction.unrender.push({ result: oldResult, elements: elements });\r\n            // determine if there's a corresponding new result for the old result we are unrendering.\r\n            var newResultIndex = newResults.findIndex(function (x) { return x.rule === oldResult.rule && x.object === oldResult.object && x.propertyName === oldResult.propertyName; });\r\n            if (newResultIndex === -1) {\r\n                // no corresponding new result... simple remove.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1);\r\n                if (!oldResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n            }\r\n            else {\r\n                // there is a corresponding new result...\r\n                var newResult = newResults.splice(newResultIndex, 1)[0];\r\n                // get the elements that are associated with the new result.\r\n                var elements_1 = this_1.getAssociatedElements(newResult);\r\n                this_1.elements.set(newResult, elements_1);\r\n                // create a render instruction for the new result.\r\n                instruction.render.push({ result: newResult, elements: elements_1 });\r\n                // do an in-place replacement of the old result with the new result.\r\n                // this ensures any repeats bound to this.results will not thrash.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1, newResult);\r\n                if (!oldResult.valid && newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n                else if (!oldResult.valid && !newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1, newResult);\r\n                }\r\n                else if (!newResult.valid) {\r\n                    this_1.errors.push(newResult);\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        // create unrender instructions from the old results.\r\n        for (var _i = 0, oldResults_1 = oldResults; _i < oldResults_1.length; _i++) {\r\n            var oldResult = oldResults_1[_i];\r\n            _loop_1(oldResult);\r\n        }\r\n        // create render instructions from the remaining new results.\r\n        for (var _a = 0, newResults_1 = newResults; _a < newResults_1.length; _a++) {\r\n            var result = newResults_1[_a];\r\n            var elements = this.getAssociatedElements(result);\r\n            instruction.render.push({ result: result, elements: elements });\r\n            this.elements.set(result, elements);\r\n            this.results.push(result);\r\n            if (!result.valid) {\r\n                this.errors.push(result);\r\n            }\r\n        }\r\n        // render.\r\n        for (var _b = 0, _c = this.renderers; _b < _c.length; _b++) {\r\n            var renderer = _c[_b];\r\n            renderer.render(instruction);\r\n        }\r\n    };\r\n    /**\r\n     * Validates the property associated with a binding.\r\n     */\r\n    ValidationController.prototype.validateBinding = function (binding) {\r\n        if (!binding.isBound) {\r\n            return;\r\n        }\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        var rules;\r\n        var registeredBinding = this.bindings.get(binding);\r\n        if (registeredBinding) {\r\n            rules = registeredBinding.rules;\r\n            registeredBinding.propertyInfo = propertyInfo;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n    };\r\n    /**\r\n     * Resets the results for a property associated with a binding.\r\n     */\r\n    ValidationController.prototype.resetBinding = function (binding) {\r\n        var registeredBinding = this.bindings.get(binding);\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        if (!propertyInfo && registeredBinding) {\r\n            propertyInfo = registeredBinding.propertyInfo;\r\n        }\r\n        if (registeredBinding) {\r\n            registeredBinding.propertyInfo = null;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.reset({ object: object, propertyName: propertyName });\r\n    };\r\n    /**\r\n     * Changes the controller's validateTrigger.\r\n     * @param newTrigger The new validateTrigger\r\n     */\r\n    ValidationController.prototype.changeTrigger = function (newTrigger) {\r\n        this.validateTrigger = newTrigger;\r\n        var bindings = Array.from(this.bindings.keys());\r\n        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {\r\n            var binding = bindings_1[_i];\r\n            var source = binding.source;\r\n            binding.unbind();\r\n            binding.bind(source);\r\n        }\r\n    };\r\n    /**\r\n     * Revalidates the controller's current set of errors.\r\n     */\r\n    ValidationController.prototype.revalidateErrors = function () {\r\n        for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {\r\n            var _b = _a[_i], object = _b.object, propertyName = _b.propertyName, rule = _b.rule;\r\n            if (rule.__manuallyAdded__) {\r\n                continue;\r\n            }\r\n            var rules = [[rule]];\r\n            this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n        }\r\n    };\r\n    ValidationController.prototype.invokeCallbacks = function (instruction, result) {\r\n        if (this.eventCallbacks.length === 0) {\r\n            return;\r\n        }\r\n        var event = new ValidateEvent(result ? 'validate' : 'reset', this.errors, this.results, instruction || null, result);\r\n        for (var i = 0; i < this.eventCallbacks.length; i++) {\r\n            this.eventCallbacks[i](event);\r\n        }\r\n    };\r\n    ValidationController.inject = [Validator, PropertyAccessorParser];\r\n    return ValidationController;\r\n}());\n\n/**\r\n * Binding behavior. Indicates the bound property should be validated.\r\n */\r\nvar ValidateBindingBehaviorBase = /** @class */ (function () {\r\n    function ValidateBindingBehaviorBase(taskQueue) {\r\n        this.taskQueue = taskQueue;\r\n    }\r\n    ValidateBindingBehaviorBase.prototype.bind = function (binding, source, rulesOrController, rules) {\r\n        var _this = this;\r\n        // identify the target element.\r\n        var target = getTargetDOMElement(binding, source);\r\n        // locate the controller.\r\n        var controller;\r\n        if (rulesOrController instanceof ValidationController) {\r\n            controller = rulesOrController;\r\n        }\r\n        else {\r\n            controller = source.container.get(aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"].of(ValidationController));\r\n            rules = rulesOrController;\r\n        }\r\n        if (controller === null) {\r\n            throw new Error(\"A ValidationController has not been registered.\");\r\n        }\r\n        controller.registerBinding(binding, target, rules);\r\n        binding.validationController = controller;\r\n        var trigger = this.getValidateTrigger(controller);\r\n        // tslint:disable-next-line:no-bitwise\r\n        if (trigger & validateTrigger.change) {\r\n            binding.vbbUpdateSource = binding.updateSource;\r\n            // tslint:disable-next-line:only-arrow-functions\r\n            // tslint:disable-next-line:space-before-function-paren\r\n            binding.updateSource = function (value) {\r\n                this.vbbUpdateSource(value);\r\n                this.validationController.validateBinding(this);\r\n            };\r\n        }\r\n        // tslint:disable-next-line:no-bitwise\r\n        if (trigger & validateTrigger.blur) {\r\n            binding.validateBlurHandler = function () {\r\n                _this.taskQueue.queueMicroTask(function () { return controller.validateBinding(binding); });\r\n            };\r\n            binding.validateTarget = target;\r\n            target.addEventListener('blur', binding.validateBlurHandler);\r\n        }\r\n        if (trigger !== validateTrigger.manual) {\r\n            binding.standardUpdateTarget = binding.updateTarget;\r\n            // tslint:disable-next-line:only-arrow-functions\r\n            // tslint:disable-next-line:space-before-function-paren\r\n            binding.updateTarget = function (value) {\r\n                this.standardUpdateTarget(value);\r\n                this.validationController.resetBinding(this);\r\n            };\r\n        }\r\n    };\r\n    ValidateBindingBehaviorBase.prototype.unbind = function (binding) {\r\n        // reset the binding to it's original state.\r\n        if (binding.vbbUpdateSource) {\r\n            binding.updateSource = binding.vbbUpdateSource;\r\n            binding.vbbUpdateSource = null;\r\n        }\r\n        if (binding.standardUpdateTarget) {\r\n            binding.updateTarget = binding.standardUpdateTarget;\r\n            binding.standardUpdateTarget = null;\r\n        }\r\n        if (binding.validateBlurHandler) {\r\n            binding.validateTarget.removeEventListener('blur', binding.validateBlurHandler);\r\n            binding.validateBlurHandler = null;\r\n            binding.validateTarget = null;\r\n        }\r\n        binding.validationController.unregisterBinding(binding);\r\n        binding.validationController = null;\r\n    };\r\n    return ValidateBindingBehaviorBase;\r\n}());\n\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the validate trigger specified by the associated controller's\r\n * validateTrigger property occurs.\r\n */\r\nvar ValidateBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateBindingBehavior, _super);\r\n    function ValidateBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateBindingBehavior.prototype.getValidateTrigger = function (controller) {\r\n        return controller.validateTrigger;\r\n    };\r\n    ValidateBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validate')\r\n    ], ValidateBindingBehavior);\r\n    return ValidateBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property will be validated\r\n * manually, by calling controller.validate(). No automatic validation\r\n * triggered by data-entry or blur will occur.\r\n */\r\nvar ValidateManuallyBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateManuallyBindingBehavior, _super);\r\n    function ValidateManuallyBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateManuallyBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.manual;\r\n    };\r\n    ValidateManuallyBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateManuallyBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateManually')\r\n    ], ValidateManuallyBindingBehavior);\r\n    return ValidateManuallyBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element blurs.\r\n */\r\nvar ValidateOnBlurBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnBlurBindingBehavior, _super);\r\n    function ValidateOnBlurBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnBlurBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.blur;\r\n    };\r\n    ValidateOnBlurBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnBlurBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnBlur')\r\n    ], ValidateOnBlurBindingBehavior);\r\n    return ValidateOnBlurBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element is changed by the user, causing a change\r\n * to the model.\r\n */\r\nvar ValidateOnChangeBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnChangeBindingBehavior, _super);\r\n    function ValidateOnChangeBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnChangeBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.change;\r\n    };\r\n    ValidateOnChangeBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnChangeBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnChange')\r\n    ], ValidateOnChangeBindingBehavior);\r\n    return ValidateOnChangeBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element blurs or is changed by the user, causing\r\n * a change to the model.\r\n */\r\nvar ValidateOnChangeOrBlurBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnChangeOrBlurBindingBehavior, _super);\r\n    function ValidateOnChangeOrBlurBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnChangeOrBlurBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.changeOrBlur;\r\n    };\r\n    ValidateOnChangeOrBlurBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnChangeOrBlurBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnChangeOrBlur')\r\n    ], ValidateOnChangeOrBlurBindingBehavior);\r\n    return ValidateOnChangeOrBlurBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\n\n/**\r\n * Creates ValidationController instances.\r\n */\r\nvar ValidationControllerFactory = /** @class */ (function () {\r\n    function ValidationControllerFactory(container) {\r\n        this.container = container;\r\n    }\r\n    ValidationControllerFactory.get = function (container) {\r\n        return new ValidationControllerFactory(container);\r\n    };\r\n    /**\r\n     * Creates a new controller instance.\r\n     */\r\n    ValidationControllerFactory.prototype.create = function (validator) {\r\n        if (!validator) {\r\n            validator = this.container.get(Validator);\r\n        }\r\n        var propertyParser = this.container.get(PropertyAccessorParser);\r\n        return new ValidationController(validator, propertyParser);\r\n    };\r\n    /**\r\n     * Creates a new controller and registers it in the current element's container so that it's\r\n     * available to the validate binding behavior and renderers.\r\n     */\r\n    ValidationControllerFactory.prototype.createForCurrentScope = function (validator) {\r\n        var controller = this.create(validator);\r\n        this.container.registerInstance(ValidationController, controller);\r\n        return controller;\r\n    };\r\n    return ValidationControllerFactory;\r\n}());\r\nValidationControllerFactory['protocol:aurelia:resolver'] = true;\n\nvar ValidationErrorsCustomAttribute = /** @class */ (function () {\r\n    function ValidationErrorsCustomAttribute(boundaryElement, controllerAccessor) {\r\n        this.boundaryElement = boundaryElement;\r\n        this.controllerAccessor = controllerAccessor;\r\n        this.controller = null;\r\n        this.errors = [];\r\n        this.errorsInternal = [];\r\n    }\r\n    ValidationErrorsCustomAttribute.inject = function () {\r\n        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"DOM\"].Element, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Lazy\"].of(ValidationController)];\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.sort = function () {\r\n        this.errorsInternal.sort(function (a, b) {\r\n            if (a.targets[0] === b.targets[0]) {\r\n                return 0;\r\n            }\r\n            // tslint:disable-next-line:no-bitwise\r\n            return a.targets[0].compareDocumentPosition(b.targets[0]) & 2 ? 1 : -1;\r\n        });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.interestingElements = function (elements) {\r\n        var _this = this;\r\n        return elements.filter(function (e) { return _this.boundaryElement.contains(e); });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.render = function (instruction) {\r\n        var _loop_1 = function (result) {\r\n            var index = this_1.errorsInternal.findIndex(function (x) { return x.error === result; });\r\n            if (index !== -1) {\r\n                this_1.errorsInternal.splice(index, 1);\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, _a = instruction.unrender; _i < _a.length; _i++) {\r\n            var result = _a[_i].result;\r\n            _loop_1(result);\r\n        }\r\n        for (var _b = 0, _c = instruction.render; _b < _c.length; _b++) {\r\n            var _d = _c[_b], result = _d.result, elements = _d.elements;\r\n            if (result.valid) {\r\n                continue;\r\n            }\r\n            var targets = this.interestingElements(elements);\r\n            if (targets.length) {\r\n                this.errorsInternal.push({ error: result, targets: targets });\r\n            }\r\n        }\r\n        this.sort();\r\n        this.errors = this.errorsInternal;\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.bind = function () {\r\n        if (!this.controller) {\r\n            this.controller = this.controllerAccessor();\r\n        }\r\n        // this will call render() with the side-effect of updating this.errors\r\n        this.controller.addRenderer(this);\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.unbind = function () {\r\n        if (this.controller) {\r\n            this.controller.removeRenderer(this);\r\n        }\r\n    };\r\n    __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"bindable\"])({ defaultBindingMode: aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingMode\"].oneWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"controller\", void 0);\r\n    __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"bindable\"])({ primaryProperty: true, defaultBindingMode: aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingMode\"].twoWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"errors\", void 0);\r\n    ValidationErrorsCustomAttribute = __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"customAttribute\"])('validation-errors')\r\n    ], ValidationErrorsCustomAttribute);\r\n    return ValidationErrorsCustomAttribute;\r\n}());\n\nvar ValidationRendererCustomAttribute = /** @class */ (function () {\r\n    function ValidationRendererCustomAttribute() {\r\n    }\r\n    ValidationRendererCustomAttribute.prototype.created = function (view) {\r\n        this.container = view.container;\r\n    };\r\n    ValidationRendererCustomAttribute.prototype.bind = function () {\r\n        this.controller = this.container.get(ValidationController);\r\n        this.renderer = this.container.get(this.value);\r\n        this.controller.addRenderer(this.renderer);\r\n    };\r\n    ValidationRendererCustomAttribute.prototype.unbind = function () {\r\n        this.controller.removeRenderer(this.renderer);\r\n        this.controller = null;\r\n        this.renderer = null;\r\n    };\r\n    ValidationRendererCustomAttribute = __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"customAttribute\"])('validation-renderer')\r\n    ], ValidationRendererCustomAttribute);\r\n    return ValidationRendererCustomAttribute;\r\n}());\n\n/**\r\n * Sets, unsets and retrieves rules on an object or constructor function.\r\n */\r\nvar Rules = /** @class */ (function () {\r\n    function Rules() {\r\n    }\r\n    /**\r\n     * Applies the rules to a target.\r\n     */\r\n    Rules.set = function (target, rules) {\r\n        if (target instanceof Function) {\r\n            target = target.prototype;\r\n        }\r\n        Object.defineProperty(target, Rules.key, { enumerable: false, configurable: false, writable: true, value: rules });\r\n    };\r\n    /**\r\n     * Removes rules from a target.\r\n     */\r\n    Rules.unset = function (target) {\r\n        if (target instanceof Function) {\r\n            target = target.prototype;\r\n        }\r\n        target[Rules.key] = null;\r\n    };\r\n    /**\r\n     * Retrieves the target's rules.\r\n     */\r\n    Rules.get = function (target) {\r\n        return target[Rules.key] || null;\r\n    };\r\n    /**\r\n     * The name of the property that stores the rules.\r\n     */\r\n    Rules.key = '__rules__';\r\n    return Rules;\r\n}());\n\n// tslint:disable:no-empty\r\nvar ExpressionVisitor = /** @class */ (function () {\r\n    function ExpressionVisitor() {\r\n    }\r\n    ExpressionVisitor.prototype.visitChain = function (chain) {\r\n        this.visitArgs(chain.expressions);\r\n    };\r\n    ExpressionVisitor.prototype.visitBindingBehavior = function (behavior) {\r\n        behavior.expression.accept(this);\r\n        this.visitArgs(behavior.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitValueConverter = function (converter) {\r\n        converter.expression.accept(this);\r\n        this.visitArgs(converter.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitAssign = function (assign) {\r\n        assign.target.accept(this);\r\n        assign.value.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitConditional = function (conditional) {\r\n        conditional.condition.accept(this);\r\n        conditional.yes.accept(this);\r\n        conditional.no.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessThis = function (access) {\r\n        access.ancestor = access.ancestor;\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessScope = function (access) {\r\n        access.name = access.name;\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessMember = function (access) {\r\n        access.object.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessKeyed = function (access) {\r\n        access.object.accept(this);\r\n        access.key.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallScope = function (call) {\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallFunction = function (call) {\r\n        call.func.accept(this);\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallMember = function (call) {\r\n        call.object.accept(this);\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitPrefix = function (prefix) {\r\n        prefix.expression.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitBinary = function (binary) {\r\n        binary.left.accept(this);\r\n        binary.right.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralPrimitive = function (literal) {\r\n        literal.value = literal.value;\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralArray = function (literal) {\r\n        this.visitArgs(literal.elements);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralObject = function (literal) {\r\n        this.visitArgs(literal.values);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralString = function (literal) {\r\n        literal.value = literal.value;\r\n    };\r\n    ExpressionVisitor.prototype.visitArgs = function (args) {\r\n        for (var i = 0; i < args.length; i++) {\r\n            args[i].accept(this);\r\n        }\r\n    };\r\n    return ExpressionVisitor;\r\n}());\n\nvar ValidationMessageParser = /** @class */ (function () {\r\n    function ValidationMessageParser(bindinqLanguage) {\r\n        this.bindinqLanguage = bindinqLanguage;\r\n        this.emptyStringExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"]('');\r\n        this.nullExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralPrimitive\"](null);\r\n        this.undefinedExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralPrimitive\"](undefined);\r\n        this.cache = {};\r\n    }\r\n    ValidationMessageParser.prototype.parse = function (message) {\r\n        if (this.cache[message] !== undefined) {\r\n            return this.cache[message];\r\n        }\r\n        var parts = this.bindinqLanguage.parseInterpolation(null, message);\r\n        if (parts === null) {\r\n            return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](message);\r\n        }\r\n        var expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](parts[0]);\r\n        for (var i = 1; i < parts.length; i += 2) {\r\n            expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('+', expression, new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('+', this.coalesce(parts[i]), new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](parts[i + 1])));\r\n        }\r\n        MessageExpressionValidator.validate(expression, message);\r\n        this.cache[message] = expression;\r\n        return expression;\r\n    };\r\n    ValidationMessageParser.prototype.coalesce = function (part) {\r\n        // part === null || part === undefined ? '' : part\r\n        return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Conditional\"](new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('||', new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('===', part, this.nullExpression), new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('===', part, this.undefinedExpression)), this.emptyStringExpression, new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"CallMember\"](part, 'toString', []));\r\n    };\r\n    ValidationMessageParser.inject = [aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"BindingLanguage\"]];\r\n    return ValidationMessageParser;\r\n}());\r\nvar MessageExpressionValidator = /** @class */ (function (_super) {\r\n    __extends(MessageExpressionValidator, _super);\r\n    function MessageExpressionValidator(originalMessage) {\r\n        var _this = _super.call(this) || this;\r\n        _this.originalMessage = originalMessage;\r\n        return _this;\r\n    }\r\n    MessageExpressionValidator.validate = function (expression, originalMessage) {\r\n        var visitor = new MessageExpressionValidator(originalMessage);\r\n        expression.accept(visitor);\r\n    };\r\n    MessageExpressionValidator.prototype.visitAccessScope = function (access) {\r\n        if (access.ancestor !== 0) {\r\n            throw new Error('$parent is not permitted in validation message expressions.');\r\n        }\r\n        if (['displayName', 'propertyName', 'value', 'object', 'config', 'getDisplayName'].indexOf(access.name) !== -1) {\r\n            Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_5__[\"getLogger\"])('aurelia-validation')\r\n                // tslint:disable-next-line:max-line-length\r\n                .warn(\"Did you mean to use \\\"$\" + access.name + \"\\\" instead of \\\"\" + access.name + \"\\\" in this validation message template: \\\"\" + this.originalMessage + \"\\\"?\");\r\n        }\r\n    };\r\n    return MessageExpressionValidator;\r\n}(ExpressionVisitor));\n\n/**\r\n * Dictionary of validation messages. [messageKey]: messageExpression\r\n */\r\nvar validationMessages = {\r\n    /**\r\n     * The default validation message. Used with rules that have no standard message.\r\n     */\r\n    default: \"${$displayName} is invalid.\",\r\n    required: \"${$displayName} is required.\",\r\n    matches: \"${$displayName} is not correctly formatted.\",\r\n    email: \"${$displayName} is not a valid email.\",\r\n    minLength: \"${$displayName} must be at least ${$config.length} character${$config.length === 1 ? '' : 's'}.\",\r\n    maxLength: \"${$displayName} cannot be longer than ${$config.length} character${$config.length === 1 ? '' : 's'}.\",\r\n    minItems: \"${$displayName} must contain at least ${$config.count} item${$config.count === 1 ? '' : 's'}.\",\r\n    maxItems: \"${$displayName} cannot contain more than ${$config.count} item${$config.count === 1 ? '' : 's'}.\",\r\n    min: \"${$displayName} must be at least ${$config.constraint}.\",\r\n    max: \"${$displayName} must be at most ${$config.constraint}.\",\r\n    range: \"${$displayName} must be between or equal to ${$config.min} and ${$config.max}.\",\r\n    between: \"${$displayName} must be between but not equal to ${$config.min} and ${$config.max}.\",\r\n    equals: \"${$displayName} must be ${$config.expectedValue}.\",\r\n};\r\n/**\r\n * Retrieves validation messages and property display names.\r\n */\r\nvar ValidationMessageProvider = /** @class */ (function () {\r\n    function ValidationMessageProvider(parser) {\r\n        this.parser = parser;\r\n    }\r\n    /**\r\n     * Returns a message binding expression that corresponds to the key.\r\n     * @param key The message key.\r\n     */\r\n    ValidationMessageProvider.prototype.getMessage = function (key) {\r\n        var message;\r\n        if (key in validationMessages) {\r\n            message = validationMessages[key];\r\n        }\r\n        else {\r\n            message = validationMessages['default'];\r\n        }\r\n        return this.parser.parse(message);\r\n    };\r\n    /**\r\n     * Formulates a property display name using the property name and the configured\r\n     * displayName (if provided).\r\n     * Override this with your own custom logic.\r\n     * @param propertyName The property name.\r\n     */\r\n    ValidationMessageProvider.prototype.getDisplayName = function (propertyName, displayName) {\r\n        if (displayName !== null && displayName !== undefined) {\r\n            return (displayName instanceof Function) ? displayName() : displayName;\r\n        }\r\n        // split on upper-case letters.\r\n        var words = propertyName.toString().split(/(?=[A-Z])/).join(' ');\r\n        // capitalize first letter.\r\n        return words.charAt(0).toUpperCase() + words.slice(1);\r\n    };\r\n    ValidationMessageProvider.inject = [ValidationMessageParser];\r\n    return ValidationMessageProvider;\r\n}());\n\n/**\r\n * Validates.\r\n * Responsible for validating objects and properties.\r\n */\r\nvar StandardValidator = /** @class */ (function (_super) {\r\n    __extends(StandardValidator, _super);\r\n    function StandardValidator(messageProvider, resources) {\r\n        var _this = _super.call(this) || this;\r\n        _this.messageProvider = messageProvider;\r\n        _this.lookupFunctions = resources.lookupFunctions;\r\n        _this.getDisplayName = messageProvider.getDisplayName.bind(messageProvider);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Validates the specified property.\r\n     * @param object The object to validate.\r\n     * @param propertyName The name of the property to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    StandardValidator.prototype.validateProperty = function (object, propertyName, rules) {\r\n        return this.validate(object, propertyName, rules || null);\r\n    };\r\n    /**\r\n     * Validates all rules for specified object and it's properties.\r\n     * @param object The object to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    StandardValidator.prototype.validateObject = function (object, rules) {\r\n        return this.validate(object, null, rules || null);\r\n    };\r\n    /**\r\n     * Determines whether a rule exists in a set of rules.\r\n     * @param rules The rules to search.\r\n     * @parem rule The rule to find.\r\n     */\r\n    StandardValidator.prototype.ruleExists = function (rules, rule) {\r\n        var i = rules.length;\r\n        while (i--) {\r\n            if (rules[i].indexOf(rule) !== -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    StandardValidator.prototype.getMessage = function (rule, object, value) {\r\n        var expression = rule.message || this.messageProvider.getMessage(rule.messageKey);\r\n        // tslint:disable-next-line:prefer-const\r\n        var _a = rule.property, propertyName = _a.name, displayName = _a.displayName;\r\n        if (propertyName !== null) {\r\n            displayName = this.messageProvider.getDisplayName(propertyName, displayName);\r\n        }\r\n        var overrideContext = {\r\n            $displayName: displayName,\r\n            $propertyName: propertyName,\r\n            $value: value,\r\n            $object: object,\r\n            $config: rule.config,\r\n            // returns the name of a given property, given just the property name (irrespective of the property's displayName)\r\n            // split on capital letters, first letter ensured to be capitalized\r\n            $getDisplayName: this.getDisplayName\r\n        };\r\n        return expression.evaluate({ bindingContext: object, overrideContext: overrideContext }, this.lookupFunctions);\r\n    };\r\n    StandardValidator.prototype.validateRuleSequence = function (object, propertyName, ruleSequence, sequence, results) {\r\n        var _this = this;\r\n        // are we validating all properties or a single property?\r\n        var validateAllProperties = propertyName === null || propertyName === undefined;\r\n        var rules = ruleSequence[sequence];\r\n        var allValid = true;\r\n        // validate each rule.\r\n        var promises = [];\r\n        var _loop_1 = function (i) {\r\n            var rule = rules[i];\r\n            // is the rule related to the property we're validating.\r\n            // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n            if (!validateAllProperties && rule.property.name != propertyName) {\r\n                return \"continue\";\r\n            }\r\n            // is this a conditional rule? is the condition met?\r\n            if (rule.when && !rule.when(object)) {\r\n                return \"continue\";\r\n            }\r\n            // validate.\r\n            var value = rule.property.name === null ? object : object[rule.property.name];\r\n            var promiseOrBoolean = rule.condition(value, object);\r\n            if (!(promiseOrBoolean instanceof Promise)) {\r\n                promiseOrBoolean = Promise.resolve(promiseOrBoolean);\r\n            }\r\n            promises.push(promiseOrBoolean.then(function (valid) {\r\n                var message = valid ? null : _this.getMessage(rule, object, value);\r\n                results.push(new ValidateResult(rule, object, rule.property.name, valid, message));\r\n                allValid = allValid && valid;\r\n                return valid;\r\n            }));\r\n        };\r\n        for (var i = 0; i < rules.length; i++) {\r\n            _loop_1(i);\r\n        }\r\n        return Promise.all(promises)\r\n            .then(function () {\r\n            sequence++;\r\n            if (allValid && sequence < ruleSequence.length) {\r\n                return _this.validateRuleSequence(object, propertyName, ruleSequence, sequence, results);\r\n            }\r\n            return results;\r\n        });\r\n    };\r\n    StandardValidator.prototype.validate = function (object, propertyName, rules) {\r\n        // rules specified?\r\n        if (!rules) {\r\n            // no. attempt to locate the rules.\r\n            rules = Rules.get(object);\r\n        }\r\n        // any rules?\r\n        if (!rules || rules.length === 0) {\r\n            return Promise.resolve([]);\r\n        }\r\n        return this.validateRuleSequence(object, propertyName, rules, 0, []);\r\n    };\r\n    StandardValidator.inject = [ValidationMessageProvider, aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"ViewResources\"]];\r\n    return StandardValidator;\r\n}(Validator));\n\n/**\r\n * Part of the fluent rule API. Enables customizing property rules.\r\n */\r\nvar FluentRuleCustomizer = /** @class */ (function () {\r\n    function FluentRuleCustomizer(property, condition, config, fluentEnsure, fluentRules, parsers) {\r\n        if (config === void 0) { config = {}; }\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.fluentRules = fluentRules;\r\n        this.parsers = parsers;\r\n        this.rule = {\r\n            property: property,\r\n            condition: condition,\r\n            config: config,\r\n            when: null,\r\n            messageKey: 'default',\r\n            message: null,\r\n            sequence: fluentRules.sequence\r\n        };\r\n        this.fluentEnsure._addRule(this.rule);\r\n    }\r\n    /**\r\n     * Validate subsequent rules after previously declared rules have\r\n     * been validated successfully. Use to postpone validation of costly\r\n     * rules until less expensive rules pass validation.\r\n     */\r\n    FluentRuleCustomizer.prototype.then = function () {\r\n        this.fluentRules.sequence++;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies the key to use when looking up the rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessageKey = function (key) {\r\n        this.rule.messageKey = key;\r\n        this.rule.message = null;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessage = function (message) {\r\n        this.rule.messageKey = 'custom';\r\n        this.rule.message = this.parsers.message.parse(message);\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies a condition that must be met before attempting to validate the rule.\r\n     * @param condition A function that accepts the object as a parameter and returns true\r\n     * or false whether the rule should be evaluated.\r\n     */\r\n    FluentRuleCustomizer.prototype.when = function (condition) {\r\n        this.rule.when = condition;\r\n        return this;\r\n    };\r\n    /**\r\n     * Tags the rule instance, enabling the rule to be found easily\r\n     * using ValidationRules.taggedRules(rules, tag)\r\n     */\r\n    FluentRuleCustomizer.prototype.tag = function (tag) {\r\n        this.rule.tag = tag;\r\n        return this;\r\n    };\r\n    ///// FluentEnsure APIs /////\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensure = function (subject) {\r\n        return this.fluentEnsure.ensure(subject);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensureObject = function () {\r\n        return this.fluentEnsure.ensureObject();\r\n    };\r\n    Object.defineProperty(FluentRuleCustomizer.prototype, \"rules\", {\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        get: function () {\r\n            return this.fluentEnsure.rules;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentRuleCustomizer.prototype.on = function (target) {\r\n        return this.fluentEnsure.on(target);\r\n    };\r\n    ///////// FluentRules APIs /////////\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfies = function (condition, config) {\r\n        return this.fluentRules.satisfies(condition, config);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfiesRule = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a;\r\n        return (_a = this.fluentRules).satisfiesRule.apply(_a, [name].concat(args));\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRuleCustomizer.prototype.required = function () {\r\n        return this.fluentRules.required();\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.matches = function (regex) {\r\n        return this.fluentRules.matches(regex);\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.email = function () {\r\n        return this.fluentRules.email();\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minLength = function (length) {\r\n        return this.fluentRules.minLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxLength = function (length) {\r\n        return this.fluentRules.maxLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minItems = function (count) {\r\n        return this.fluentRules.minItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxItems = function (count) {\r\n        return this.fluentRules.maxItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"min\" NUMBER validation rule to the property.\r\n     * Value must be greater than or equal to the specified constraint.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.min = function (value) {\r\n        return this.fluentRules.min(value);\r\n    };\r\n    /**\r\n     * Applies the \"max\" NUMBER validation rule to the property.\r\n     * Value must be less than or equal to the specified constraint.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.max = function (value) {\r\n        return this.fluentRules.max(value);\r\n    };\r\n    /**\r\n     * Applies the \"range\" NUMBER validation rule to the property.\r\n     * Value must be between or equal to the specified min and max.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.range = function (min, max) {\r\n        return this.fluentRules.range(min, max);\r\n    };\r\n    /**\r\n     * Applies the \"between\" NUMBER validation rule to the property.\r\n     * Value must be between but not equal to the specified min and max.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.between = function (min, max) {\r\n        return this.fluentRules.between(min, max);\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.equals = function (expectedValue) {\r\n        return this.fluentRules.equals(expectedValue);\r\n    };\r\n    return FluentRuleCustomizer;\r\n}());\r\n/**\r\n * Part of the fluent rule API. Enables applying rules to properties and objects.\r\n */\r\nvar FluentRules = /** @class */ (function () {\r\n    function FluentRules(fluentEnsure, parsers, property) {\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.parsers = parsers;\r\n        this.property = property;\r\n        /**\r\n         * Current rule sequence number. Used to postpone evaluation of rules until rules\r\n         * with lower sequence number have successfully validated. The \"then\" fluent API method\r\n         * manages this property, there's usually no need to set it directly.\r\n         */\r\n        this.sequence = 0;\r\n    }\r\n    /**\r\n     * Sets the display name of the ensured property.\r\n     */\r\n    FluentRules.prototype.displayName = function (name) {\r\n        this.property.displayName = name;\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRules.prototype.satisfies = function (condition, config) {\r\n        return new FluentRuleCustomizer(this.property, condition, config, this.fluentEnsure, this, this.parsers);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRules.prototype.satisfiesRule = function (name) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var rule = FluentRules.customRules[name];\r\n        if (!rule) {\r\n            // standard rule?\r\n            rule = this[name];\r\n            if (rule instanceof Function) {\r\n                return rule.call.apply(rule, [this].concat(args));\r\n            }\r\n            throw new Error(\"Rule with name \\\"\" + name + \"\\\" does not exist.\");\r\n        }\r\n        var config = rule.argsToConfig ? rule.argsToConfig.apply(rule, args) : undefined;\r\n        return this.satisfies(function (value, obj) {\r\n            var _a;\r\n            return (_a = rule.condition).call.apply(_a, [_this, value, obj].concat(args));\r\n        }, config)\r\n            .withMessageKey(name);\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRules.prototype.required = function () {\r\n        return this.satisfies(function (value) {\r\n            return value !== null\r\n                && value !== undefined\r\n                && !(isString(value) && !/\\S/.test(value));\r\n        }).withMessageKey('required');\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.matches = function (regex) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || regex.test(value); })\r\n            .withMessageKey('matches');\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.email = function () {\r\n        // regex from https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\r\n        /* tslint:disable:max-line-length */\r\n        return this.matches(/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/)\r\n            /* tslint:enable:max-line-length */\r\n            .withMessageKey('email');\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.minLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length >= length; }, { length: length })\r\n            .withMessageKey('minLength');\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length <= length; }, { length: length })\r\n            .withMessageKey('maxLength');\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.minItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length >= count; }, { count: count })\r\n            .withMessageKey('minItems');\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length <= count; }, { count: count })\r\n            .withMessageKey('maxItems');\r\n    };\r\n    /**\r\n     * Applies the \"min\" NUMBER validation rule to the property.\r\n     * Value must be greater than or equal to the specified constraint.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.min = function (constraint) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value >= constraint; }, { constraint: constraint })\r\n            .withMessageKey('min');\r\n    };\r\n    /**\r\n     * Applies the \"max\" NUMBER validation rule to the property.\r\n     * Value must be less than or equal to the specified constraint.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.max = function (constraint) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value <= constraint; }, { constraint: constraint })\r\n            .withMessageKey('max');\r\n    };\r\n    /**\r\n     * Applies the \"range\" NUMBER validation rule to the property.\r\n     * Value must be between or equal to the specified min and max.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.range = function (min, max) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || (value >= min && value <= max); }, { min: min, max: max })\r\n            .withMessageKey('range');\r\n    };\r\n    /**\r\n     * Applies the \"between\" NUMBER validation rule to the property.\r\n     * Value must be between but not equal to the specified min and max.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.between = function (min, max) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || (value > min && value < max); }, { min: min, max: max })\r\n            .withMessageKey('between');\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.equals = function (expectedValue) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value === '' || value === expectedValue; }, { expectedValue: expectedValue })\r\n            .withMessageKey('equals');\r\n    };\r\n    FluentRules.customRules = {};\r\n    return FluentRules;\r\n}());\r\n/**\r\n * Part of the fluent rule API. Enables targeting properties and objects with rules.\r\n */\r\nvar FluentEnsure = /** @class */ (function () {\r\n    function FluentEnsure(parsers) {\r\n        this.parsers = parsers;\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        this.rules = [];\r\n    }\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor\r\n     * function.\r\n     */\r\n    FluentEnsure.prototype.ensure = function (property) {\r\n        this.assertInitialized();\r\n        var name = this.parsers.property.parse(property);\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: name, displayName: null });\r\n        return this.mergeRules(fluentRules, name);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentEnsure.prototype.ensureObject = function () {\r\n        this.assertInitialized();\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: null, displayName: null });\r\n        return this.mergeRules(fluentRules, null);\r\n    };\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentEnsure.prototype.on = function (target) {\r\n        Rules.set(target, this.rules);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a rule definition to the sequenced ruleset.\r\n     * @internal\r\n     */\r\n    FluentEnsure.prototype._addRule = function (rule) {\r\n        while (this.rules.length < rule.sequence + 1) {\r\n            this.rules.push([]);\r\n        }\r\n        this.rules[rule.sequence].push(rule);\r\n    };\r\n    FluentEnsure.prototype.assertInitialized = function () {\r\n        if (this.parsers) {\r\n            return;\r\n        }\r\n        throw new Error(\"Did you forget to add \\\".plugin('aurelia-validation')\\\" to your main.js?\");\r\n    };\r\n    FluentEnsure.prototype.mergeRules = function (fluentRules, propertyName) {\r\n        // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n        var existingRules = this.rules.find(function (r) { return r.length > 0 && r[0].property.name == propertyName; });\r\n        if (existingRules) {\r\n            var rule = existingRules[existingRules.length - 1];\r\n            fluentRules.sequence = rule.sequence;\r\n            if (rule.property.displayName !== null) {\r\n                fluentRules = fluentRules.displayName(rule.property.displayName);\r\n            }\r\n        }\r\n        return fluentRules;\r\n    };\r\n    return FluentEnsure;\r\n}());\r\n/**\r\n * Fluent rule definition API.\r\n */\r\nvar ValidationRules = /** @class */ (function () {\r\n    function ValidationRules() {\r\n    }\r\n    ValidationRules.initialize = function (messageParser, propertyParser) {\r\n        this.parsers = {\r\n            message: messageParser,\r\n            property: propertyParser\r\n        };\r\n    };\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    ValidationRules.ensure = function (property) {\r\n        return new FluentEnsure(ValidationRules.parsers).ensure(property);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    ValidationRules.ensureObject = function () {\r\n        return new FluentEnsure(ValidationRules.parsers).ensureObject();\r\n    };\r\n    /**\r\n     * Defines a custom rule.\r\n     * @param name The name of the custom rule. Also serves as the message key.\r\n     * @param condition The rule function.\r\n     * @param message The message expression\r\n     * @param argsToConfig A function that maps the rule's arguments to a \"config\"\r\n     * object that can be used when evaluating the message expression.\r\n     */\r\n    ValidationRules.customRule = function (name, condition, message, argsToConfig) {\r\n        validationMessages[name] = message;\r\n        FluentRules.customRules[name] = { condition: condition, argsToConfig: argsToConfig };\r\n    };\r\n    /**\r\n     * Returns rules with the matching tag.\r\n     * @param rules The rules to search.\r\n     * @param tag The tag to search for.\r\n     */\r\n    ValidationRules.taggedRules = function (rules, tag) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === tag; }); });\r\n    };\r\n    /**\r\n     * Returns rules that have no tag.\r\n     * @param rules The rules to search.\r\n     */\r\n    ValidationRules.untaggedRules = function (rules) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === undefined; }); });\r\n    };\r\n    /**\r\n     * Removes the rules from a class or object.\r\n     * @param target A class or object.\r\n     */\r\n    ValidationRules.off = function (target) {\r\n        Rules.unset(target);\r\n    };\r\n    return ValidationRules;\r\n}());\n\n// Exports\r\n/**\r\n * Aurelia Validation Configuration API\r\n */\r\nvar AureliaValidationConfiguration = /** @class */ (function () {\r\n    function AureliaValidationConfiguration() {\r\n        this.validatorType = StandardValidator;\r\n    }\r\n    /**\r\n     * Use a custom Validator implementation.\r\n     */\r\n    AureliaValidationConfiguration.prototype.customValidator = function (type) {\r\n        this.validatorType = type;\r\n    };\r\n    /**\r\n     * Applies the configuration.\r\n     */\r\n    AureliaValidationConfiguration.prototype.apply = function (container) {\r\n        var validator = container.get(this.validatorType);\r\n        container.registerInstance(Validator, validator);\r\n    };\r\n    return AureliaValidationConfiguration;\r\n}());\r\n/**\r\n * Configures the plugin.\r\n */\r\nfunction configure(\r\n// tslint:disable-next-line:ban-types\r\nframeworkConfig, callback) {\r\n    // the fluent rule definition API needs the parser to translate messages\r\n    // to interpolation expressions.\r\n    var messageParser = frameworkConfig.container.get(ValidationMessageParser);\r\n    var propertyParser = frameworkConfig.container.get(PropertyAccessorParser);\r\n    ValidationRules.initialize(messageParser, propertyParser);\r\n    // configure...\r\n    var config = new AureliaValidationConfiguration();\r\n    if (callback instanceof Function) {\r\n        callback(config);\r\n    }\r\n    config.apply(frameworkConfig.container);\r\n    // globalize the behaviors.\r\n    if (frameworkConfig.globalResources) {\r\n        frameworkConfig.globalResources(ValidateBindingBehavior, ValidateManuallyBindingBehavior, ValidateOnBlurBindingBehavior, ValidateOnChangeBindingBehavior, ValidateOnChangeOrBlurBindingBehavior, ValidationErrorsCustomAttribute, ValidationRendererCustomAttribute);\r\n    }\r\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! promise-polyfill */ \"B/eG\")[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS12YWxpZGF0aW9uLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtdmFsaWRhdGlvbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtdmFsaWRhdGlvbi5qcz9mMGQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTSB9IGZyb20gJ2F1cmVsaWEtcGFsJztcbmltcG9ydCB7IEFjY2Vzc01lbWJlciwgQWNjZXNzU2NvcGUsIEFjY2Vzc0tleWVkLCBCaW5kaW5nQmVoYXZpb3IsIFZhbHVlQ29udmVydGVyLCBnZXRDb250ZXh0Rm9yLCBQYXJzZXIsIGJpbmRpbmdCZWhhdmlvciwgYmluZGluZ01vZGUsIExpdGVyYWxTdHJpbmcsIEJpbmFyeSwgQ29uZGl0aW9uYWwsIExpdGVyYWxQcmltaXRpdmUsIENhbGxNZW1iZXIgfSBmcm9tICdhdXJlbGlhLWJpbmRpbmcnO1xuaW1wb3J0IHsgT3B0aW9uYWwsIExhenkgfSBmcm9tICdhdXJlbGlhLWRlcGVuZGVuY3ktaW5qZWN0aW9uJztcbmltcG9ydCB7IFRhc2tRdWV1ZSB9IGZyb20gJ2F1cmVsaWEtdGFzay1xdWV1ZSc7XG5pbXBvcnQgeyBjdXN0b21BdHRyaWJ1dGUsIGJpbmRhYmxlLCBCaW5kaW5nTGFuZ3VhZ2UsIFZpZXdSZXNvdXJjZXMgfSBmcm9tICdhdXJlbGlhLXRlbXBsYXRpbmcnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnYXVyZWxpYS1sb2dnaW5nJztcblxuLyoqXHJcbiAqIEdldHMgdGhlIERPTSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZGF0YS1iaW5kaW5nLiBNb3N0IG9mIHRoZSB0aW1lIGl0J3NcclxuICogdGhlIGJpbmRpbmcudGFyZ2V0IGJ1dCBzb21ldGltZXMgYmluZGluZy50YXJnZXQgaXMgYW4gYXVyZWxpYSBjdXN0b20gZWxlbWVudCxcclxuICogb3IgY3VzdG9tIGF0dHJpYnV0ZSB3aGljaCBpcyBhIGphdmFzY3JpcHQgXCJjbGFzc1wiIGluc3RhbmNlLCBzbyB3ZSBuZWVkIHRvIHVzZVxyXG4gKiB0aGUgY29udHJvbGxlcidzIGNvbnRhaW5lciB0byByZXRyaWV2ZSB0aGUgYWN0dWFsIERPTSBlbGVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0RE9NRWxlbWVudChiaW5kaW5nLCB2aWV3KSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gYmluZGluZy50YXJnZXQ7XHJcbiAgICAvLyBET00gZWxlbWVudFxyXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIGVsZW1lbnQgb3IgY3VzdG9tIGF0dHJpYnV0ZVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1jb25zdFxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdmlldy5jb250cm9sbGVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB2aWV3LmNvbnRyb2xsZXJzW2ldO1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLnZpZXdNb2RlbCA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY29udHJvbGxlci5jb250YWluZXIuZ2V0KERPTS5FbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2NhdGUgdGFyZ2V0IGVsZW1lbnQgZm9yIFxcXCJcIiArIGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiArIFwiXFxcIi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvY2F0ZSB0YXJnZXQgZWxlbWVudCBmb3IgXFxcIlwiICsgYmluZGluZy5zb3VyY2VFeHByZXNzaW9uICsgXCJcXFwiLlwiKTtcclxufVxuXG5mdW5jdGlvbiBnZXRPYmplY3QoZXhwcmVzc2lvbiwgb2JqZWN0RXhwcmVzc2lvbiwgc291cmNlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RFeHByZXNzaW9uLmV2YWx1YXRlKHNvdXJjZSwgbnVsbCk7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnXCIgKyBvYmplY3RFeHByZXNzaW9uICsgXCInIHBhcnQgb2YgJ1wiICsgZXhwcmVzc2lvbiArIFwiJyBldmFsdWF0ZXMgdG8gXCIgKyB2YWx1ZSArIFwiIGluc3RlYWQgb2YgYW4gb2JqZWN0LCBudWxsIG9yIHVuZGVmaW5lZC5cIik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgb2JqZWN0IGFuZCBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uXHJcbiAqIEBwYXJhbSBzb3VyY2UgVGhlIHNjb3BlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8oZXhwcmVzc2lvbiwgc291cmNlKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuICAgIHdoaWxlIChleHByZXNzaW9uIGluc3RhbmNlb2YgQmluZGluZ0JlaGF2aW9yIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBWYWx1ZUNvbnZlcnRlcikge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLmV4cHJlc3Npb247XHJcbiAgICB9XHJcbiAgICB2YXIgb2JqZWN0O1xyXG4gICAgdmFyIHByb3BlcnR5TmFtZTtcclxuICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQWNjZXNzU2NvcGUpIHtcclxuICAgICAgICBvYmplY3QgPSBnZXRDb250ZXh0Rm9yKGV4cHJlc3Npb24ubmFtZSwgc291cmNlLCBleHByZXNzaW9uLmFuY2VzdG9yKTtcclxuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBleHByZXNzaW9uLm5hbWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQWNjZXNzTWVtYmVyKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gZ2V0T2JqZWN0KG9yaWdpbmFsRXhwcmVzc2lvbiwgZXhwcmVzc2lvbi5vYmplY3QsIHNvdXJjZSk7XHJcbiAgICAgICAgcHJvcGVydHlOYW1lID0gZXhwcmVzc2lvbi5uYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFjY2Vzc0tleWVkKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gZ2V0T2JqZWN0KG9yaWdpbmFsRXhwcmVzc2lvbiwgZXhwcmVzc2lvbi5vYmplY3QsIHNvdXJjZSk7XHJcbiAgICAgICAgcHJvcGVydHlOYW1lID0gZXhwcmVzc2lvbi5rZXkuZXZhbHVhdGUoc291cmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cHJlc3Npb24gJ1wiICsgb3JpZ2luYWxFeHByZXNzaW9uICsgXCInIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHZhbGlkYXRlIGJpbmRpbmctYmVoYXZpb3IuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgb2JqZWN0OiBvYmplY3QsIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lIH07XHJcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcclxufVxyXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xyXG59XG5cbnZhciBQcm9wZXJ0eUFjY2Vzc29yUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvcGVydHlBY2Nlc3NvclBhcnNlcihwYXJzZXIpIHtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIH1cclxuICAgIFByb3BlcnR5QWNjZXNzb3JQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHByb3BlcnR5KSB8fCBpc051bWJlcihwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWNjZXNzb3JUZXh0ID0gZ2V0QWNjZXNzb3JFeHByZXNzaW9uKHByb3BlcnR5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHZhciBhY2Nlc3NvciA9IHRoaXMucGFyc2VyLnBhcnNlKGFjY2Vzc29yVGV4dCk7XHJcbiAgICAgICAgaWYgKGFjY2Vzc29yIGluc3RhbmNlb2YgQWNjZXNzU2NvcGVcclxuICAgICAgICAgICAgfHwgYWNjZXNzb3IgaW5zdGFuY2VvZiBBY2Nlc3NNZW1iZXIgJiYgYWNjZXNzb3Iub2JqZWN0IGluc3RhbmNlb2YgQWNjZXNzU2NvcGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc29yLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgZXhwcmVzc2lvbjogXFxcIlwiICsgYWNjZXNzb3IgKyBcIlxcXCJcIik7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHlBY2Nlc3NvclBhcnNlci5pbmplY3QgPSBbUGFyc2VyXTtcclxuICAgIHJldHVybiBQcm9wZXJ0eUFjY2Vzc29yUGFyc2VyO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBnZXRBY2Nlc3NvckV4cHJlc3Npb24oZm4pIHtcclxuICAgIC8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG4gICAgdmFyIGNsYXNzaWMgPSAvXmZ1bmN0aW9uXFxzKlxcKFskX1xcd1xcZF0rXFwpXFxzKlxceyg/OlxccypcInVzZSBzdHJpY3RcIjspP1xccyooPzpbJF9cXHdcXGQuWydcIlxcXSs7XSspP1xccypyZXR1cm5cXHMrWyRfXFx3XFxkXStcXC4oWyRfXFx3XFxkXSspXFxzKjs/XFxzKlxcfSQvO1xyXG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cclxuICAgIHZhciBhcnJvdyA9IC9eXFwoP1skX1xcd1xcZF0rXFwpP1xccyo9PlxccypbJF9cXHdcXGRdK1xcLihbJF9cXHdcXGRdKykkLztcclxuICAgIHZhciBtYXRjaCA9IGNsYXNzaWMuZXhlYyhmbikgfHwgYXJyb3cuZXhlYyhmbik7XHJcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgYWNjZXNzb3IgZnVuY3Rpb246XFxuXCIgKyBmbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hbMV07XHJcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxuXG4vKipcclxuICogVmFsaWRhdGlvbiB0cmlnZ2Vycy5cclxuICovXHJcbnZhciB2YWxpZGF0ZVRyaWdnZXI7XHJcbihmdW5jdGlvbiAodmFsaWRhdGVUcmlnZ2VyKSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hbnVhbCB2YWxpZGF0aW9uLiAgVXNlIHRoZSBjb250cm9sbGVyJ3MgYHZhbGlkYXRlKClgIGFuZCAgYHJlc2V0KClgIG1ldGhvZHNcclxuICAgICAqIHRvIHZhbGlkYXRlIGFsbCBiaW5kaW5ncy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVUcmlnZ2VyW3ZhbGlkYXRlVHJpZ2dlcltcIm1hbnVhbFwiXSA9IDBdID0gXCJtYW51YWxcIjtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIGJpbmRpbmcgd2hlbiB0aGUgYmluZGluZydzIHRhcmdldCBlbGVtZW50IGZpcmVzIGEgRE9NIFwiYmx1clwiIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZVRyaWdnZXJbdmFsaWRhdGVUcmlnZ2VyW1wiYmx1clwiXSA9IDFdID0gXCJibHVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBiaW5kaW5nIHdoZW4gaXQgdXBkYXRlcyB0aGUgbW9kZWwgZHVlIHRvIGEgY2hhbmdlIGluIHRoZSB2aWV3LlxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZVRyaWdnZXJbdmFsaWRhdGVUcmlnZ2VyW1wiY2hhbmdlXCJdID0gMl0gPSBcImNoYW5nZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgYmluZGluZyB3aGVuIHRoZSBiaW5kaW5nJ3MgdGFyZ2V0IGVsZW1lbnQgZmlyZXMgYSBET00gXCJibHVyXCIgZXZlbnQgYW5kXHJcbiAgICAgKiB3aGVuIGl0IHVwZGF0ZXMgdGhlIG1vZGVsIGR1ZSB0byBhIGNoYW5nZSBpbiB0aGUgdmlldy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVUcmlnZ2VyW3ZhbGlkYXRlVHJpZ2dlcltcImNoYW5nZU9yQmx1clwiXSA9IDNdID0gXCJjaGFuZ2VPckJsdXJcIjtcclxufSkodmFsaWRhdGVUcmlnZ2VyIHx8ICh2YWxpZGF0ZVRyaWdnZXIgPSB7fSkpO1xuXG4vKipcclxuICogVmFsaWRhdGVzIG9iamVjdHMgYW5kIHByb3BlcnRpZXMuXHJcbiAqL1xyXG52YXIgVmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdG9yKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZhbGlkYXRvcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIFRoZSByZXN1bHQgb2YgdmFsaWRhdGluZyBhbiBpbmRpdmlkdWFsIHZhbGlkYXRpb24gcnVsZS5cclxuICovXHJcbnZhciBWYWxpZGF0ZVJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJ1bGUgVGhlIHJ1bGUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXN1bHQuIFZhbGlkYXRvciBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYy5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0aGF0IHdhcyB2YWxpZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdhcyB2YWxpZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgVGhlIGVycm9yLCBpZiB0aGUgcmVzdWx0IGlzIGEgdmFsaWRhdGlvbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGVSZXN1bHQocnVsZSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHZhbGlkLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5pZCA9IFZhbGlkYXRlUmVzdWx0Lm5leHRJZCsrO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGVSZXN1bHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkID8gJ1ZhbGlkLicgOiB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGVSZXN1bHQubmV4dElkID0gMDtcclxuICAgIHJldHVybiBWYWxpZGF0ZVJlc3VsdDtcclxufSgpKTtcblxudmFyIFZhbGlkYXRlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZUV2ZW50KFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiB2YWxpZGF0ZSBldmVudC4gRWl0aGVyIFwidmFsaWRhdGVcIiBvciBcInJlc2V0XCIuXHJcbiAgICAgKi9cclxuICAgIHR5cGUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29udHJvbGxlcidzIGN1cnJlbnQgYXJyYXkgb2YgZXJyb3JzLiBGb3IgYW4gYXJyYXkgY29udGFpbmluZyBib3RoXHJcbiAgICAgKiBmYWlsZWQgcnVsZXMgYW5kIHBhc3NlZCBydWxlcywgdXNlIHRoZSBcInJlc3VsdHNcIiBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZXJyb3JzLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnRyb2xsZXIncyBjdXJyZW50IGFycmF5IG9mIHZhbGlkYXRlIHJlc3VsdHMuIFRoaXNcclxuICAgICAqIGluY2x1ZGVzIGJvdGggcGFzc2VkIHJ1bGVzIGFuZCBmYWlsZWQgcnVsZXMuIEZvciBhbiBhcnJheSBvZiBvbmx5IGZhaWxlZCBydWxlcyxcclxuICAgICAqIHVzZSB0aGUgXCJlcnJvcnNcIiBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgcmVzdWx0cywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnN0cnVjdGlvbiBwYXNzZWQgdG8gdGhlIFwidmFsaWRhdGVcIiBvciBcInJlc2V0XCIgZXZlbnQuIFdpbGwgYmUgbnVsbCB3aGVuXHJcbiAgICAgKiB0aGUgY29udHJvbGxlcidzIHZhbGlkYXRlL3Jlc2V0IG1ldGhvZCB3YXMgY2FsbGVkIHdpdGggbm8gaW5zdHJ1Y3Rpb24gYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGluc3RydWN0aW9uLCBcclxuICAgIC8qKlxyXG4gICAgICogSW4gZXZlbnRzIHdpdGggdHlwZSA9PT0gXCJ2YWxpZGF0ZVwiLCB0aGlzIHByb3BlcnR5IHdpbGwgY29udGFpbiB0aGUgcmVzdWx0XHJcbiAgICAgKiBvZiB2YWxpZGF0aW5nIHRoZSBpbnN0cnVjdGlvbiAoc2VlIFwiaW5zdHJ1Y3Rpb25cIiBwcm9wZXJ0eSkuIFVzZSB0aGUgY29udHJvbGxlclZhbGlkYXRlUmVzdWx0XHJcbiAgICAgKiB0byBhY2Nlc3MgdGhlIHZhbGlkYXRlIHJlc3VsdHMgc3BlY2lmaWMgdG8gdGhlIGNhbGwgdG8gXCJ2YWxpZGF0ZVwiXHJcbiAgICAgKiAoYXMgb3Bwb3NlZCB0byB1c2luZyB0aGUgXCJyZXN1bHRzXCIgYW5kIFwiZXJyb3JzXCIgcHJvcGVydGllcyB0byBhY2Nlc3MgdGhlIGNvbnRyb2xsZXIncyBlbnRpcmVcclxuICAgICAqIHNldCBvZiByZXN1bHRzL2Vycm9ycykuXHJcbiAgICAgKi9cclxuICAgIGNvbnRyb2xsZXJWYWxpZGF0ZVJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcclxuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyVmFsaWRhdGVSZXN1bHQgPSBjb250cm9sbGVyVmFsaWRhdGVSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVmFsaWRhdGVFdmVudDtcclxufSgpKTtcblxuLyoqXHJcbiAqIE9yY2hlc3RyYXRlcyB2YWxpZGF0aW9uLlxyXG4gKiBNYW5hZ2VzIGEgc2V0IG9mIGJpbmRpbmdzLCByZW5kZXJlcnMgYW5kIG9iamVjdHMuXHJcbiAqIEV4cG9zZXMgdGhlIGN1cnJlbnQgbGlzdCBvZiB2YWxpZGF0aW9uIHJlc3VsdHMgZm9yIGJpbmRpbmcgcHVycG9zZXMuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGlvbkNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uQ29udHJvbGxlcih2YWxpZGF0b3IsIHByb3BlcnR5UGFyc2VyKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eVBhcnNlciA9IHByb3BlcnR5UGFyc2VyO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyZWQgYmluZGluZ3MgKHZpYSB0aGUgdmFsaWRhdGUgYmluZGluZyBiZWhhdmlvcilcclxuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIFJlbmRlcmVycyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY29udHJvbGxlciBpbnN0YW5jZS5cclxuICAgICAgICB0aGlzLnJlbmRlcmVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhbGlkYXRpb24gcmVzdWx0cyB0aGF0IGhhdmUgYmVlbiByZW5kZXJlZCBieSB0aGUgY29udHJvbGxlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWYWxpZGF0aW9uIGVycm9ycyB0aGF0IGhhdmUgYmVlbiByZW5kZXJlZCBieSB0aGUgY29udHJvbGxlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICBXaGV0aGVyIHRoZSBjb250cm9sbGVyIGlzIGN1cnJlbnRseSB2YWxpZGF0aW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEVsZW1lbnRzIHJlbGF0ZWQgdG8gdmFsaWRhdGlvbiByZXN1bHRzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkLlxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY29udHJvbGxlciBpbnN0YW5jZSAoZW50aXR5LXN0eWxlIHZhbGlkYXRpb24pLlxyXG4gICAgICAgIHRoaXMub2JqZWN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHJpZ2dlciB0aGF0IHdpbGwgaW52b2tlIGF1dG9tYXRpYyB2YWxpZGF0aW9uIG9mIGEgcHJvcGVydHkgdXNlZCBpbiBhIGJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRyaWdnZXIgPSB2YWxpZGF0ZVRyaWdnZXIuYmx1cjtcclxuICAgICAgICAvLyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB2YWxpZGF0aW9uIGhhcyBjb21wbGV0ZWQuXHJcbiAgICAgICAgdGhpcy5maW5pc2hWYWxpZGF0aW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5ldmVudENhbGxiYWNrcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gY29udHJvbGxlciB2YWxpZGF0ZSBhbmQgcmVzZXQgZXZlbnRzLiBUaGVzZSBldmVudHMgb2NjdXIgd2hlbiB0aGVcclxuICAgICAqIGNvbnRyb2xsZXIncyBcInZhbGlkYXRlXCJcIiBhbmQgXCJyZXNldFwiIG1ldGhvZHMgYXJlIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBjb250cm9sbGVyIHZhbGlkYXRlcyBvciByZXNldHMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZXZlbnRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZXZlbnRDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byB0aGUgc2V0IG9mIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgdmFsaWRhdGVkIHdoZW4gdmFsaWRhdGUgaXMgY2FsbGVkLlxyXG4gICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIE9wdGlvbmFsLiBUaGUgcnVsZXMuIElmIHJ1bGVzIGFyZW4ndCBzdXBwbGllZCB0aGUgVmFsaWRhdG9yIGltcGxlbWVudGF0aW9uIHdpbGwgbG9va3VwIHRoZSBydWxlcy5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIHJ1bGVzKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3RzLnNldChvYmplY3QsIHJ1bGVzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gdGhlIHNldCBvZiBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIHZhbGlkYXRlZCB3aGVuIHZhbGlkYXRlIGlzIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICB0aGlzLm9iamVjdHMuZGVsZXRlKG9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0RGVsdGEoJ3Jlc2V0JywgdGhpcy5yZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQub2JqZWN0ID09PSBvYmplY3Q7IH0pLCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuZCByZW5kZXJzIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSB2b2lkIDApIHsgcHJvcGVydHlOYW1lID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciByZXNvbHZlZFByb3BlcnR5TmFtZTtcclxuICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVkUHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWRQcm9wZXJ0eU5hbWUgPSB0aGlzLnByb3BlcnR5UGFyc2VyLnBhcnNlKHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdGVSZXN1bHQoeyBfX21hbnVhbGx5QWRkZWRfXzogdHJ1ZSB9LCBvYmplY3QsIHJlc29sdmVkUHJvcGVydHlOYW1lLCBmYWxzZSwgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0RGVsdGEoJ3ZhbGlkYXRlJywgW10sIFtyZXN1bHRdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbmQgdW5yZW5kZXJzIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlRXJyb3IgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0cy5pbmRleE9mKHJlc3VsdCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Jlc3VsdERlbHRhKCdyZXNldCcsIFtyZXN1bHRdLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlbmRlcmVyLlxyXG4gICAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoe1xyXG4gICAgICAgICAgICBraW5kOiAndmFsaWRhdGUnLFxyXG4gICAgICAgICAgICByZW5kZXI6IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHsgcmVzdWx0OiByZXN1bHQsIGVsZW1lbnRzOiBfdGhpcy5lbGVtZW50cy5nZXQocmVzdWx0KSB9KTsgfSksXHJcbiAgICAgICAgICAgIHVucmVuZGVyOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHJlbmRlcmVyLlxyXG4gICAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZVJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlbmRlcmVycy5zcGxpY2UodGhpcy5yZW5kZXJlcnMuaW5kZXhPZihyZW5kZXJlciksIDEpO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcih7XHJcbiAgICAgICAgICAgIGtpbmQ6ICdyZXNldCcsXHJcbiAgICAgICAgICAgIHJlbmRlcjogW10sXHJcbiAgICAgICAgICAgIHVucmVuZGVyOiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuICh7IHJlc3VsdDogcmVzdWx0LCBlbGVtZW50czogX3RoaXMuZWxlbWVudHMuZ2V0KHJlc3VsdCkgfSk7IH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBiaW5kaW5nIHdpdGggdGhlIGNvbnRyb2xsZXIuXHJcbiAgICAgKiBAcGFyYW0gYmluZGluZyBUaGUgYmluZGluZyBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIERPTSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIChvcHRpb25hbCkgcnVsZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBiaW5kaW5nLiBWYWxpZGF0b3IgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiAoYmluZGluZywgdGFyZ2V0LCBydWxlcykge1xyXG4gICAgICAgIHRoaXMuYmluZGluZ3Muc2V0KGJpbmRpbmcsIHsgdGFyZ2V0OiB0YXJnZXQsIHJ1bGVzOiBydWxlcywgcHJvcGVydHlJbmZvOiBudWxsIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5yZWdpc3RlcnMgYSBiaW5kaW5nIHdpdGggdGhlIGNvbnRyb2xsZXIuXHJcbiAgICAgKiBAcGFyYW0gYmluZGluZyBUaGUgYmluZGluZyBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnVucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcclxuICAgICAgICB0aGlzLnJlc2V0QmluZGluZyhiaW5kaW5nKTtcclxuICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShiaW5kaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludGVycHJldHMgdGhlIGluc3RydWN0aW9uIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgd2lsbCBpZGVudGlmeVxyXG4gICAgICogcmVsZXZhbnQgcmVzdWx0cyBpbiB0aGUgbGlzdCBvZiByZW5kZXJlZCB2YWxpZGF0aW9uIHJlc3VsdHMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5nZXRJbnN0cnVjdGlvblByZWRpY2F0ZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RfMSA9IGluc3RydWN0aW9uLm9iamVjdCwgcHJvcGVydHlOYW1lXzEgPSBpbnN0cnVjdGlvbi5wcm9wZXJ0eU5hbWUsIHJ1bGVzXzEgPSBpbnN0cnVjdGlvbi5ydWxlcztcclxuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZV8xO1xyXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ucHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGVfMSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm9iamVjdCA9PT0gb2JqZWN0XzEgJiYgeC5wcm9wZXJ0eU5hbWUgPT09IHByb3BlcnR5TmFtZV8xOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlXzEgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5vYmplY3QgPT09IG9iamVjdF8xOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChydWxlc18xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByZWRpY2F0ZV8xKHgpICYmIF90aGlzLnZhbGlkYXRvci5ydWxlRXhpc3RzKHJ1bGVzXzEsIHgucnVsZSk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZV8xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGFuZCByZW5kZXJzIHJlc3VsdHMuXHJcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gT3B0aW9uYWwuIEluc3RydWN0aW9ucyBvbiB3aGF0IHRvIHZhbGlkYXRlLiBJZiB1bmRlZmluZWQsIGFsbFxyXG4gICAgICogb2JqZWN0cyBhbmQgYmluZGluZ3Mgd2lsbCBiZSB2YWxpZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gR2V0IGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgdGhlIHZhbGlkYXRpb24gaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgdmFyIGV4ZWN1dGU7XHJcbiAgICAgICAgaWYgKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItY29uc3RcclxuICAgICAgICAgICAgdmFyIG9iamVjdF8yID0gaW5zdHJ1Y3Rpb24ub2JqZWN0LCBwcm9wZXJ0eU5hbWVfMiA9IGluc3RydWN0aW9uLnByb3BlcnR5TmFtZSwgcnVsZXNfMiA9IGluc3RydWN0aW9uLnJ1bGVzO1xyXG4gICAgICAgICAgICAvLyBpZiBydWxlcyB3ZXJlIG5vdCBzcGVjaWZpZWQsIGNoZWNrIHRoZSBvYmplY3QgbWFwLlxyXG4gICAgICAgICAgICBydWxlc18yID0gcnVsZXNfMiB8fCB0aGlzLm9iamVjdHMuZ2V0KG9iamVjdF8yKTtcclxuICAgICAgICAgICAgLy8gcHJvcGVydHkgc3BlY2lmaWVkP1xyXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ucHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbGlkYXRvci52YWxpZGF0ZU9iamVjdChvYmplY3RfMiwgcnVsZXNfMik7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbGlkYXRvci52YWxpZGF0ZVByb3BlcnR5KG9iamVjdF8yLCBwcm9wZXJ0eU5hbWVfMiwgcnVsZXNfMik7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIGFsbCBvYmplY3RzIGFuZCBiaW5kaW5ncy5cclxuICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEFycmF5LmZyb20oX3RoaXMub2JqZWN0cyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBvYmplY3QgPSBfYlswXSwgcnVsZXMgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKF90aGlzLnZhbGlkYXRvci52YWxpZGF0ZU9iamVjdChvYmplY3QsIHJ1bGVzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIF9kID0gQXJyYXkuZnJvbShfdGhpcy5iaW5kaW5ncyk7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lID0gX2RbX2NdLCBiaW5kaW5nID0gX2VbMF0sIHJ1bGVzID0gX2VbMV0ucnVsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhiaW5kaW5nLnNvdXJjZUV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5SW5mbyB8fCBfdGhpcy5vYmplY3RzLmhhcyhwcm9wZXJ0eUluZm8ub2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChfdGhpcy52YWxpZGF0b3IudmFsaWRhdGVQcm9wZXJ0eShwcm9wZXJ0eUluZm8ub2JqZWN0LCBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lLCBydWxlcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRTZXRzKSB7IHJldHVybiByZXN1bHRTZXRzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTsgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBleGlzdGluZyB2YWxpZGF0aW9uIHRvIGZpbmlzaCwgZXhlY3V0ZSB0aGUgaW5zdHJ1Y3Rpb24sIHJlbmRlciB0aGUgcmVzdWx0cy5cclxuICAgICAgICB0aGlzLnZhbGlkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciByZXR1cm5Qcm9taXNlID0gdGhpcy5maW5pc2hWYWxpZGF0aW5nXHJcbiAgICAgICAgICAgIC50aGVuKGV4ZWN1dGUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChuZXdSZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBfdGhpcy5nZXRJbnN0cnVjdGlvblByZWRpY2F0ZShpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBvbGRSZXN1bHRzID0gX3RoaXMucmVzdWx0cy5maWx0ZXIocHJlZGljYXRlKTtcclxuICAgICAgICAgICAgX3RoaXMucHJvY2Vzc1Jlc3VsdERlbHRhKCd2YWxpZGF0ZScsIG9sZFJlc3VsdHMsIG5ld1Jlc3VsdHMpO1xyXG4gICAgICAgICAgICBpZiAocmV0dXJuUHJvbWlzZSA9PT0gX3RoaXMuZmluaXNoVmFsaWRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmFsaWRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24sXHJcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3UmVzdWx0cy5maW5kKGZ1bmN0aW9uICh4KSB7IHJldHVybiAheC52YWxpZDsgfSkgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IG5ld1Jlc3VsdHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbGJhY2tzKGluc3RydWN0aW9uLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIHJlY292ZXIsIHRvIGVuYWJsZSBzdWJzZXF1ZW50IGNhbGxzIHRvIHZhbGlkYXRlKClcclxuICAgICAgICAgICAgX3RoaXMudmFsaWRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5maW5pc2hWYWxpZGF0aW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleGNlcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZmluaXNoVmFsaWRhdGluZyA9IHJldHVyblByb21pc2U7XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblByb21pc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgYW55IHJlbmRlcmVkIHZhbGlkYXRpb24gcmVzdWx0cyAodW5yZW5kZXJzKS5cclxuICAgICAqIEBwYXJhbSBpbnN0cnVjdGlvbiBPcHRpb25hbC4gSW5zdHJ1Y3Rpb25zIG9uIHdoYXQgdG8gcmVzZXQuIElmIHVuc3BlY2lmaWVkIGFsbCByZW5kZXJlZCByZXN1bHRzXHJcbiAgICAgKiB3aWxsIGJlIHVucmVuZGVyZWQuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSB0aGlzLmdldEluc3RydWN0aW9uUHJlZGljYXRlKGluc3RydWN0aW9uKTtcclxuICAgICAgICB2YXIgb2xkUmVzdWx0cyA9IHRoaXMucmVzdWx0cy5maWx0ZXIocHJlZGljYXRlKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSZXN1bHREZWx0YSgncmVzZXQnLCBvbGRSZXN1bHRzLCBbXSk7XHJcbiAgICAgICAgdGhpcy5pbnZva2VDYWxsYmFja3MoaW5zdHJ1Y3Rpb24sIG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoIGFuIG9iamVjdCBhbmQgcHJvcGVydHlOYW1lIChpZiBhbnkpLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0QXNzb2NpYXRlZEVsZW1lbnRzID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IF9hLm9iamVjdCwgcHJvcGVydHlOYW1lID0gX2EucHJvcGVydHlOYW1lO1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBBcnJheS5mcm9tKHRoaXMuYmluZGluZ3MpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfYltfaV0sIGJpbmRpbmcgPSBfY1swXSwgdGFyZ2V0ID0gX2NbMV0udGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiwgYmluZGluZy5zb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHlJbmZvICYmIHByb3BlcnR5SW5mby5vYmplY3QgPT09IG9iamVjdCAmJiBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID09PSBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnByb2Nlc3NSZXN1bHREZWx0YSA9IGZ1bmN0aW9uIChraW5kLCBvbGRSZXN1bHRzLCBuZXdSZXN1bHRzKSB7XHJcbiAgICAgICAgLy8gcHJlcGFyZSB0aGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uID0ge1xyXG4gICAgICAgICAgICBraW5kOiBraW5kLFxyXG4gICAgICAgICAgICByZW5kZXI6IFtdLFxyXG4gICAgICAgICAgICB1bnJlbmRlcjogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBuZXdSZXN1bHRzIHNvIHdlIGNhbiBtdXRhdGUgaXQgd2l0aG91dCBjYXVzaW5nIHNpZGUtZWZmZWN0cy5cclxuICAgICAgICBuZXdSZXN1bHRzID0gbmV3UmVzdWx0cy5zbGljZSgwKTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChvbGRSZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIG9sZCByZXN1bHQuXHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXNfMS5lbGVtZW50cy5nZXQob2xkUmVzdWx0KTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgcmVzdWx0IGZyb20gdGhlIGVsZW1lbnQgbWFwLlxyXG4gICAgICAgICAgICB0aGlzXzEuZWxlbWVudHMuZGVsZXRlKG9sZFJlc3VsdCk7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdW5yZW5kZXIgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uLnVucmVuZGVyLnB1c2goeyByZXN1bHQ6IG9sZFJlc3VsdCwgZWxlbWVudHM6IGVsZW1lbnRzIH0pO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlcmUncyBhIGNvcnJlc3BvbmRpbmcgbmV3IHJlc3VsdCBmb3IgdGhlIG9sZCByZXN1bHQgd2UgYXJlIHVucmVuZGVyaW5nLlxyXG4gICAgICAgICAgICB2YXIgbmV3UmVzdWx0SW5kZXggPSBuZXdSZXN1bHRzLmZpbmRJbmRleChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5ydWxlID09PSBvbGRSZXN1bHQucnVsZSAmJiB4Lm9iamVjdCA9PT0gb2xkUmVzdWx0Lm9iamVjdCAmJiB4LnByb3BlcnR5TmFtZSA9PT0gb2xkUmVzdWx0LnByb3BlcnR5TmFtZTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdSZXN1bHRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGNvcnJlc3BvbmRpbmcgbmV3IHJlc3VsdC4uLiBzaW1wbGUgcmVtb3ZlLlxyXG4gICAgICAgICAgICAgICAgdGhpc18xLnJlc3VsdHMuc3BsaWNlKHRoaXNfMS5yZXN1bHRzLmluZGV4T2Yob2xkUmVzdWx0KSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFJlc3VsdC52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5lcnJvcnMuc3BsaWNlKHRoaXNfMS5lcnJvcnMuaW5kZXhPZihvbGRSZXN1bHQpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBuZXcgcmVzdWx0Li4uXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmVzdWx0ID0gbmV3UmVzdWx0cy5zcGxpY2UobmV3UmVzdWx0SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50cyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIG5ldyByZXN1bHQuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHNfMSA9IHRoaXNfMS5nZXRBc3NvY2lhdGVkRWxlbWVudHMobmV3UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHRoaXNfMS5lbGVtZW50cy5zZXQobmV3UmVzdWx0LCBlbGVtZW50c18xKTtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlciBpbnN0cnVjdGlvbiBmb3IgdGhlIG5ldyByZXN1bHQuXHJcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5yZW5kZXIucHVzaCh7IHJlc3VsdDogbmV3UmVzdWx0LCBlbGVtZW50czogZWxlbWVudHNfMSB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGRvIGFuIGluLXBsYWNlIHJlcGxhY2VtZW50IG9mIHRoZSBvbGQgcmVzdWx0IHdpdGggdGhlIG5ldyByZXN1bHQuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGVuc3VyZXMgYW55IHJlcGVhdHMgYm91bmQgdG8gdGhpcy5yZXN1bHRzIHdpbGwgbm90IHRocmFzaC5cclxuICAgICAgICAgICAgICAgIHRoaXNfMS5yZXN1bHRzLnNwbGljZSh0aGlzXzEucmVzdWx0cy5pbmRleE9mKG9sZFJlc3VsdCksIDEsIG5ld1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFJlc3VsdC52YWxpZCAmJiBuZXdSZXN1bHQudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZXJyb3JzLnNwbGljZSh0aGlzXzEuZXJyb3JzLmluZGV4T2Yob2xkUmVzdWx0KSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghb2xkUmVzdWx0LnZhbGlkICYmICFuZXdSZXN1bHQudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZXJyb3JzLnNwbGljZSh0aGlzXzEuZXJyb3JzLmluZGV4T2Yob2xkUmVzdWx0KSwgMSwgbmV3UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuZXdSZXN1bHQudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZXJyb3JzLnB1c2gobmV3UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgLy8gY3JlYXRlIHVucmVuZGVyIGluc3RydWN0aW9ucyBmcm9tIHRoZSBvbGQgcmVzdWx0cy5cclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9sZFJlc3VsdHNfMSA9IG9sZFJlc3VsdHM7IF9pIDwgb2xkUmVzdWx0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgb2xkUmVzdWx0ID0gb2xkUmVzdWx0c18xW19pXTtcclxuICAgICAgICAgICAgX2xvb3BfMShvbGRSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgcmVuZGVyIGluc3RydWN0aW9ucyBmcm9tIHRoZSByZW1haW5pbmcgbmV3IHJlc3VsdHMuXHJcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBuZXdSZXN1bHRzXzEgPSBuZXdSZXN1bHRzOyBfYSA8IG5ld1Jlc3VsdHNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ld1Jlc3VsdHNfMVtfYV07XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXNzb2NpYXRlZEVsZW1lbnRzKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uLnJlbmRlci5wdXNoKHsgcmVzdWx0OiByZXN1bHQsIGVsZW1lbnRzOiBlbGVtZW50cyB9KTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQocmVzdWx0LCBlbGVtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyLlxyXG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnJlbmRlcmVyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gX2NbX2JdO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoaW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGUgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIGEgYmluZGluZy5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnZhbGlkYXRlQmluZGluZyA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XHJcbiAgICAgICAgaWYgKCFiaW5kaW5nLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiwgYmluZGluZy5zb3VyY2UpO1xyXG4gICAgICAgIHZhciBydWxlcztcclxuICAgICAgICB2YXIgcmVnaXN0ZXJlZEJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzLmdldChiaW5kaW5nKTtcclxuICAgICAgICBpZiAocmVnaXN0ZXJlZEJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcnVsZXMgPSByZWdpc3RlcmVkQmluZGluZy5ydWxlcztcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZEJpbmRpbmcucHJvcGVydHlJbmZvID0gcHJvcGVydHlJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYmplY3QgPSBwcm9wZXJ0eUluZm8ub2JqZWN0LCBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGUoeyBvYmplY3Q6IG9iamVjdCwgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsIHJ1bGVzOiBydWxlcyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgcmVzdWx0cyBmb3IgYSBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggYSBiaW5kaW5nLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmVzZXRCaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcclxuICAgICAgICB2YXIgcmVnaXN0ZXJlZEJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzLmdldChiaW5kaW5nKTtcclxuICAgICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiwgYmluZGluZy5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvICYmIHJlZ2lzdGVyZWRCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5SW5mbyA9IHJlZ2lzdGVyZWRCaW5kaW5nLnByb3BlcnR5SW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRCaW5kaW5nLnByb3BlcnR5SW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHByb3BlcnR5SW5mby5vYmplY3QsIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgdGhpcy5yZXNldCh7IG9iamVjdDogb2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGNvbnRyb2xsZXIncyB2YWxpZGF0ZVRyaWdnZXIuXHJcbiAgICAgKiBAcGFyYW0gbmV3VHJpZ2dlciBUaGUgbmV3IHZhbGlkYXRlVHJpZ2dlclxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuY2hhbmdlVHJpZ2dlciA9IGZ1bmN0aW9uIChuZXdUcmlnZ2VyKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRyaWdnZXIgPSBuZXdUcmlnZ2VyO1xyXG4gICAgICAgIHZhciBiaW5kaW5ncyA9IEFycmF5LmZyb20odGhpcy5iaW5kaW5ncy5rZXlzKCkpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYmluZGluZ3NfMSA9IGJpbmRpbmdzOyBfaSA8IGJpbmRpbmdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBiaW5kaW5nLnNvdXJjZTtcclxuICAgICAgICAgICAgYmluZGluZy51bmJpbmQoKTtcclxuICAgICAgICAgICAgYmluZGluZy5iaW5kKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV2YWxpZGF0ZXMgdGhlIGNvbnRyb2xsZXIncyBjdXJyZW50IHNldCBvZiBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5yZXZhbGlkYXRlRXJyb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVycm9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBvYmplY3QgPSBfYi5vYmplY3QsIHByb3BlcnR5TmFtZSA9IF9iLnByb3BlcnR5TmFtZSwgcnVsZSA9IF9iLnJ1bGU7XHJcbiAgICAgICAgICAgIGlmIChydWxlLl9fbWFudWFsbHlBZGRlZF9fKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbW3J1bGVdXTtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSh7IG9iamVjdDogb2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSwgcnVsZXM6IHJ1bGVzIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuaW52b2tlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudENhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgVmFsaWRhdGVFdmVudChyZXN1bHQgPyAndmFsaWRhdGUnIDogJ3Jlc2V0JywgdGhpcy5lcnJvcnMsIHRoaXMucmVzdWx0cywgaW5zdHJ1Y3Rpb24gfHwgbnVsbCwgcmVzdWx0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudENhbGxiYWNrc1tpXShldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLmluamVjdCA9IFtWYWxpZGF0b3IsIFByb3BlcnR5QWNjZXNzb3JQYXJzZXJdO1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25Db250cm9sbGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogQmluZGluZyBiZWhhdmlvci4gSW5kaWNhdGVzIHRoZSBib3VuZCBwcm9wZXJ0eSBzaG91bGQgYmUgdmFsaWRhdGVkLlxyXG4gKi9cclxudmFyIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSh0YXNrUXVldWUpIHtcclxuICAgICAgICB0aGlzLnRhc2tRdWV1ZSA9IHRhc2tRdWV1ZTtcclxuICAgIH1cclxuICAgIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChiaW5kaW5nLCBzb3VyY2UsIHJ1bGVzT3JDb250cm9sbGVyLCBydWxlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gaWRlbnRpZnkgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXRET01FbGVtZW50KGJpbmRpbmcsIHNvdXJjZSk7XHJcbiAgICAgICAgLy8gbG9jYXRlIHRoZSBjb250cm9sbGVyLlxyXG4gICAgICAgIHZhciBjb250cm9sbGVyO1xyXG4gICAgICAgIGlmIChydWxlc09yQ29udHJvbGxlciBpbnN0YW5jZW9mIFZhbGlkYXRpb25Db250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBydWxlc09yQ29udHJvbGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBzb3VyY2UuY29udGFpbmVyLmdldChPcHRpb25hbC5vZihWYWxpZGF0aW9uQ29udHJvbGxlcikpO1xyXG4gICAgICAgICAgICBydWxlcyA9IHJ1bGVzT3JDb250cm9sbGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIFZhbGlkYXRpb25Db250cm9sbGVyIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbGxlci5yZWdpc3RlckJpbmRpbmcoYmluZGluZywgdGFyZ2V0LCBydWxlcyk7XHJcbiAgICAgICAgYmluZGluZy52YWxpZGF0aW9uQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLmdldFZhbGlkYXRlVHJpZ2dlcihjb250cm9sbGVyKTtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgICAgIGlmICh0cmlnZ2VyICYgdmFsaWRhdGVUcmlnZ2VyLmNoYW5nZSkge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnZiYlVwZGF0ZVNvdXJjZSA9IGJpbmRpbmcudXBkYXRlU291cmNlO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25seS1hcnJvdy1mdW5jdGlvbnNcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlblxyXG4gICAgICAgICAgICBiaW5kaW5nLnVwZGF0ZVNvdXJjZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YmJVcGRhdGVTb3VyY2UodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uQ29udHJvbGxlci52YWxpZGF0ZUJpbmRpbmcodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgaWYgKHRyaWdnZXIgJiB2YWxpZGF0ZVRyaWdnZXIuYmx1cikge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnZhbGlkYXRlQmx1ckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50YXNrUXVldWUucXVldWVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbGxlci52YWxpZGF0ZUJpbmRpbmcoYmluZGluZyk7IH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBiaW5kaW5nLnZhbGlkYXRlVGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJpbmRpbmcudmFsaWRhdGVCbHVySGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmlnZ2VyICE9PSB2YWxpZGF0ZVRyaWdnZXIubWFudWFsKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuc3RhbmRhcmRVcGRhdGVUYXJnZXQgPSBiaW5kaW5nLnVwZGF0ZVRhcmdldDtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9ubHktYXJyb3ctZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW5cclxuICAgICAgICAgICAgYmluZGluZy51cGRhdGVUYXJnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhbmRhcmRVcGRhdGVUYXJnZXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uQ29udHJvbGxlci5yZXNldEJpbmRpbmcodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcclxuICAgICAgICAvLyByZXNldCB0aGUgYmluZGluZyB0byBpdCdzIG9yaWdpbmFsIHN0YXRlLlxyXG4gICAgICAgIGlmIChiaW5kaW5nLnZiYlVwZGF0ZVNvdXJjZSkge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnVwZGF0ZVNvdXJjZSA9IGJpbmRpbmcudmJiVXBkYXRlU291cmNlO1xyXG4gICAgICAgICAgICBiaW5kaW5nLnZiYlVwZGF0ZVNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nLnN0YW5kYXJkVXBkYXRlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcudXBkYXRlVGFyZ2V0ID0gYmluZGluZy5zdGFuZGFyZFVwZGF0ZVRhcmdldDtcclxuICAgICAgICAgICAgYmluZGluZy5zdGFuZGFyZFVwZGF0ZVRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nLnZhbGlkYXRlQmx1ckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgYmluZGluZy52YWxpZGF0ZVRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgYmluZGluZy52YWxpZGF0ZUJsdXJIYW5kbGVyKTtcclxuICAgICAgICAgICAgYmluZGluZy52YWxpZGF0ZUJsdXJIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICAgICAgYmluZGluZy52YWxpZGF0ZVRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmcudmFsaWRhdGlvbkNvbnRyb2xsZXIudW5yZWdpc3RlckJpbmRpbmcoYmluZGluZyk7XHJcbiAgICAgICAgYmluZGluZy52YWxpZGF0aW9uQ29udHJvbGxlciA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZTtcclxufSgpKTtcblxuLyoqXHJcbiAqIEJpbmRpbmcgYmVoYXZpb3IuIEluZGljYXRlcyB0aGUgYm91bmQgcHJvcGVydHkgc2hvdWxkIGJlIHZhbGlkYXRlZFxyXG4gKiB3aGVuIHRoZSB2YWxpZGF0ZSB0cmlnZ2VyIHNwZWNpZmllZCBieSB0aGUgYXNzb2NpYXRlZCBjb250cm9sbGVyJ3NcclxuICogdmFsaWRhdGVUcmlnZ2VyIHByb3BlcnR5IG9jY3Vycy5cclxuICovXHJcbnZhciBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yLnByb3RvdHlwZS5nZXRWYWxpZGF0ZVRyaWdnZXIgPSBmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnZhbGlkYXRlVHJpZ2dlcjtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvci5pbmplY3QgPSBbVGFza1F1ZXVlXTtcclxuICAgIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgYmluZGluZ0JlaGF2aW9yKCd2YWxpZGF0ZScpXHJcbiAgICBdLCBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvcik7XHJcbiAgICByZXR1cm4gVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3I7XHJcbn0oVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3JCYXNlKSk7XHJcbi8qKlxyXG4gKiBCaW5kaW5nIGJlaGF2aW9yLiBJbmRpY2F0ZXMgdGhlIGJvdW5kIHByb3BlcnR5IHdpbGwgYmUgdmFsaWRhdGVkXHJcbiAqIG1hbnVhbGx5LCBieSBjYWxsaW5nIGNvbnRyb2xsZXIudmFsaWRhdGUoKS4gTm8gYXV0b21hdGljIHZhbGlkYXRpb25cclxuICogdHJpZ2dlcmVkIGJ5IGRhdGEtZW50cnkgb3IgYmx1ciB3aWxsIG9jY3VyLlxyXG4gKi9cclxudmFyIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGVNYW51YWxseUJpbmRpbmdCZWhhdmlvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGVNYW51YWxseUJpbmRpbmdCZWhhdmlvci5wcm90b3R5cGUuZ2V0VmFsaWRhdGVUcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVRyaWdnZXIubWFudWFsO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IuaW5qZWN0ID0gW1Rhc2tRdWV1ZV07XHJcbiAgICBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgYmluZGluZ0JlaGF2aW9yKCd2YWxpZGF0ZU1hbnVhbGx5JylcclxuICAgIF0sIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IpO1xyXG4gICAgcmV0dXJuIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3I7XHJcbn0oVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3JCYXNlKSk7XHJcbi8qKlxyXG4gKiBCaW5kaW5nIGJlaGF2aW9yLiBJbmRpY2F0ZXMgdGhlIGJvdW5kIHByb3BlcnR5IHNob3VsZCBiZSB2YWxpZGF0ZWRcclxuICogd2hlbiB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IGJsdXJzLlxyXG4gKi9cclxudmFyIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGVPbkJsdXJCaW5kaW5nQmVoYXZpb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGVPbkJsdXJCaW5kaW5nQmVoYXZpb3IucHJvdG90eXBlLmdldFZhbGlkYXRlVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGVUcmlnZ2VyLmJsdXI7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGVPbkJsdXJCaW5kaW5nQmVoYXZpb3IuaW5qZWN0ID0gW1Rhc2tRdWV1ZV07XHJcbiAgICBWYWxpZGF0ZU9uQmx1ckJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndmFsaWRhdGVPbkJsdXInKVxyXG4gICAgXSwgVmFsaWRhdGVPbkJsdXJCaW5kaW5nQmVoYXZpb3IpO1xyXG4gICAgcmV0dXJuIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yO1xyXG59KFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSkpO1xyXG4vKipcclxuICogQmluZGluZyBiZWhhdmlvci4gSW5kaWNhdGVzIHRoZSBib3VuZCBwcm9wZXJ0eSBzaG91bGQgYmUgdmFsaWRhdGVkXHJcbiAqIHdoZW4gdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBpcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyLCBjYXVzaW5nIGEgY2hhbmdlXHJcbiAqIHRvIHRoZSBtb2RlbC5cclxuICovXHJcbnZhciBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZhbGlkYXRlT25DaGFuZ2VCaW5kaW5nQmVoYXZpb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlT25DaGFuZ2VCaW5kaW5nQmVoYXZpb3IucHJvdG90eXBlLmdldFZhbGlkYXRlVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGVUcmlnZ2VyLmNoYW5nZTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLmluamVjdCA9IFtUYXNrUXVldWVdO1xyXG4gICAgVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndmFsaWRhdGVPbkNoYW5nZScpXHJcbiAgICBdLCBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yKTtcclxuICAgIHJldHVybiBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yO1xyXG59KFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSkpO1xyXG4vKipcclxuICogQmluZGluZyBiZWhhdmlvci4gSW5kaWNhdGVzIHRoZSBib3VuZCBwcm9wZXJ0eSBzaG91bGQgYmUgdmFsaWRhdGVkXHJcbiAqIHdoZW4gdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBibHVycyBvciBpcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyLCBjYXVzaW5nXHJcbiAqIGEgY2hhbmdlIHRvIHRoZSBtb2RlbC5cclxuICovXHJcbnZhciBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZhbGlkYXRlT25DaGFuZ2VPckJsdXJCaW5kaW5nQmVoYXZpb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlT25DaGFuZ2VPckJsdXJCaW5kaW5nQmVoYXZpb3IucHJvdG90eXBlLmdldFZhbGlkYXRlVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGVUcmlnZ2VyLmNoYW5nZU9yQmx1cjtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLmluamVjdCA9IFtUYXNrUXVldWVdO1xyXG4gICAgVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndmFsaWRhdGVPbkNoYW5nZU9yQmx1cicpXHJcbiAgICBdLCBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yKTtcclxuICAgIHJldHVybiBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yO1xyXG59KFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSkpO1xuXG4vKipcclxuICogQ3JlYXRlcyBWYWxpZGF0aW9uQ29udHJvbGxlciBpbnN0YW5jZXMuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5KGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5LmdldCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeShjb250YWluZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250cm9sbGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcclxuICAgICAgICBpZiAoIXZhbGlkYXRvcikge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3IgPSB0aGlzLmNvbnRhaW5lci5nZXQoVmFsaWRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BlcnR5UGFyc2VyID0gdGhpcy5jb250YWluZXIuZ2V0KFByb3BlcnR5QWNjZXNzb3JQYXJzZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkNvbnRyb2xsZXIodmFsaWRhdG9yLCBwcm9wZXJ0eVBhcnNlcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRyb2xsZXIgYW5kIHJlZ2lzdGVycyBpdCBpbiB0aGUgY3VycmVudCBlbGVtZW50J3MgY29udGFpbmVyIHNvIHRoYXQgaXQnc1xyXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSB2YWxpZGF0ZSBiaW5kaW5nIGJlaGF2aW9yIGFuZCByZW5kZXJlcnMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRm9yQ3VycmVudFNjb3BlID0gZnVuY3Rpb24gKHZhbGlkYXRvcikge1xyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5jcmVhdGUodmFsaWRhdG9yKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZWdpc3Rlckluc3RhbmNlKFZhbGlkYXRpb25Db250cm9sbGVyLCBjb250cm9sbGVyKTtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5O1xyXG59KCkpO1xyXG5WYWxpZGF0aW9uQ29udHJvbGxlckZhY3RvcnlbJ3Byb3RvY29sOmF1cmVsaWE6cmVzb2x2ZXInXSA9IHRydWU7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZShib3VuZGFyeUVsZW1lbnQsIGNvbnRyb2xsZXJBY2Nlc3Nvcikge1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnlFbGVtZW50ID0gYm91bmRhcnlFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlckFjY2Vzc29yID0gY29udHJvbGxlckFjY2Vzc29yO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmVycm9yc0ludGVybmFsID0gW107XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLmluamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW0RPTS5FbGVtZW50LCBMYXp5Lm9mKFZhbGlkYXRpb25Db250cm9sbGVyKV07XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVycm9yc0ludGVybmFsLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKGEudGFyZ2V0c1swXSA9PT0gYi50YXJnZXRzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgICAgICAgICByZXR1cm4gYS50YXJnZXRzWzBdLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIudGFyZ2V0c1swXSkgJiAyID8gMSA6IC0xO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLmludGVyZXN0aW5nRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmJvdW5kYXJ5RWxlbWVudC5jb250YWlucyhlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXNfMS5lcnJvcnNJbnRlcm5hbC5maW5kSW5kZXgoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZXJyb3IgPT09IHJlc3VsdDsgfSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNfMS5lcnJvcnNJbnRlcm5hbC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gaW5zdHJ1Y3Rpb24udW5yZW5kZXI7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYVtfaV0ucmVzdWx0O1xyXG4gICAgICAgICAgICBfbG9vcF8xKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBpbnN0cnVjdGlvbi5yZW5kZXI7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgIHZhciBfZCA9IF9jW19iXSwgcmVzdWx0ID0gX2QucmVzdWx0LCBlbGVtZW50cyA9IF9kLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuaW50ZXJlc3RpbmdFbGVtZW50cyhlbGVtZW50cyk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNJbnRlcm5hbC5wdXNoKHsgZXJyb3I6IHJlc3VsdCwgdGFyZ2V0czogdGFyZ2V0cyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvcnQoKTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzSW50ZXJuYWw7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXJBY2Nlc3NvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIHdpbGwgY2FsbCByZW5kZXIoKSB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB1cGRhdGluZyB0aGlzLmVycm9yc1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hZGRSZW5kZXJlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIucmVtb3ZlUmVuZGVyZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRhYmxlKHsgZGVmYXVsdEJpbmRpbmdNb2RlOiBiaW5kaW5nTW9kZS5vbmVXYXkgfSlcclxuICAgIF0sIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLCBcImNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRhYmxlKHsgcHJpbWFyeVByb3BlcnR5OiB0cnVlLCBkZWZhdWx0QmluZGluZ01vZGU6IGJpbmRpbmdNb2RlLnR3b1dheSB9KVxyXG4gICAgXSwgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgY3VzdG9tQXR0cmlidXRlKCd2YWxpZGF0aW9uLWVycm9ycycpXHJcbiAgICBdLCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlKTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlO1xyXG59KCkpO1xuXG52YXIgVmFsaWRhdGlvblJlbmRlcmVyQ3VzdG9tQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvblJlbmRlcmVyQ3VzdG9tQXR0cmlidXRlKCkge1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvblJlbmRlcmVyQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZS5jcmVhdGVkID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHZpZXcuY29udGFpbmVyO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSB0aGlzLmNvbnRhaW5lci5nZXQoVmFsaWRhdGlvbkNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLmNvbnRhaW5lci5nZXQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFkZFJlbmRlcmVyKHRoaXMucmVuZGVyZXIpO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5yZW1vdmVSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGN1c3RvbUF0dHJpYnV0ZSgndmFsaWRhdGlvbi1yZW5kZXJlcicpXHJcbiAgICBdLCBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUpO1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZTtcclxufSgpKTtcblxuLyoqXHJcbiAqIFNldHMsIHVuc2V0cyBhbmQgcmV0cmlldmVzIHJ1bGVzIG9uIGFuIG9iamVjdCBvciBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICovXHJcbnZhciBSdWxlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJ1bGVzKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBydWxlcyB0byBhIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgUnVsZXMuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcnVsZXMpIHtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgUnVsZXMua2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHJ1bGVzIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBydWxlcyBmcm9tIGEgdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBSdWxlcy51bnNldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0W1J1bGVzLmtleV0gPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB0YXJnZXQncyBydWxlcy5cclxuICAgICAqL1xyXG4gICAgUnVsZXMuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRbUnVsZXMua2V5XSB8fCBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc3RvcmVzIHRoZSBydWxlcy5cclxuICAgICAqL1xyXG4gICAgUnVsZXMua2V5ID0gJ19fcnVsZXNfXyc7XHJcbiAgICByZXR1cm4gUnVsZXM7XHJcbn0oKSk7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWVtcHR5XHJcbnZhciBFeHByZXNzaW9uVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25WaXNpdG9yKCkge1xyXG4gICAgfVxyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoY2hhaW4pIHtcclxuICAgICAgICB0aGlzLnZpc2l0QXJncyhjaGFpbi5leHByZXNzaW9ucyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluZGluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgYmVoYXZpb3IuZXhwcmVzc2lvbi5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MoYmVoYXZpb3IuYXJncyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFsdWVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XHJcbiAgICAgICAgY29udmVydGVyLmV4cHJlc3Npb24uYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudmlzaXRBcmdzKGNvbnZlcnRlci5hcmdzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBc3NpZ24gPSBmdW5jdGlvbiAoYXNzaWduKSB7XHJcbiAgICAgICAgYXNzaWduLnRhcmdldC5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgYXNzaWduLnZhbHVlLmFjY2VwdCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChjb25kaXRpb25hbCkge1xyXG4gICAgICAgIGNvbmRpdGlvbmFsLmNvbmRpdGlvbi5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgY29uZGl0aW9uYWwueWVzLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICBjb25kaXRpb25hbC5uby5hY2NlcHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWNjZXNzVGhpcyA9IGZ1bmN0aW9uIChhY2Nlc3MpIHtcclxuICAgICAgICBhY2Nlc3MuYW5jZXN0b3IgPSBhY2Nlc3MuYW5jZXN0b3I7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWNjZXNzU2NvcGUgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XHJcbiAgICAgICAgYWNjZXNzLm5hbWUgPSBhY2Nlc3MubmFtZTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBY2Nlc3NNZW1iZXIgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XHJcbiAgICAgICAgYWNjZXNzLm9iamVjdC5hY2NlcHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWNjZXNzS2V5ZWQgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XHJcbiAgICAgICAgYWNjZXNzLm9iamVjdC5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgYWNjZXNzLmtleS5hY2NlcHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FsbFNjb3BlID0gZnVuY3Rpb24gKGNhbGwpIHtcclxuICAgICAgICB0aGlzLnZpc2l0QXJncyhjYWxsLmFyZ3MpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIChjYWxsKSB7XHJcbiAgICAgICAgY2FsbC5mdW5jLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpc2l0QXJncyhjYWxsLmFyZ3MpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhbGxNZW1iZXIgPSBmdW5jdGlvbiAoY2FsbCkge1xyXG4gICAgICAgIGNhbGwub2JqZWN0LmFjY2VwdCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpc2l0QXJncyhjYWxsLmFyZ3MpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgICAgICBwcmVmaXguZXhwcmVzc2lvbi5hY2NlcHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xyXG4gICAgICAgIGJpbmFyeS5sZWZ0LmFjY2VwdCh0aGlzKTtcclxuICAgICAgICBiaW5hcnkucmlnaHQuYWNjZXB0KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIGxpdGVyYWwudmFsdWUgPSBsaXRlcmFsLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChsaXRlcmFsKSB7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MobGl0ZXJhbC5lbGVtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE9iamVjdCA9IGZ1bmN0aW9uIChsaXRlcmFsKSB7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MobGl0ZXJhbC52YWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxTdHJpbmcgPSBmdW5jdGlvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIGxpdGVyYWwudmFsdWUgPSBsaXRlcmFsLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdzW2ldLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV4cHJlc3Npb25WaXNpdG9yO1xyXG59KCkpO1xuXG52YXIgVmFsaWRhdGlvbk1lc3NhZ2VQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uTWVzc2FnZVBhcnNlcihiaW5kaW5xTGFuZ3VhZ2UpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbnFMYW5ndWFnZSA9IGJpbmRpbnFMYW5ndWFnZTtcclxuICAgICAgICB0aGlzLmVtcHR5U3RyaW5nRXhwcmVzc2lvbiA9IG5ldyBMaXRlcmFsU3RyaW5nKCcnKTtcclxuICAgICAgICB0aGlzLm51bGxFeHByZXNzaW9uID0gbmV3IExpdGVyYWxQcmltaXRpdmUobnVsbCk7XHJcbiAgICAgICAgdGhpcy51bmRlZmluZWRFeHByZXNzaW9uID0gbmV3IExpdGVyYWxQcmltaXRpdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLmNhY2hlID0ge307XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0aW9uTWVzc2FnZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlW21lc3NhZ2VdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVbbWVzc2FnZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuYmluZGlucUxhbmd1YWdlLnBhcnNlSW50ZXJwb2xhdGlvbihudWxsLCBtZXNzYWdlKTtcclxuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsU3RyaW5nKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG5ldyBMaXRlcmFsU3RyaW5nKHBhcnRzWzBdKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgQmluYXJ5KCcrJywgZXhwcmVzc2lvbiwgbmV3IEJpbmFyeSgnKycsIHRoaXMuY29hbGVzY2UocGFydHNbaV0pLCBuZXcgTGl0ZXJhbFN0cmluZyhwYXJ0c1tpICsgMV0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yLnZhbGlkYXRlKGV4cHJlc3Npb24sIG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY2FjaGVbbWVzc2FnZV0gPSBleHByZXNzaW9uO1xyXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyLnByb3RvdHlwZS5jb2FsZXNjZSA9IGZ1bmN0aW9uIChwYXJ0KSB7XHJcbiAgICAgICAgLy8gcGFydCA9PT0gbnVsbCB8fCBwYXJ0ID09PSB1bmRlZmluZWQgPyAnJyA6IHBhcnRcclxuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKG5ldyBCaW5hcnkoJ3x8JywgbmV3IEJpbmFyeSgnPT09JywgcGFydCwgdGhpcy5udWxsRXhwcmVzc2lvbiksIG5ldyBCaW5hcnkoJz09PScsIHBhcnQsIHRoaXMudW5kZWZpbmVkRXhwcmVzc2lvbikpLCB0aGlzLmVtcHR5U3RyaW5nRXhwcmVzc2lvbiwgbmV3IENhbGxNZW1iZXIocGFydCwgJ3RvU3RyaW5nJywgW10pKTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uTWVzc2FnZVBhcnNlci5pbmplY3QgPSBbQmluZGluZ0xhbmd1YWdlXTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uTWVzc2FnZVBhcnNlcjtcclxufSgpKTtcclxudmFyIE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVzc2FnZUV4cHJlc3Npb25WYWxpZGF0b3Iob3JpZ2luYWxNZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWVzc2FnZUV4cHJlc3Npb25WYWxpZGF0b3IudmFsaWRhdGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3JpZ2luYWxNZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgTWVzc2FnZUV4cHJlc3Npb25WYWxpZGF0b3Iob3JpZ2luYWxNZXNzYWdlKTtcclxuICAgICAgICBleHByZXNzaW9uLmFjY2VwdCh2aXNpdG9yKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvci5wcm90b3R5cGUudmlzaXRBY2Nlc3NTY29wZSA9IGZ1bmN0aW9uIChhY2Nlc3MpIHtcclxuICAgICAgICBpZiAoYWNjZXNzLmFuY2VzdG9yICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJHBhcmVudCBpcyBub3QgcGVybWl0dGVkIGluIHZhbGlkYXRpb24gbWVzc2FnZSBleHByZXNzaW9ucy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFsnZGlzcGxheU5hbWUnLCAncHJvcGVydHlOYW1lJywgJ3ZhbHVlJywgJ29iamVjdCcsICdjb25maWcnLCAnZ2V0RGlzcGxheU5hbWUnXS5pbmRleE9mKGFjY2Vzcy5uYW1lKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZ2V0TG9nZ2VyKCdhdXJlbGlhLXZhbGlkYXRpb24nKVxyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxyXG4gICAgICAgICAgICAgICAgLndhcm4oXCJEaWQgeW91IG1lYW4gdG8gdXNlIFxcXCIkXCIgKyBhY2Nlc3MubmFtZSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGFjY2Vzcy5uYW1lICsgXCJcXFwiIGluIHRoaXMgdmFsaWRhdGlvbiBtZXNzYWdlIHRlbXBsYXRlOiBcXFwiXCIgKyB0aGlzLm9yaWdpbmFsTWVzc2FnZSArIFwiXFxcIj9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvcjtcclxufShFeHByZXNzaW9uVmlzaXRvcikpO1xuXG4vKipcclxuICogRGljdGlvbmFyeSBvZiB2YWxpZGF0aW9uIG1lc3NhZ2VzLiBbbWVzc2FnZUtleV06IG1lc3NhZ2VFeHByZXNzaW9uXHJcbiAqL1xyXG52YXIgdmFsaWRhdGlvbk1lc3NhZ2VzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCB2YWxpZGF0aW9uIG1lc3NhZ2UuIFVzZWQgd2l0aCBydWxlcyB0aGF0IGhhdmUgbm8gc3RhbmRhcmQgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdDogXCIkeyRkaXNwbGF5TmFtZX0gaXMgaW52YWxpZC5cIixcclxuICAgIHJlcXVpcmVkOiBcIiR7JGRpc3BsYXlOYW1lfSBpcyByZXF1aXJlZC5cIixcclxuICAgIG1hdGNoZXM6IFwiJHskZGlzcGxheU5hbWV9IGlzIG5vdCBjb3JyZWN0bHkgZm9ybWF0dGVkLlwiLFxyXG4gICAgZW1haWw6IFwiJHskZGlzcGxheU5hbWV9IGlzIG5vdCBhIHZhbGlkIGVtYWlsLlwiLFxyXG4gICAgbWluTGVuZ3RoOiBcIiR7JGRpc3BsYXlOYW1lfSBtdXN0IGJlIGF0IGxlYXN0ICR7JGNvbmZpZy5sZW5ndGh9IGNoYXJhY3RlciR7JGNvbmZpZy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30uXCIsXHJcbiAgICBtYXhMZW5ndGg6IFwiJHskZGlzcGxheU5hbWV9IGNhbm5vdCBiZSBsb25nZXIgdGhhbiAkeyRjb25maWcubGVuZ3RofSBjaGFyYWN0ZXIkeyRjb25maWcubGVuZ3RoID09PSAxID8gJycgOiAncyd9LlwiLFxyXG4gICAgbWluSXRlbXM6IFwiJHskZGlzcGxheU5hbWV9IG11c3QgY29udGFpbiBhdCBsZWFzdCAkeyRjb25maWcuY291bnR9IGl0ZW0keyRjb25maWcuY291bnQgPT09IDEgPyAnJyA6ICdzJ30uXCIsXHJcbiAgICBtYXhJdGVtczogXCIkeyRkaXNwbGF5TmFtZX0gY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuICR7JGNvbmZpZy5jb3VudH0gaXRlbSR7JGNvbmZpZy5jb3VudCA9PT0gMSA/ICcnIDogJ3MnfS5cIixcclxuICAgIG1pbjogXCIkeyRkaXNwbGF5TmFtZX0gbXVzdCBiZSBhdCBsZWFzdCAkeyRjb25maWcuY29uc3RyYWludH0uXCIsXHJcbiAgICBtYXg6IFwiJHskZGlzcGxheU5hbWV9IG11c3QgYmUgYXQgbW9zdCAkeyRjb25maWcuY29uc3RyYWludH0uXCIsXHJcbiAgICByYW5nZTogXCIkeyRkaXNwbGF5TmFtZX0gbXVzdCBiZSBiZXR3ZWVuIG9yIGVxdWFsIHRvICR7JGNvbmZpZy5taW59IGFuZCAkeyRjb25maWcubWF4fS5cIixcclxuICAgIGJldHdlZW46IFwiJHskZGlzcGxheU5hbWV9IG11c3QgYmUgYmV0d2VlbiBidXQgbm90IGVxdWFsIHRvICR7JGNvbmZpZy5taW59IGFuZCAkeyRjb25maWcubWF4fS5cIixcclxuICAgIGVxdWFsczogXCIkeyRkaXNwbGF5TmFtZX0gbXVzdCBiZSAkeyRjb25maWcuZXhwZWN0ZWRWYWx1ZX0uXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgdmFsaWRhdGlvbiBtZXNzYWdlcyBhbmQgcHJvcGVydHkgZGlzcGxheSBuYW1lcy5cclxuICovXHJcbnZhciBWYWxpZGF0aW9uTWVzc2FnZVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbk1lc3NhZ2VQcm92aWRlcihwYXJzZXIpIHtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1lc3NhZ2UgYmluZGluZyBleHByZXNzaW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGtleS5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG1lc3NhZ2Uga2V5LlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uTWVzc2FnZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChrZXkgaW4gdmFsaWRhdGlvbk1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB2YWxpZGF0aW9uTWVzc2FnZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB2YWxpZGF0aW9uTWVzc2FnZXNbJ2RlZmF1bHQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlKG1lc3NhZ2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRm9ybXVsYXRlcyBhIHByb3BlcnR5IGRpc3BsYXkgbmFtZSB1c2luZyB0aGUgcHJvcGVydHkgbmFtZSBhbmQgdGhlIGNvbmZpZ3VyZWRcclxuICAgICAqIGRpc3BsYXlOYW1lIChpZiBwcm92aWRlZCkuXHJcbiAgICAgKiBPdmVycmlkZSB0aGlzIHdpdGggeW91ciBvd24gY3VzdG9tIGxvZ2ljLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbk1lc3NhZ2VQcm92aWRlci5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBkaXNwbGF5TmFtZSkge1xyXG4gICAgICAgIGlmIChkaXNwbGF5TmFtZSAhPT0gbnVsbCAmJiBkaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzcGxheU5hbWUgaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBkaXNwbGF5TmFtZSgpIDogZGlzcGxheU5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwbGl0IG9uIHVwcGVyLWNhc2UgbGV0dGVycy5cclxuICAgICAgICB2YXIgd29yZHMgPSBwcm9wZXJ0eU5hbWUudG9TdHJpbmcoKS5zcGxpdCgvKD89W0EtWl0pLykuam9pbignICcpO1xyXG4gICAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyLlxyXG4gICAgICAgIHJldHVybiB3b3Jkcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmRzLnNsaWNlKDEpO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIuaW5qZWN0ID0gW1ZhbGlkYXRpb25NZXNzYWdlUGFyc2VyXTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uTWVzc2FnZVByb3ZpZGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogVmFsaWRhdGVzLlxyXG4gKiBSZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyBvYmplY3RzIGFuZCBwcm9wZXJ0aWVzLlxyXG4gKi9cclxudmFyIFN0YW5kYXJkVmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0YW5kYXJkVmFsaWRhdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhbmRhcmRWYWxpZGF0b3IobWVzc2FnZVByb3ZpZGVyLCByZXNvdXJjZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm1lc3NhZ2VQcm92aWRlciA9IG1lc3NhZ2VQcm92aWRlcjtcclxuICAgICAgICBfdGhpcy5sb29rdXBGdW5jdGlvbnMgPSByZXNvdXJjZXMubG9va3VwRnVuY3Rpb25zO1xyXG4gICAgICAgIF90aGlzLmdldERpc3BsYXlOYW1lID0gbWVzc2FnZVByb3ZpZGVyLmdldERpc3BsYXlOYW1lLmJpbmQobWVzc2FnZVByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gdmFsaWRhdGUuXHJcbiAgICAgKiBAcGFyYW0gcnVsZXMgT3B0aW9uYWwuIElmIHVuc3BlY2lmaWVkLCB0aGUgcnVsZXMgd2lsbCBiZSBsb29rZWQgdXAgdXNpbmcgdGhlIG1ldGFkYXRhXHJcbiAgICAgKiBmb3IgdGhlIG9iamVjdCBjcmVhdGVkIGJ5IFZhbGlkYXRpb25SdWxlcy4uLi5vbihjbGFzcy9vYmplY3QpXHJcbiAgICAgKi9cclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHlOYW1lLCBydWxlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKG9iamVjdCwgcHJvcGVydHlOYW1lLCBydWxlcyB8fCBudWxsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBhbGwgcnVsZXMgZm9yIHNwZWNpZmllZCBvYmplY3QgYW5kIGl0J3MgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB2YWxpZGF0ZS5cclxuICAgICAqIEBwYXJhbSBydWxlcyBPcHRpb25hbC4gSWYgdW5zcGVjaWZpZWQsIHRoZSBydWxlcyB3aWxsIGJlIGxvb2tlZCB1cCB1c2luZyB0aGUgbWV0YWRhdGFcclxuICAgICAqIGZvciB0aGUgb2JqZWN0IGNyZWF0ZWQgYnkgVmFsaWRhdGlvblJ1bGVzLi4uLm9uKGNsYXNzL29iamVjdClcclxuICAgICAqL1xyXG4gICAgU3RhbmRhcmRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgcnVsZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShvYmplY3QsIG51bGwsIHJ1bGVzIHx8IG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcnVsZSBleGlzdHMgaW4gYSBzZXQgb2YgcnVsZXMuXHJcbiAgICAgKiBAcGFyYW0gcnVsZXMgVGhlIHJ1bGVzIHRvIHNlYXJjaC5cclxuICAgICAqIEBwYXJlbSBydWxlIFRoZSBydWxlIHRvIGZpbmQuXHJcbiAgICAgKi9cclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLnByb3RvdHlwZS5ydWxlRXhpc3RzID0gZnVuY3Rpb24gKHJ1bGVzLCBydWxlKSB7XHJcbiAgICAgICAgdmFyIGkgPSBydWxlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBpZiAocnVsZXNbaV0uaW5kZXhPZihydWxlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTdGFuZGFyZFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChydWxlLCBvYmplY3QsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBydWxlLm1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlUHJvdmlkZXIuZ2V0TWVzc2FnZShydWxlLm1lc3NhZ2VLZXkpO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItY29uc3RcclxuICAgICAgICB2YXIgX2EgPSBydWxlLnByb3BlcnR5LCBwcm9wZXJ0eU5hbWUgPSBfYS5uYW1lLCBkaXNwbGF5TmFtZSA9IF9hLmRpc3BsYXlOYW1lO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheU5hbWUgPSB0aGlzLm1lc3NhZ2VQcm92aWRlci5nZXREaXNwbGF5TmFtZShwcm9wZXJ0eU5hbWUsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG92ZXJyaWRlQ29udGV4dCA9IHtcclxuICAgICAgICAgICAgJGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcclxuICAgICAgICAgICAgJHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxyXG4gICAgICAgICAgICAkdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAkb2JqZWN0OiBvYmplY3QsXHJcbiAgICAgICAgICAgICRjb25maWc6IHJ1bGUuY29uZmlnLFxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBuYW1lIG9mIGEgZ2l2ZW4gcHJvcGVydHksIGdpdmVuIGp1c3QgdGhlIHByb3BlcnR5IG5hbWUgKGlycmVzcGVjdGl2ZSBvZiB0aGUgcHJvcGVydHkncyBkaXNwbGF5TmFtZSlcclxuICAgICAgICAgICAgLy8gc3BsaXQgb24gY2FwaXRhbCBsZXR0ZXJzLCBmaXJzdCBsZXR0ZXIgZW5zdXJlZCB0byBiZSBjYXBpdGFsaXplZFxyXG4gICAgICAgICAgICAkZ2V0RGlzcGxheU5hbWU6IHRoaXMuZ2V0RGlzcGxheU5hbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLmV2YWx1YXRlKHsgYmluZGluZ0NvbnRleHQ6IG9iamVjdCwgb3ZlcnJpZGVDb250ZXh0OiBvdmVycmlkZUNvbnRleHQgfSwgdGhpcy5sb29rdXBGdW5jdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVJ1bGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5TmFtZSwgcnVsZVNlcXVlbmNlLCBzZXF1ZW5jZSwgcmVzdWx0cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYXJlIHdlIHZhbGlkYXRpbmcgYWxsIHByb3BlcnRpZXMgb3IgYSBzaW5nbGUgcHJvcGVydHk/XHJcbiAgICAgICAgdmFyIHZhbGlkYXRlQWxsUHJvcGVydGllcyA9IHByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCBwcm9wZXJ0eU5hbWUgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgcnVsZXMgPSBydWxlU2VxdWVuY2Vbc2VxdWVuY2VdO1xyXG4gICAgICAgIHZhciBhbGxWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgLy8gdmFsaWRhdGUgZWFjaCBydWxlLlxyXG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcclxuICAgICAgICAgICAgLy8gaXMgdGhlIHJ1bGUgcmVsYXRlZCB0byB0aGUgcHJvcGVydHkgd2UncmUgdmFsaWRhdGluZy5cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHMgfCBVc2UgbG9vc2UgZXF1YWxpdHkgZm9yIHByb3BlcnR5IGtleXNcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbFByb3BlcnRpZXMgJiYgcnVsZS5wcm9wZXJ0eS5uYW1lICE9IHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpcyB0aGlzIGEgY29uZGl0aW9uYWwgcnVsZT8gaXMgdGhlIGNvbmRpdGlvbiBtZXQ/XHJcbiAgICAgICAgICAgIGlmIChydWxlLndoZW4gJiYgIXJ1bGUud2hlbihvYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlLlxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBydWxlLnByb3BlcnR5Lm5hbWUgPT09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbcnVsZS5wcm9wZXJ0eS5uYW1lXTtcclxuICAgICAgICAgICAgdmFyIHByb21pc2VPckJvb2xlYW4gPSBydWxlLmNvbmRpdGlvbih2YWx1ZSwgb2JqZWN0KTtcclxuICAgICAgICAgICAgaWYgKCEocHJvbWlzZU9yQm9vbGVhbiBpbnN0YW5jZW9mIFByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlT3JCb29sZWFuID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VPckJvb2xlYW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZU9yQm9vbGVhbi50aGVuKGZ1bmN0aW9uICh2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB2YWxpZCA/IG51bGwgOiBfdGhpcy5nZXRNZXNzYWdlKHJ1bGUsIG9iamVjdCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWYWxpZGF0ZVJlc3VsdChydWxlLCBvYmplY3QsIHJ1bGUucHJvcGVydHkubmFtZSwgdmFsaWQsIG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIGFsbFZhbGlkID0gYWxsVmFsaWQgJiYgdmFsaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2xvb3BfMShpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlcXVlbmNlKys7XHJcbiAgICAgICAgICAgIGlmIChhbGxWYWxpZCAmJiBzZXF1ZW5jZSA8IHJ1bGVTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy52YWxpZGF0ZVJ1bGVTZXF1ZW5jZShvYmplY3QsIHByb3BlcnR5TmFtZSwgcnVsZVNlcXVlbmNlLCBzZXF1ZW5jZSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHlOYW1lLCBydWxlcykge1xyXG4gICAgICAgIC8vIHJ1bGVzIHNwZWNpZmllZD9cclxuICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgIC8vIG5vLiBhdHRlbXB0IHRvIGxvY2F0ZSB0aGUgcnVsZXMuXHJcbiAgICAgICAgICAgIHJ1bGVzID0gUnVsZXMuZ2V0KG9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFueSBydWxlcz9cclxuICAgICAgICBpZiAoIXJ1bGVzIHx8IHJ1bGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVSdWxlU2VxdWVuY2Uob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHJ1bGVzLCAwLCBbXSk7XHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRWYWxpZGF0b3IuaW5qZWN0ID0gW1ZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIsIFZpZXdSZXNvdXJjZXNdO1xyXG4gICAgcmV0dXJuIFN0YW5kYXJkVmFsaWRhdG9yO1xyXG59KFZhbGlkYXRvcikpO1xuXG4vKipcclxuICogUGFydCBvZiB0aGUgZmx1ZW50IHJ1bGUgQVBJLiBFbmFibGVzIGN1c3RvbWl6aW5nIHByb3BlcnR5IHJ1bGVzLlxyXG4gKi9cclxudmFyIEZsdWVudFJ1bGVDdXN0b21pemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmx1ZW50UnVsZUN1c3RvbWl6ZXIocHJvcGVydHksIGNvbmRpdGlvbiwgY29uZmlnLCBmbHVlbnRFbnN1cmUsIGZsdWVudFJ1bGVzLCBwYXJzZXJzKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XHJcbiAgICAgICAgdGhpcy5mbHVlbnRFbnN1cmUgPSBmbHVlbnRFbnN1cmU7XHJcbiAgICAgICAgdGhpcy5mbHVlbnRSdWxlcyA9IGZsdWVudFJ1bGVzO1xyXG4gICAgICAgIHRoaXMucGFyc2VycyA9IHBhcnNlcnM7XHJcbiAgICAgICAgdGhpcy5ydWxlID0ge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxyXG4gICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcclxuICAgICAgICAgICAgd2hlbjogbnVsbCxcclxuICAgICAgICAgICAgbWVzc2FnZUtleTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsLFxyXG4gICAgICAgICAgICBzZXF1ZW5jZTogZmx1ZW50UnVsZXMuc2VxdWVuY2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZmx1ZW50RW5zdXJlLl9hZGRSdWxlKHRoaXMucnVsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHN1YnNlcXVlbnQgcnVsZXMgYWZ0ZXIgcHJldmlvdXNseSBkZWNsYXJlZCBydWxlcyBoYXZlXHJcbiAgICAgKiBiZWVuIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHkuIFVzZSB0byBwb3N0cG9uZSB2YWxpZGF0aW9uIG9mIGNvc3RseVxyXG4gICAgICogcnVsZXMgdW50aWwgbGVzcyBleHBlbnNpdmUgcnVsZXMgcGFzcyB2YWxpZGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZsdWVudFJ1bGVzLnNlcXVlbmNlKys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGtleSB0byB1c2Ugd2hlbiBsb29raW5nIHVwIHRoZSBydWxlJ3MgdmFsaWRhdGlvbiBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUud2l0aE1lc3NhZ2VLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5ydWxlLm1lc3NhZ2VLZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5ydWxlLm1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHJ1bGUncyB2YWxpZGF0aW9uIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS53aXRoTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlLm1lc3NhZ2VLZXkgPSAnY3VzdG9tJztcclxuICAgICAgICB0aGlzLnJ1bGUubWVzc2FnZSA9IHRoaXMucGFyc2Vycy5tZXNzYWdlLnBhcnNlKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGEgY29uZGl0aW9uIHRoYXQgbXVzdCBiZSBtZXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgdGhlIHJ1bGUuXHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdHJ1ZVxyXG4gICAgICogb3IgZmFsc2Ugd2hldGhlciB0aGUgcnVsZSBzaG91bGQgYmUgZXZhbHVhdGVkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcclxuICAgICAgICB0aGlzLnJ1bGUud2hlbiA9IGNvbmRpdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRhZ3MgdGhlIHJ1bGUgaW5zdGFuY2UsIGVuYWJsaW5nIHRoZSBydWxlIHRvIGJlIGZvdW5kIGVhc2lseVxyXG4gICAgICogdXNpbmcgVmFsaWRhdGlvblJ1bGVzLnRhZ2dlZFJ1bGVzKHJ1bGVzLCB0YWcpXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS50YWcgPSBmdW5jdGlvbiAodGFnKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlLnRhZyA9IHRhZztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvLy8vLyBGbHVlbnRFbnN1cmUgQVBJcyAvLy8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYXJnZXQgYSBwcm9wZXJ0eSB3aXRoIHZhbGlkYXRpb24gcnVsZXMuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIHRhcmdldC4gQ2FuIGJlIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbiAoc3ViamVjdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudEVuc3VyZS5lbnN1cmUoc3ViamVjdCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYXJnZXRzIGFuIG9iamVjdCB3aXRoIHZhbGlkYXRpb24gcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5lbnN1cmVPYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50RW5zdXJlLmVuc3VyZU9iamVjdCgpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUsIFwicnVsZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJ1bGVzIHRoYXQgaGF2ZSBiZWVuIGRlZmluZWQgdXNpbmcgdGhlIGZsdWVudCBBUEkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdWVudEVuc3VyZS5ydWxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcnVsZXMgdG8gYSBjbGFzcyBvciBvYmplY3QsIG1ha2luZyB0aGVtIGRpc2NvdmVyYWJsZSBieSB0aGUgU3RhbmRhcmRWYWxpZGF0b3IuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgY2xhc3Mgb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50RW5zdXJlLm9uKHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgLy8vLy8vLy8vIEZsdWVudFJ1bGVzIEFQSXMgLy8vLy8vLy8vXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYW4gYWQtaG9jIHJ1bGUgZnVuY3Rpb24gdG8gdGhlIGVuc3VyZWQgcHJvcGVydHkgb3Igb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgZnVuY3Rpb24gdG8gdmFsaWRhdGUgdGhlIHJ1bGUuXHJcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhbmQgdGhlIG9iamVjdC5cclxuICAgICAqIFNob3VsZCByZXR1cm4gYSBib29sZWFuIG9yIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbi5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLnNhdGlzZmllcyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLnNhdGlzZmllcyhjb25kaXRpb24sIGNvbmZpZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgcnVsZSBieSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBvciBzdGFuZGFyZCBydWxlLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIHJ1bGUncyBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5zYXRpc2ZpZXNSdWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5mbHVlbnRSdWxlcykuc2F0aXNmaWVzUnVsZS5hcHBseShfYSwgW25hbWVdLmNvbmNhdChhcmdzKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcInJlcXVpcmVkXCIgcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBUaGUgdmFsdWUgY2Fubm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciB3aGl0ZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMucmVxdWlyZWQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWF0Y2hlc1wiIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVmFsdWUgbXVzdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAocmVnZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5tYXRjaGVzKHJlZ2V4KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiZW1haWxcIiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLmVtYWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLmVtYWlsKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1pbkxlbmd0aFwiIFNUUklORyB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUubWluTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLm1pbkxlbmd0aChsZW5ndGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtYXhMZW5ndGhcIiBTVFJJTkcgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1heExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5tYXhMZW5ndGgobGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWluSXRlbXNcIiBBUlJBWSB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1pbkl0ZW1zID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMubWluSXRlbXMoY291bnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtYXhJdGVtc1wiIEFSUkFZIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUubWF4SXRlbXMgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5tYXhJdGVtcyhjb3VudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1pblwiIE5VTUJFUiB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBjb25zdHJhaW50LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLm1pbih2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1heFwiIE5VTUJFUiB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVmFsdWUgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBjb25zdHJhaW50LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLm1heCh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcInJhbmdlXCIgTlVNQkVSIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtaW4gYW5kIG1heC5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLnJhbmdlKG1pbiwgbWF4KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiYmV0d2VlblwiIE5VTUJFUiB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIGJ1dCBub3QgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtaW4gYW5kIG1heC5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5iZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMuYmV0d2VlbihtaW4sIG1heCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcImVxdWFsc1wiIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoZXhwZWN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLmVxdWFscyhleHBlY3RlZFZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmx1ZW50UnVsZUN1c3RvbWl6ZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBQYXJ0IG9mIHRoZSBmbHVlbnQgcnVsZSBBUEkuIEVuYWJsZXMgYXBwbHlpbmcgcnVsZXMgdG8gcHJvcGVydGllcyBhbmQgb2JqZWN0cy5cclxuICovXHJcbnZhciBGbHVlbnRSdWxlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZsdWVudFJ1bGVzKGZsdWVudEVuc3VyZSwgcGFyc2VycywgcHJvcGVydHkpIHtcclxuICAgICAgICB0aGlzLmZsdWVudEVuc3VyZSA9IGZsdWVudEVuc3VyZTtcclxuICAgICAgICB0aGlzLnBhcnNlcnMgPSBwYXJzZXJzO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHJ1bGUgc2VxdWVuY2UgbnVtYmVyLiBVc2VkIHRvIHBvc3Rwb25lIGV2YWx1YXRpb24gb2YgcnVsZXMgdW50aWwgcnVsZXNcclxuICAgICAgICAgKiB3aXRoIGxvd2VyIHNlcXVlbmNlIG51bWJlciBoYXZlIHN1Y2Nlc3NmdWxseSB2YWxpZGF0ZWQuIFRoZSBcInRoZW5cIiBmbHVlbnQgQVBJIG1ldGhvZFxyXG4gICAgICAgICAqIG1hbmFnZXMgdGhpcyBwcm9wZXJ0eSwgdGhlcmUncyB1c3VhbGx5IG5vIG5lZWQgdG8gc2V0IGl0IGRpcmVjdGx5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2UgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGVuc3VyZWQgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eS5kaXNwbGF5TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGFuIGFkLWhvYyBydWxlIGZ1bmN0aW9uIHRvIHRoZSBlbnN1cmVkIHByb3BlcnR5IG9yIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gVGhlIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIHRoZSBydWxlLlxyXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgcHJvcGVydHkgdmFsdWUgYW5kIHRoZSBvYmplY3QuXHJcbiAgICAgKiBTaG91bGQgcmV0dXJuIGEgYm9vbGVhbiBvciBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4uXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5zYXRpc2ZpZXMgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBjb25maWcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZsdWVudFJ1bGVDdXN0b21pemVyKHRoaXMucHJvcGVydHksIGNvbmRpdGlvbiwgY29uZmlnLCB0aGlzLmZsdWVudEVuc3VyZSwgdGhpcywgdGhpcy5wYXJzZXJzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBydWxlIGJ5IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIG9yIHN0YW5kYXJkIHJ1bGUuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBUaGUgcnVsZSdzIGFyZ3VtZW50cy5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLnNhdGlzZmllc1J1bGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcnVsZSA9IEZsdWVudFJ1bGVzLmN1c3RvbVJ1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghcnVsZSkge1xyXG4gICAgICAgICAgICAvLyBzdGFuZGFyZCBydWxlP1xyXG4gICAgICAgICAgICBydWxlID0gdGhpc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuY2FsbC5hcHBseShydWxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlIHdpdGggbmFtZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGRvZXMgbm90IGV4aXN0LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJ1bGUuYXJnc1RvQ29uZmlnID8gcnVsZS5hcmdzVG9Db25maWcuYXBwbHkocnVsZSwgYXJncykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSwgb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHJ1bGUuY29uZGl0aW9uKS5jYWxsLmFwcGx5KF9hLCBbX3RoaXMsIHZhbHVlLCBvYmpdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfSwgY29uZmlnKVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcInJlcXVpcmVkXCIgcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBUaGUgdmFsdWUgY2Fubm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciB3aGl0ZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGxcclxuICAgICAgICAgICAgICAgICYmIHZhbHVlICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICYmICEoaXNTdHJpbmcodmFsdWUpICYmICEvXFxTLy50ZXN0KHZhbHVlKSk7XHJcbiAgICAgICAgfSkud2l0aE1lc3NhZ2VLZXkoJ3JlcXVpcmVkJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1hdGNoZXNcIiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIFZhbHVlIG11c3QgbWF0Y2ggdGhlIHNwZWNpZmllZCByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHJlZ2V4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDAgfHwgcmVnZXgudGVzdCh2YWx1ZSk7IH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWF0Y2hlcycpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJlbWFpbFwiIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuZW1haWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcmVnZXggZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXHJcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcygvXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLylcclxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cclxuICAgICAgICAgICAgLndpdGhNZXNzYWdlS2V5KCdlbWFpbCcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtaW5MZW5ndGhcIiBTVFJJTkcgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXRpc2ZpZXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB2YWx1ZS5sZW5ndGggPj0gbGVuZ3RoOyB9LCB7IGxlbmd0aDogbGVuZ3RoIH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWluTGVuZ3RoJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1heExlbmd0aFwiIFNUUklORyB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUubWF4TGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8IHZhbHVlLmxlbmd0aCA8PSBsZW5ndGg7IH0sIHsgbGVuZ3RoOiBsZW5ndGggfSlcclxuICAgICAgICAgICAgLndpdGhNZXNzYWdlS2V5KCdtYXhMZW5ndGgnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWluSXRlbXNcIiBBUlJBWSB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLm1pbkl0ZW1zID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPj0gY291bnQ7IH0sIHsgY291bnQ6IGNvdW50IH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWluSXRlbXMnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWF4SXRlbXNcIiBBUlJBWSB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLm1heEl0ZW1zID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPD0gY291bnQ7IH0sIHsgY291bnQ6IGNvdW50IH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWF4SXRlbXMnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWluXCIgTlVNQkVSIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBWYWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXRpc2ZpZXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID49IGNvbnN0cmFpbnQ7IH0sIHsgY29uc3RyYWludDogY29uc3RyYWludCB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ21pbicpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtYXhcIiBOVU1CRVIgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIFZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgY29uc3RyYWludC5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPD0gY29uc3RyYWludDsgfSwgeyBjb25zdHJhaW50OiBjb25zdHJhaW50IH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWF4Jyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcInJhbmdlXCIgTlVNQkVSIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtaW4gYW5kIG1heC5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXgpOyB9LCB7IG1pbjogbWluLCBtYXg6IG1heCB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ3JhbmdlJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcImJldHdlZW5cIiBOVU1CRVIgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIFZhbHVlIG11c3QgYmUgYmV0d2VlbiBidXQgbm90IGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWluIGFuZCBtYXguXHJcbiAgICAgKiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuYmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlID4gbWluICYmIHZhbHVlIDwgbWF4KTsgfSwgeyBtaW46IG1pbiwgbWF4OiBtYXggfSlcclxuICAgICAgICAgICAgLndpdGhNZXNzYWdlS2V5KCdiZXR3ZWVuJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcImVxdWFsc1wiIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGV4cGVjdGVkVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXRpc2ZpZXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZTsgfSwgeyBleHBlY3RlZFZhbHVlOiBleHBlY3RlZFZhbHVlIH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnZXF1YWxzJyk7XHJcbiAgICB9O1xyXG4gICAgRmx1ZW50UnVsZXMuY3VzdG9tUnVsZXMgPSB7fTtcclxuICAgIHJldHVybiBGbHVlbnRSdWxlcztcclxufSgpKTtcclxuLyoqXHJcbiAqIFBhcnQgb2YgdGhlIGZsdWVudCBydWxlIEFQSS4gRW5hYmxlcyB0YXJnZXRpbmcgcHJvcGVydGllcyBhbmQgb2JqZWN0cyB3aXRoIHJ1bGVzLlxyXG4gKi9cclxudmFyIEZsdWVudEVuc3VyZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZsdWVudEVuc3VyZShwYXJzZXJzKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gcGFyc2VycztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSdWxlcyB0aGF0IGhhdmUgYmVlbiBkZWZpbmVkIHVzaW5nIHRoZSBmbHVlbnQgQVBJLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucnVsZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0IGEgcHJvcGVydHkgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byB0YXJnZXQuIENhbiBiZSB0aGUgcHJvcGVydHkgbmFtZSBvciBhIHByb3BlcnR5IGFjY2Vzc29yXHJcbiAgICAgKiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEluaXRpYWxpemVkKCk7XHJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlcnMucHJvcGVydHkucGFyc2UocHJvcGVydHkpO1xyXG4gICAgICAgIHZhciBmbHVlbnRSdWxlcyA9IG5ldyBGbHVlbnRSdWxlcyh0aGlzLCB0aGlzLnBhcnNlcnMsIHsgbmFtZTogbmFtZSwgZGlzcGxheU5hbWU6IG51bGwgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VSdWxlcyhmbHVlbnRSdWxlcywgbmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYXJnZXRzIGFuIG9iamVjdCB3aXRoIHZhbGlkYXRpb24gcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudEVuc3VyZS5wcm90b3R5cGUuZW5zdXJlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICB2YXIgZmx1ZW50UnVsZXMgPSBuZXcgRmx1ZW50UnVsZXModGhpcywgdGhpcy5wYXJzZXJzLCB7IG5hbWU6IG51bGwsIGRpc3BsYXlOYW1lOiBudWxsIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlUnVsZXMoZmx1ZW50UnVsZXMsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcnVsZXMgdG8gYSBjbGFzcyBvciBvYmplY3QsIG1ha2luZyB0aGVtIGRpc2NvdmVyYWJsZSBieSB0aGUgU3RhbmRhcmRWYWxpZGF0b3IuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgY2xhc3Mgb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRFbnN1cmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIFJ1bGVzLnNldCh0YXJnZXQsIHRoaXMucnVsZXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJ1bGUgZGVmaW5pdGlvbiB0byB0aGUgc2VxdWVuY2VkIHJ1bGVzZXQuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5fYWRkUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucnVsZXMubGVuZ3RoIDwgcnVsZS5zZXF1ZW5jZSArIDEpIHtcclxuICAgICAgICAgICAgdGhpcy5ydWxlcy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ydWxlc1tydWxlLnNlcXVlbmNlXS5wdXNoKHJ1bGUpO1xyXG4gICAgfTtcclxuICAgIEZsdWVudEVuc3VyZS5wcm90b3R5cGUuYXNzZXJ0SW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyc2Vycykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCB5b3UgZm9yZ2V0IHRvIGFkZCBcXFwiLnBsdWdpbignYXVyZWxpYS12YWxpZGF0aW9uJylcXFwiIHRvIHlvdXIgbWFpbi5qcz9cIik7XHJcbiAgICB9O1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5tZXJnZVJ1bGVzID0gZnVuY3Rpb24gKGZsdWVudFJ1bGVzLCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFscyB8IFVzZSBsb29zZSBlcXVhbGl0eSBmb3IgcHJvcGVydHkga2V5c1xyXG4gICAgICAgIHZhciBleGlzdGluZ1J1bGVzID0gdGhpcy5ydWxlcy5maW5kKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmxlbmd0aCA+IDAgJiYgclswXS5wcm9wZXJ0eS5uYW1lID09IHByb3BlcnR5TmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUnVsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBleGlzdGluZ1J1bGVzW2V4aXN0aW5nUnVsZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGZsdWVudFJ1bGVzLnNlcXVlbmNlID0gcnVsZS5zZXF1ZW5jZTtcclxuICAgICAgICAgICAgaWYgKHJ1bGUucHJvcGVydHkuZGlzcGxheU5hbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZsdWVudFJ1bGVzID0gZmx1ZW50UnVsZXMuZGlzcGxheU5hbWUocnVsZS5wcm9wZXJ0eS5kaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZsdWVudFJ1bGVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGbHVlbnRFbnN1cmU7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBGbHVlbnQgcnVsZSBkZWZpbml0aW9uIEFQSS5cclxuICovXHJcbnZhciBWYWxpZGF0aW9uUnVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uUnVsZXMoKSB7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0aW9uUnVsZXMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChtZXNzYWdlUGFyc2VyLCBwcm9wZXJ0eVBhcnNlcikge1xyXG4gICAgICAgIHRoaXMucGFyc2VycyA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVBhcnNlcixcclxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5UGFyc2VyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRhcmdldCBhIHByb3BlcnR5IHdpdGggdmFsaWRhdGlvbiBydWxlcy5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gdGFyZ2V0LiBDYW4gYmUgdGhlIHByb3BlcnR5IG5hbWUgb3IgYSBwcm9wZXJ0eSBhY2Nlc3NvciBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmVuc3VyZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmx1ZW50RW5zdXJlKFZhbGlkYXRpb25SdWxlcy5wYXJzZXJzKS5lbnN1cmUocHJvcGVydHkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0cyBhbiBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uUnVsZXMuZW5zdXJlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmx1ZW50RW5zdXJlKFZhbGlkYXRpb25SdWxlcy5wYXJzZXJzKS5lbnN1cmVPYmplY3QoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBjdXN0b20gcnVsZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gcnVsZS4gQWxzbyBzZXJ2ZXMgYXMgdGhlIG1lc3NhZ2Uga2V5LlxyXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgcnVsZSBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGV4cHJlc3Npb25cclxuICAgICAqIEBwYXJhbSBhcmdzVG9Db25maWcgQSBmdW5jdGlvbiB0aGF0IG1hcHMgdGhlIHJ1bGUncyBhcmd1bWVudHMgdG8gYSBcImNvbmZpZ1wiXHJcbiAgICAgKiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIGV2YWx1YXRpbmcgdGhlIG1lc3NhZ2UgZXhwcmVzc2lvbi5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmN1c3RvbVJ1bGUgPSBmdW5jdGlvbiAobmFtZSwgY29uZGl0aW9uLCBtZXNzYWdlLCBhcmdzVG9Db25maWcpIHtcclxuICAgICAgICB2YWxpZGF0aW9uTWVzc2FnZXNbbmFtZV0gPSBtZXNzYWdlO1xyXG4gICAgICAgIEZsdWVudFJ1bGVzLmN1c3RvbVJ1bGVzW25hbWVdID0geyBjb25kaXRpb246IGNvbmRpdGlvbiwgYXJnc1RvQ29uZmlnOiBhcmdzVG9Db25maWcgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcnVsZXMgd2l0aCB0aGUgbWF0Y2hpbmcgdGFnLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIFRoZSBydWxlcyB0byBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLnRhZ2dlZFJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzLCB0YWcpIHtcclxuICAgICAgICByZXR1cm4gcnVsZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50YWcgPT09IHRhZzsgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBydWxlcyB0aGF0IGhhdmUgbm8gdGFnLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIFRoZSBydWxlcyB0byBzZWFyY2guXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25SdWxlcy51bnRhZ2dlZFJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudGFnID09PSB1bmRlZmluZWQ7IH0pOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHJ1bGVzIGZyb20gYSBjbGFzcyBvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgY2xhc3Mgb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uUnVsZXMub2ZmID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIFJ1bGVzLnVuc2V0KHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25SdWxlcztcclxufSgpKTtcblxuLy8gRXhwb3J0c1xyXG4vKipcclxuICogQXVyZWxpYSBWYWxpZGF0aW9uIENvbmZpZ3VyYXRpb24gQVBJXHJcbiAqL1xyXG52YXIgQXVyZWxpYVZhbGlkYXRpb25Db25maWd1cmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXVyZWxpYVZhbGlkYXRpb25Db25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yVHlwZSA9IFN0YW5kYXJkVmFsaWRhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgYSBjdXN0b20gVmFsaWRhdG9yIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBBdXJlbGlhVmFsaWRhdGlvbkNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmN1c3RvbVZhbGlkYXRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3JUeXBlID0gdHlwZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IGNvbnRhaW5lci5nZXQodGhpcy52YWxpZGF0b3JUeXBlKTtcclxuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJJbnN0YW5jZShWYWxpZGF0b3IsIHZhbGlkYXRvcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbjtcclxufSgpKTtcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgdGhlIHBsdWdpbi5cclxuICovXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZShcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xyXG5mcmFtZXdvcmtDb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICAvLyB0aGUgZmx1ZW50IHJ1bGUgZGVmaW5pdGlvbiBBUEkgbmVlZHMgdGhlIHBhcnNlciB0byB0cmFuc2xhdGUgbWVzc2FnZXNcclxuICAgIC8vIHRvIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMuXHJcbiAgICB2YXIgbWVzc2FnZVBhcnNlciA9IGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIuZ2V0KFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyKTtcclxuICAgIHZhciBwcm9wZXJ0eVBhcnNlciA9IGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIuZ2V0KFByb3BlcnR5QWNjZXNzb3JQYXJzZXIpO1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmluaXRpYWxpemUobWVzc2FnZVBhcnNlciwgcHJvcGVydHlQYXJzZXIpO1xyXG4gICAgLy8gY29uZmlndXJlLi4uXHJcbiAgICB2YXIgY29uZmlnID0gbmV3IEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbigpO1xyXG4gICAgaWYgKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICBjYWxsYmFjayhjb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uZmlnLmFwcGx5KGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIpO1xyXG4gICAgLy8gZ2xvYmFsaXplIHRoZSBiZWhhdmlvcnMuXHJcbiAgICBpZiAoZnJhbWV3b3JrQ29uZmlnLmdsb2JhbFJlc291cmNlcykge1xyXG4gICAgICAgIGZyYW1ld29ya0NvbmZpZy5nbG9iYWxSZXNvdXJjZXMoVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLCBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbiwgY29uZmlndXJlLCBnZXRUYXJnZXRET01FbGVtZW50LCBnZXRQcm9wZXJ0eUluZm8sIFByb3BlcnR5QWNjZXNzb3JQYXJzZXIsIGdldEFjY2Vzc29yRXhwcmVzc2lvbiwgVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZUV2ZW50LCBWYWxpZGF0ZVJlc3VsdCwgdmFsaWRhdGVUcmlnZ2VyLCBWYWxpZGF0aW9uQ29udHJvbGxlciwgVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5LCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLCBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUsIFZhbGlkYXRvciwgUnVsZXMsIFN0YW5kYXJkVmFsaWRhdG9yLCB2YWxpZGF0aW9uTWVzc2FnZXMsIFZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIsIFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyLCBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvciwgRmx1ZW50UnVsZUN1c3RvbWl6ZXIsIEZsdWVudFJ1bGVzLCBGbHVlbnRFbnN1cmUsIFZhbGlkYXRpb25SdWxlcyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-validation\n");

/***/ })

}]);