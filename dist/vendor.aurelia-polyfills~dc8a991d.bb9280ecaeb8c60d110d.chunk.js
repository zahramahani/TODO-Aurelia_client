(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-polyfills~dc8a991d"],{

/***/ "Q/5p":
/*!*********************************************************************************!*\
  !*** ./node_modules/aurelia-polyfills/dist/native-modules/aurelia-polyfills.js ***!
  \*********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (Object, GOPS) {\n    'use strict';\n\n    if (GOPS in Object) return;\n\n    var setDescriptor,\n        G = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global,\n        id = 0,\n        random = '' + Math.random(),\n        prefix = '__\\x01symbol:',\n        prefixLength = prefix.length,\n        internalSymbol = '__\\x01symbol@@' + random,\n        DP = 'defineProperty',\n        DPies = 'defineProperties',\n        GOPN = 'getOwnPropertyNames',\n        GOPD = 'getOwnPropertyDescriptor',\n        PIE = 'propertyIsEnumerable',\n        gOPN = Object[GOPN],\n        gOPD = Object[GOPD],\n        create = Object.create,\n        keys = Object.keys,\n        defineProperty = Object[DP],\n        $defineProperties = Object[DPies],\n        descriptor = gOPD(Object, GOPN),\n        ObjectProto = Object.prototype,\n        hOP = ObjectProto.hasOwnProperty,\n        pIE = ObjectProto[PIE],\n        toString = ObjectProto.toString,\n        indexOf = Array.prototype.indexOf || function (v) {\n      for (var i = this.length; i-- && this[i] !== v;) {}\n      return i;\n    },\n        addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {\n      if (!hOP.call(o, internalSymbol)) {\n        defineProperty(o, internalSymbol, {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: {}\n        });\n      }\n      o[internalSymbol]['@@' + uid] = enumerable;\n    },\n        createWithSymbols = function createWithSymbols(proto, descriptors) {\n      var self = create(proto);\n      if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {\n        gOPN(descriptors).forEach(function (key) {\n          if (propertyIsEnumerable.call(descriptors, key)) {\n            $defineProperty(self, key, descriptors[key]);\n          }\n        });\n      }\n      return self;\n    },\n        copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {\n      var newDescriptor = create(descriptor);\n      newDescriptor.enumerable = false;\n      return newDescriptor;\n    },\n        get = function get() {},\n        onlyNonSymbols = function onlyNonSymbols(name) {\n      return name != internalSymbol && !hOP.call(source, name);\n    },\n        onlySymbols = function onlySymbols(name) {\n      return name != internalSymbol && hOP.call(source, name);\n    },\n        propertyIsEnumerable = function propertyIsEnumerable(key) {\n      var uid = '' + key;\n      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);\n    },\n        setAndGetSymbol = function setAndGetSymbol(uid) {\n      var descriptor = {\n        enumerable: false,\n        configurable: true,\n        get: get,\n        set: function set(value) {\n          setDescriptor(this, uid, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n          addInternalIfNeeded(this, uid, true);\n        }\n      };\n      defineProperty(ObjectProto, uid, descriptor);\n      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);\n    },\n        _Symbol = function _Symbol2(description) {\n      if (this && this !== G) {\n        throw new TypeError('Symbol is not a constructor');\n      }\n      return setAndGetSymbol(prefix.concat(description || '', random, ++id));\n    },\n        source = create(null),\n        sourceConstructor = { value: _Symbol },\n        sourceMap = function sourceMap(uid) {\n      return source[uid];\n    },\n        $defineProperty = function defineProp(o, key, descriptor) {\n      var uid = '' + key;\n      if (onlySymbols(uid)) {\n        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);\n        addInternalIfNeeded(o, uid, !!descriptor.enumerable);\n      } else {\n        defineProperty(o, key, descriptor);\n      }\n      return o;\n    },\n        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n      var cof = toString.call(o);\n      o = cof === '[object String]' ? o.split('') : Object(o);\n      return gOPN(o).filter(onlySymbols).map(sourceMap);\n    };\n\n    descriptor.value = $defineProperty;\n    defineProperty(Object, DP, descriptor);\n\n    descriptor.value = $getOwnPropertySymbols;\n    defineProperty(Object, GOPS, descriptor);\n\n    var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];\n    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n    descriptor.value = function getOwnPropertyNames(o) {\n      if (toString.call(o) === '[object Window]') {\n        try {\n          return originalObjectGetOwnPropertyNames(o);\n        } catch (e) {\n          return [].concat([], cachedWindowNames);\n        }\n      }\n      return gOPN(o).filter(onlyNonSymbols);\n    };\n    defineProperty(Object, GOPN, descriptor);\n\n    descriptor.value = function defineProperties(o, descriptors) {\n      var symbols = $getOwnPropertySymbols(descriptors);\n      if (symbols.length) {\n        keys(descriptors).concat(symbols).forEach(function (uid) {\n          if (propertyIsEnumerable.call(descriptors, uid)) {\n            $defineProperty(o, uid, descriptors[uid]);\n          }\n        });\n      } else {\n        $defineProperties(o, descriptors);\n      }\n      return o;\n    };\n    defineProperty(Object, DPies, descriptor);\n\n    descriptor.value = propertyIsEnumerable;\n    defineProperty(ObjectProto, PIE, descriptor);\n\n    descriptor.value = _Symbol;\n    defineProperty(G, 'Symbol', descriptor);\n\n    descriptor.value = function (key) {\n      var uid = prefix.concat(prefix, key, random);\n      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\n    };\n    defineProperty(_Symbol, 'for', descriptor);\n\n    descriptor.value = function (symbol) {\n      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;\n    };\n    defineProperty(_Symbol, 'keyFor', descriptor);\n\n    descriptor.value = function getOwnPropertyDescriptor(o, key) {\n      var descriptor = gOPD(o, key);\n      if (descriptor && onlySymbols(key)) {\n        descriptor.enumerable = propertyIsEnumerable.call(o, key);\n      }\n      return descriptor;\n    };\n    defineProperty(Object, GOPD, descriptor);\n\n    descriptor.value = function (proto, descriptors) {\n      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);\n    };\n    defineProperty(Object, 'create', descriptor);\n\n    descriptor.value = function () {\n      var str = toString.call(this);\n      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;\n    };\n    defineProperty(ObjectProto, 'toString', descriptor);\n\n    try {\n      setDescriptor = create(defineProperty({}, prefix, {\n        get: function get() {\n          return defineProperty(this, prefix, { value: false })[prefix];\n        }\n      }))[prefix] || defineProperty;\n    } catch (o_O) {\n      setDescriptor = function setDescriptor(o, key, descriptor) {\n        var protoDescriptor = gOPD(ObjectProto, key);\n        delete ObjectProto[key];\n        defineProperty(o, key, descriptor);\n        defineProperty(ObjectProto, key, protoDescriptor);\n      };\n    }\n  })(Object, 'getOwnPropertySymbols');\n\n  (function (O, S) {\n    var dP = O.defineProperty,\n        ObjectProto = O.prototype,\n        toString = ObjectProto.toString,\n        toStringTag = 'toStringTag',\n        descriptor;\n    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {\n      if (!(name in Symbol)) {\n        dP(Symbol, name, { value: Symbol(name) });\n        switch (name) {\n          case toStringTag:\n            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');\n            descriptor.value = function () {\n              var str = toString.call(this),\n                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];\n              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';\n            };\n            dP(ObjectProto, 'toString', descriptor);\n            break;\n        }\n      }\n    });\n  })(Object, Symbol);\n\n  (function (Si, AP, SP) {\n\n    function returnThis() {\n      return this;\n    }\n\n    if (!AP[Si]) AP[Si] = function () {\n      var i = 0,\n          self = this,\n          iterator = {\n        next: function next() {\n          var done = self.length <= i;\n          return done ? { done: done } : { done: done, value: self[i++] };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n\n    if (!SP[Si]) SP[Si] = function () {\n      var fromCodePoint = String.fromCodePoint,\n          self = this,\n          i = 0,\n          length = self.length,\n          iterator = {\n        next: function next() {\n          var done = length <= i,\n              c = done ? '' : fromCodePoint(self.codePointAt(i));\n          i += c.length;\n          return done ? { done: done } : { done: done, value: c };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n  })(Symbol.iterator, Array.prototype, String.prototype);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  Number.isNaN = Number.isNaN || function (value) {\n    return value !== value;\n  };\n\n  Number.isFinite = Number.isFinite || function (value) {\n    return typeof value === \"number\" && isFinite(value);\n  };\n}\n\nif (!String.prototype.endsWith || function () {\n  try {\n    return !\"ab\".endsWith(\"a\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString();\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    var lastIndex = subjectString.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n}\n\nif (!String.prototype.startsWith || function () {\n  try {\n    return !\"ab\".startsWith(\"b\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.startsWith = function (searchString, position) {\n    position = position || 0;\n    return this.substr(position, searchString.length) === searchString;\n  };\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  if (!Array.from) {\n    Array.from = function () {\n      var toInteger = function toInteger(it) {\n        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);\n      };\n      var toLength = function toLength(it) {\n        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;\n      };\n      var iterCall = function iterCall(iter, fn, val, index) {\n        try {\n          return fn(val, index);\n        } catch (E) {\n          if (typeof iter.return == 'function') iter.return();\n          throw E;\n        }\n      };\n\n      return function from(arrayLike) {\n        var O = Object(arrayLike),\n            C = typeof this == 'function' ? this : Array,\n            aLen = arguments.length,\n            mapfn = aLen > 1 ? arguments[1] : undefined,\n            mapping = mapfn !== undefined,\n            index = 0,\n            iterFn = O[Symbol.iterator],\n            length,\n            result,\n            step,\n            iterator;\n        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);\n        if (iterFn != undefined && !Array.isArray(arrayLike)) {\n          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;\n          }\n        } else {\n          length = toLength(O.length);\n          for (result = new C(length); length > index; index++) {\n            result[index] = mapping ? mapfn(O[index], index) : O[index];\n          }\n        }\n        result.length = index;\n        return result;\n      };\n    }();\n  }\n\n  if (!Array.prototype.find) {\n    Object.defineProperty(Array.prototype, 'find', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.find called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return value;\n          }\n        }\n        return undefined;\n      }\n    });\n  }\n\n  if (!Array.prototype.findIndex) {\n    Object.defineProperty(Array.prototype, 'findIndex', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.findIndex called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return i;\n          }\n        }\n        return -1;\n      }\n    });\n  }\n}\n\nif (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    value: function value(searchElement) {\n      var O = Object(this);\n      var len = parseInt(O.length) || 0;\n      if (len === 0) {\n        return false;\n      }\n      var n = parseInt(arguments[1]) || 0;\n      var k;\n      if (n >= 0) {\n        k = n;\n      } else {\n        k = len + n;\n        if (k < 0) {\n          k = 0;\n        }\n      }\n      var currentElement;\n      while (k < len) {\n        currentElement = O[k];\n        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {\n          return true;\n        }\n        k++;\n      }\n      return false;\n    }\n  });\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function () {\n    var needsFix = false;\n\n    try {\n      var s = Object.keys('a');\n      needsFix = s.length !== 1 || s[0] !== '0';\n    } catch (e) {\n      needsFix = true;\n    }\n\n    if (needsFix) {\n      Object.keys = function () {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),\n            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n            dontEnumsLength = dontEnums.length;\n\n        return function (obj) {\n          if (obj === undefined || obj === null) {\n            throw TypeError('Cannot convert undefined or null to object');\n          }\n\n          obj = Object(obj);\n\n          var result = [],\n              prop,\n              i;\n\n          for (prop in obj) {\n            if (hasOwnProperty.call(obj, prop)) {\n              result.push(prop);\n            }\n          }\n\n          if (hasDontEnumBug) {\n            for (i = 0; i < dontEnumsLength; i++) {\n              if (hasOwnProperty.call(obj, dontEnums[i])) {\n                result.push(dontEnums[i]);\n              }\n            }\n          }\n\n          return result;\n        };\n      }();\n    }\n  })();\n\n  (function (O) {\n    if ('assign' in O) {\n      return;\n    }\n\n    O.defineProperty(O, 'assign', {\n      configurable: true,\n      writable: true,\n      value: function () {\n        var gOPS = O.getOwnPropertySymbols,\n            pIE = O.propertyIsEnumerable,\n            filterOS = gOPS ? function (self) {\n          return gOPS(self).filter(pIE, self);\n        } : function () {\n          return Array.prototype;\n        };\n\n        return function assign(where) {\n          if (gOPS && !(where instanceof O)) {\n            console.warn('problematic Symbols', where);\n          }\n\n          function set(keyOrSymbol) {\n            where[keyOrSymbol] = arg[keyOrSymbol];\n          }\n\n          for (var i = 1, ii = arguments.length; i < ii; ++i) {\n            var arg = arguments[i];\n\n            if (arg === null || arg === undefined) {\n              continue;\n            }\n\n            O.keys(arg).concat(filterOS(arg)).forEach(set);\n          }\n\n          return where;\n        };\n      }()\n    });\n  })(Object);\n\n  if (!Object.is) {\n    Object.is = function (x, y) {\n      if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n      } else {\n        return x !== x && y !== y;\n      }\n    };\n  }\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (global) {\n    var i;\n\n    var defineProperty = Object.defineProperty,\n        is = function is(a, b) {\n      return a === b || a !== a && b !== b;\n    };\n\n    if (typeof WeakMap == 'undefined') {\n      global.WeakMap = createCollection({\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        get: sharedGet,\n\n        has: mapHas,\n\n        set: sharedSet\n      }, true);\n    }\n\n    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {\n      var _createCollection;\n\n      global.Map = createCollection((_createCollection = {\n        'delete': sharedDelete,\n\n        has: mapHas,\n\n        get: sharedGet,\n\n        set: sharedSet,\n\n        keys: sharedKeys,\n\n        values: sharedValues,\n\n        entries: mapEntries,\n\n        forEach: sharedForEach,\n\n        clear: sharedClear\n      }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));\n    }\n\n    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {\n      var _createCollection2;\n\n      global.Set = createCollection((_createCollection2 = {\n        has: setHas,\n\n        add: sharedAdd,\n\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        keys: sharedValues,\n        values: sharedValues,\n\n        entries: setEntries,\n\n        forEach: sharedForEach\n      }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));\n    }\n\n    if (typeof WeakSet == 'undefined') {\n      global.WeakSet = createCollection({\n        'delete': sharedDelete,\n\n        add: sharedAdd,\n\n        clear: sharedClear,\n\n        has: setHas\n      }, true);\n    }\n\n    function createCollection(proto, objectOnly) {\n      function Collection(a) {\n        if (!this || this.constructor !== Collection) return new Collection(a);\n        this._keys = [];\n        this._values = [];\n        this._itp = [];\n        this.objectOnly = objectOnly;\n\n        if (a) init.call(this, a);\n      }\n\n      if (!objectOnly) {\n        defineProperty(proto, 'size', {\n          get: sharedSize\n        });\n      }\n\n      proto.constructor = Collection;\n      Collection.prototype = proto;\n\n      return Collection;\n    }\n\n    function init(a) {\n      var i;\n\n      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {\n          this.set(a[0], a[1]);\n        }, this);\n    }\n\n    function sharedDelete(key) {\n      if (this.has(key)) {\n        this._keys.splice(i, 1);\n        this._values.splice(i, 1);\n\n        this._itp.forEach(function (p) {\n          if (i < p[0]) p[0]--;\n        });\n      }\n\n      return -1 < i;\n    };\n\n    function sharedGet(key) {\n      return this.has(key) ? this._values[i] : undefined;\n    }\n\n    function has(list, key) {\n      if (this.objectOnly && key !== Object(key)) throw new TypeError(\"Invalid value used as weak collection key\");\n\n      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);\n      return -1 < i;\n    }\n\n    function setHas(value) {\n      return has.call(this, this._values, value);\n    }\n\n    function mapHas(value) {\n      return has.call(this, this._keys, value);\n    }\n\n    function sharedSet(key, value) {\n      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n      return this;\n    }\n\n    function sharedAdd(value) {\n      if (!this.has(value)) this._values.push(value);\n      return this;\n    }\n\n    function sharedClear() {\n      (this._keys || 0).length = this._values.length = 0;\n    }\n\n    function sharedKeys() {\n      return sharedIterator(this._itp, this._keys);\n    }\n\n    function sharedValues() {\n      return sharedIterator(this._itp, this._values);\n    }\n\n    function mapEntries() {\n      return sharedIterator(this._itp, this._keys, this._values);\n    }\n\n    function setEntries() {\n      return sharedIterator(this._itp, this._values, this._values);\n    }\n\n    function sharedIterator(itp, array, array2) {\n      var _ref;\n\n      var p = [0],\n          done = false;\n      itp.push(p);\n      return _ref = {}, _ref[Symbol.iterator] = function () {\n        return this;\n      }, _ref.next = function next() {\n        var v,\n            k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }, _ref;\n    }\n\n    function sharedSize() {\n      return this._values.length;\n    }\n\n    function sharedForEach(callback, context) {\n      var it = this.entries();\n      for (;;) {\n        var r = it.next();\n        if (r.done) break;\n        callback.call(context, r.value[1], r.value[0], this);\n      }\n    }\n  })(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  var bind = Function.prototype.bind;\n\n  if (typeof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect === 'undefined') {\n    aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect = {};\n  }\n\n  if (typeof Reflect.defineProperty !== 'function') {\n    Reflect.defineProperty = function (target, propertyKey, descriptor) {\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {\n        throw new TypeError('Reflect.defineProperty called on non-object');\n      }\n      try {\n        Object.defineProperty(target, propertyKey, descriptor);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n  }\n\n  if (typeof Reflect.construct !== 'function') {\n    Reflect.construct = function (Target, args) {\n      if (args) {\n        switch (args.length) {\n          case 0:\n            return new Target();\n          case 1:\n            return new Target(args[0]);\n          case 2:\n            return new Target(args[0], args[1]);\n          case 3:\n            return new Target(args[0], args[1], args[2]);\n          case 4:\n            return new Target(args[0], args[1], args[2], args[3]);\n        }\n      }\n\n      var a = [null];\n      a.push.apply(a, args);\n      return new (bind.apply(Target, a))();\n    };\n  }\n\n  if (typeof Reflect.ownKeys !== 'function') {\n    Reflect.ownKeys = function (o) {\n      return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));\n    };\n  }\n}\n\nif (typeof FEATURE_NO_ESNEXT === 'undefined') {\n\n  var emptyMetadata = Object.freeze({});\n  var metadataContainerKey = '__metadata__';\n\n  if (typeof Reflect.getOwnMetadata !== 'function') {\n    Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {\n      if (target.hasOwnProperty(metadataContainerKey)) {\n        return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];\n      }\n    };\n  }\n\n  if (typeof Reflect.defineMetadata !== 'function') {\n    Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {\n      var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};\n      var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});\n      targetContainer[metadataKey] = metadataValue;\n    };\n  }\n\n  if (typeof Reflect.metadata !== 'function') {\n    Reflect.metadata = function (metadataKey, metadataValue) {\n      return function (target, targetKey) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);\n      };\n    };\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUS81cC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXBvbHlmaWxscy9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtcG9seWZpbGxzLmpzPzQzZmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5pbXBvcnQgeyBQTEFURk9STSB9IGZyb20gJ2F1cmVsaWEtcGFsJztcblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAoZnVuY3Rpb24gKE9iamVjdCwgR09QUykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChHT1BTIGluIE9iamVjdCkgcmV0dXJuO1xuXG4gICAgdmFyIHNldERlc2NyaXB0b3IsXG4gICAgICAgIEcgPSBQTEFURk9STS5nbG9iYWwsXG4gICAgICAgIGlkID0gMCxcbiAgICAgICAgcmFuZG9tID0gJycgKyBNYXRoLnJhbmRvbSgpLFxuICAgICAgICBwcmVmaXggPSAnX19cXHgwMXN5bWJvbDonLFxuICAgICAgICBwcmVmaXhMZW5ndGggPSBwcmVmaXgubGVuZ3RoLFxuICAgICAgICBpbnRlcm5hbFN5bWJvbCA9ICdfX1xceDAxc3ltYm9sQEAnICsgcmFuZG9tLFxuICAgICAgICBEUCA9ICdkZWZpbmVQcm9wZXJ0eScsXG4gICAgICAgIERQaWVzID0gJ2RlZmluZVByb3BlcnRpZXMnLFxuICAgICAgICBHT1BOID0gJ2dldE93blByb3BlcnR5TmFtZXMnLFxuICAgICAgICBHT1BEID0gJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsXG4gICAgICAgIFBJRSA9ICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgIGdPUE4gPSBPYmplY3RbR09QTl0sXG4gICAgICAgIGdPUEQgPSBPYmplY3RbR09QRF0sXG4gICAgICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBPYmplY3RbRFBdLFxuICAgICAgICAkZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdFtEUGllc10sXG4gICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKE9iamVjdCwgR09QTiksXG4gICAgICAgIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgaE9QID0gT2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHBJRSA9IE9iamVjdFByb3RvW1BJRV0sXG4gICAgICAgIHRvU3RyaW5nID0gT2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodikge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdjspIHt9XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgICAgICBhZGRJbnRlcm5hbElmTmVlZGVkID0gZnVuY3Rpb24gYWRkSW50ZXJuYWxJZk5lZWRlZChvLCB1aWQsIGVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaE9QLmNhbGwobywgaW50ZXJuYWxTeW1ib2wpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGludGVybmFsU3ltYm9sLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb1tpbnRlcm5hbFN5bWJvbF1bJ0BAJyArIHVpZF0gPSBlbnVtZXJhYmxlO1xuICAgIH0sXG4gICAgICAgIGNyZWF0ZVdpdGhTeW1ib2xzID0gZnVuY3Rpb24gY3JlYXRlV2l0aFN5bWJvbHMocHJvdG8sIGRlc2NyaXB0b3JzKSB7XG4gICAgICB2YXIgc2VsZiA9IGNyZWF0ZShwcm90byk7XG4gICAgICBpZiAoZGVzY3JpcHRvcnMgIT09IG51bGwgJiYgKHR5cGVvZiBkZXNjcmlwdG9ycyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVzY3JpcHRvcnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZ09QTihkZXNjcmlwdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZGVzY3JpcHRvcnMsIGtleSkpIHtcbiAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIGRlc2NyaXB0b3JzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgICAgICBjb3B5QXNOb25FbnVtZXJhYmxlID0gZnVuY3Rpb24gY29weUFzTm9uRW51bWVyYWJsZShkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgbmV3RGVzY3JpcHRvciA9IGNyZWF0ZShkZXNjcmlwdG9yKTtcbiAgICAgIG5ld0Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ld0Rlc2NyaXB0b3I7XG4gICAgfSxcbiAgICAgICAgZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge30sXG4gICAgICAgIG9ubHlOb25TeW1ib2xzID0gZnVuY3Rpb24gb25seU5vblN5bWJvbHMobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgIT0gaW50ZXJuYWxTeW1ib2wgJiYgIWhPUC5jYWxsKHNvdXJjZSwgbmFtZSk7XG4gICAgfSxcbiAgICAgICAgb25seVN5bWJvbHMgPSBmdW5jdGlvbiBvbmx5U3ltYm9scyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPSBpbnRlcm5hbFN5bWJvbCAmJiBoT1AuY2FsbChzb3VyY2UsIG5hbWUpO1xuICAgIH0sXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gICAgICB2YXIgdWlkID0gJycgKyBrZXk7XG4gICAgICByZXR1cm4gb25seVN5bWJvbHModWlkKSA/IGhPUC5jYWxsKHRoaXMsIHVpZCkgJiYgdGhpc1tpbnRlcm5hbFN5bWJvbF0gJiYgdGhpc1tpbnRlcm5hbFN5bWJvbF1bJ0BAJyArIHVpZF0gOiBwSUUuY2FsbCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgICAgIHNldEFuZEdldFN5bWJvbCA9IGZ1bmN0aW9uIHNldEFuZEdldFN5bWJvbCh1aWQpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBzZXREZXNjcmlwdG9yKHRoaXMsIHVpZCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZEludGVybmFsSWZOZWVkZWQodGhpcywgdWlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCB1aWQsIGRlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuIHNvdXJjZVt1aWRdID0gZGVmaW5lUHJvcGVydHkoT2JqZWN0KHVpZCksICdjb25zdHJ1Y3RvcicsIHNvdXJjZUNvbnN0cnVjdG9yKTtcbiAgICB9LFxuICAgICAgICBfU3ltYm9sID0gZnVuY3Rpb24gX1N5bWJvbDIoZGVzY3JpcHRpb24pIHtcbiAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IEcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0QW5kR2V0U3ltYm9sKHByZWZpeC5jb25jYXQoZGVzY3JpcHRpb24gfHwgJycsIHJhbmRvbSwgKytpZCkpO1xuICAgIH0sXG4gICAgICAgIHNvdXJjZSA9IGNyZWF0ZShudWxsKSxcbiAgICAgICAgc291cmNlQ29uc3RydWN0b3IgPSB7IHZhbHVlOiBfU3ltYm9sIH0sXG4gICAgICAgIHNvdXJjZU1hcCA9IGZ1bmN0aW9uIHNvdXJjZU1hcCh1aWQpIHtcbiAgICAgIHJldHVybiBzb3VyY2VbdWlkXTtcbiAgICB9LFxuICAgICAgICAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wKG8sIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgdmFyIHVpZCA9ICcnICsga2V5O1xuICAgICAgaWYgKG9ubHlTeW1ib2xzKHVpZCkpIHtcbiAgICAgICAgc2V0RGVzY3JpcHRvcihvLCB1aWQsIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA/IGNvcHlBc05vbkVudW1lcmFibGUoZGVzY3JpcHRvcikgOiBkZXNjcmlwdG9yKTtcbiAgICAgICAgYWRkSW50ZXJuYWxJZk5lZWRlZChvLCB1aWQsICEhZGVzY3JpcHRvci5lbnVtZXJhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgICAgICAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG8pIHtcbiAgICAgIHZhciBjb2YgPSB0b1N0cmluZy5jYWxsKG8pO1xuICAgICAgbyA9IGNvZiA9PT0gJ1tvYmplY3QgU3RyaW5nXScgPyBvLnNwbGl0KCcnKSA6IE9iamVjdChvKTtcbiAgICAgIHJldHVybiBnT1BOKG8pLmZpbHRlcihvbmx5U3ltYm9scykubWFwKHNvdXJjZU1hcCk7XG4gICAgfTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSAkZGVmaW5lUHJvcGVydHk7XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBEUCwgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gJGdldE93blByb3BlcnR5U3ltYm9scztcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3QsIEdPUFMsIGRlc2NyaXB0b3IpO1xuXG4gICAgdmFyIGNhY2hlZFdpbmRvd05hbWVzID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcbiAgICB2YXIgb3JpZ2luYWxPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMobykge1xuICAgICAgaWYgKHRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyhvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoW10sIGNhY2hlZFdpbmRvd05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdPUE4obykuZmlsdGVyKG9ubHlOb25TeW1ib2xzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdCwgR09QTiwgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvLCBkZXNjcmlwdG9ycykge1xuICAgICAgdmFyIHN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGRlc2NyaXB0b3JzKTtcbiAgICAgIGlmIChzeW1ib2xzLmxlbmd0aCkge1xuICAgICAgICBrZXlzKGRlc2NyaXB0b3JzKS5jb25jYXQoc3ltYm9scykuZm9yRWFjaChmdW5jdGlvbiAodWlkKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZGVzY3JpcHRvcnMsIHVpZCkpIHtcbiAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShvLCB1aWQsIGRlc2NyaXB0b3JzW3VpZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZGVmaW5lUHJvcGVydGllcyhvLCBkZXNjcmlwdG9ycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdCwgRFBpZXMsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCBQSUUsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IF9TeW1ib2w7XG4gICAgZGVmaW5lUHJvcGVydHkoRywgJ1N5bWJvbCcsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB1aWQgPSBwcmVmaXguY29uY2F0KHByZWZpeCwga2V5LCByYW5kb20pO1xuICAgICAgcmV0dXJuIHVpZCBpbiBPYmplY3RQcm90byA/IHNvdXJjZVt1aWRdIDogc2V0QW5kR2V0U3ltYm9sKHVpZCk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShfU3ltYm9sLCAnZm9yJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIGhPUC5jYWxsKHNvdXJjZSwgc3ltYm9sKSA/IHN5bWJvbC5zbGljZShwcmVmaXhMZW5ndGggKiAyLCAtcmFuZG9tLmxlbmd0aCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShfU3ltYm9sLCAna2V5Rm9yJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIGtleSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnT1BEKG8sIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAmJiBvbmx5U3ltYm9scyhrZXkpKSB7XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobywga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBHT1BELCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAocHJvdG8sIGRlc2NyaXB0b3JzKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGNyZWF0ZShwcm90bykgOiBjcmVhdGVXaXRoU3ltYm9scyhwcm90bywgZGVzY3JpcHRvcnMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnY3JlYXRlJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gc3RyID09PSAnW29iamVjdCBTdHJpbmddJyAmJiBvbmx5U3ltYm9scyh0aGlzKSA/ICdbb2JqZWN0IFN5bWJvbF0nIDogc3RyO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sICd0b1N0cmluZycsIGRlc2NyaXB0b3IpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldERlc2NyaXB0b3IgPSBjcmVhdGUoZGVmaW5lUHJvcGVydHkoe30sIHByZWZpeCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkodGhpcywgcHJlZml4LCB7IHZhbHVlOiBmYWxzZSB9KVtwcmVmaXhdO1xuICAgICAgICB9XG4gICAgICB9KSlbcHJlZml4XSB8fCBkZWZpbmVQcm9wZXJ0eTtcbiAgICB9IGNhdGNoIChvX08pIHtcbiAgICAgIHNldERlc2NyaXB0b3IgPSBmdW5jdGlvbiBzZXREZXNjcmlwdG9yKG8sIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgcHJvdG9EZXNjcmlwdG9yID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgICAgICAgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzY3JpcHRvcik7XG4gICAgICB9O1xuICAgIH1cbiAgfSkoT2JqZWN0LCAnZ2V0T3duUHJvcGVydHlTeW1ib2xzJyk7XG5cbiAgKGZ1bmN0aW9uIChPLCBTKSB7XG4gICAgdmFyIGRQID0gTy5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgT2JqZWN0UHJvdG8gPSBPLnByb3RvdHlwZSxcbiAgICAgICAgdG9TdHJpbmcgPSBPYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgdG9TdHJpbmdUYWcgPSAndG9TdHJpbmdUYWcnLFxuICAgICAgICBkZXNjcmlwdG9yO1xuICAgIFsnaXRlcmF0b3InLCAnbWF0Y2gnLCAncmVwbGFjZScsICdzZWFyY2gnLCAnc3BsaXQnLCAnaGFzSW5zdGFuY2UnLCAnaXNDb25jYXRTcHJlYWRhYmxlJywgJ3Vuc2NvcGFibGVzJywgJ3NwZWNpZXMnLCAndG9QcmltaXRpdmUnLCB0b1N0cmluZ1RhZ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBTeW1ib2wpKSB7XG4gICAgICAgIGRQKFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogU3ltYm9sKG5hbWUpIH0pO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlIHRvU3RyaW5nVGFnOlxuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE8uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvLCAndG9TdHJpbmcnKTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgdHN0ID0gdHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdHN0ID09PSAndW5kZWZpbmVkJyA/IHN0ciA6ICdbb2JqZWN0ICcgKyB0c3QgKyAnXSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZFAoT2JqZWN0UHJvdG8sICd0b1N0cmluZycsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoT2JqZWN0LCBTeW1ib2wpO1xuXG4gIChmdW5jdGlvbiAoU2ksIEFQLCBTUCkge1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuVGhpcygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghQVBbU2ldKSBBUFtTaV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBzZWxmLmxlbmd0aCA8PSBpO1xuICAgICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiBkb25lIH0gOiB7IGRvbmU6IGRvbmUsIHZhbHVlOiBzZWxmW2krK10gfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGl0ZXJhdG9yW1NpXSA9IHJldHVyblRoaXM7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcblxuICAgIGlmICghU1BbU2ldKSBTUFtTaV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50LFxuICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHZhciBkb25lID0gbGVuZ3RoIDw9IGksXG4gICAgICAgICAgICAgIGMgPSBkb25lID8gJycgOiBmcm9tQ29kZVBvaW50KHNlbGYuY29kZVBvaW50QXQoaSkpO1xuICAgICAgICAgIGkgKz0gYy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IGRvbmUgfSA6IHsgZG9uZTogZG9uZSwgdmFsdWU6IGMgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGl0ZXJhdG9yW1NpXSA9IHJldHVyblRoaXM7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfSkoU3ltYm9sLml0ZXJhdG9yLCBBcnJheS5wcm90b3R5cGUsIFN0cmluZy5wcm90b3R5cGUpO1xufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE1ID09PSAndW5kZWZpbmVkJykge1xuXG4gIE51bWJlci5pc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9O1xuXG4gIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIHx8IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gIVwiYWJcIi5lbmRzV2l0aChcImFcIiwgMSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGxhc3RJbmRleCA9IHN1YmplY3RTdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCB8fCBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICFcImFiXCIuc3RhcnRzV2l0aChcImJcIiwgMSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwO1xuICAgIHJldHVybiB0aGlzLnN1YnN0cihwb3NpdGlvbiwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICBpZiAoIUFycmF5LmZyb20pIHtcbiAgICBBcnJheS5mcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIHRvSW50ZWdlcihpdCkge1xuICAgICAgICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gICAgICB9O1xuICAgICAgdmFyIHRvTGVuZ3RoID0gZnVuY3Rpb24gdG9MZW5ndGgoaXQpIHtcbiAgICAgICAgcmV0dXJuIGl0ID4gMCA/IE1hdGgubWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDtcbiAgICAgIH07XG4gICAgICB2YXIgaXRlckNhbGwgPSBmdW5jdGlvbiBpdGVyQ2FsbChpdGVyLCBmbiwgdmFsLCBpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbih2YWwsIGluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlci5yZXR1cm4gPT0gJ2Z1bmN0aW9uJykgaXRlci5yZXR1cm4oKTtcbiAgICAgICAgICB0aHJvdyBFO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UpIHtcbiAgICAgICAgdmFyIE8gPSBPYmplY3QoYXJyYXlMaWtlKSxcbiAgICAgICAgICAgIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5LFxuICAgICAgICAgICAgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBpdGVyRm4gPSBPW1N5bWJvbC5pdGVyYXRvcl0sXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgaXRlcmF0b3I7XG4gICAgICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IG1hcGZuLmJpbmQoYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShhcnJheUxpa2UpKSB7XG4gICAgICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gaXRlckNhbGwoaXRlcmF0b3IsIG1hcGZuLCBzdGVwLnZhbHVlLCBpbmRleCkgOiBzdGVwLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE2ID09PSAndW5kZWZpbmVkJyAmJiAhQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdpbmNsdWRlcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbiA9IHBhcnNlSW50KE8ubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHBhcnNlSW50KGFyZ3VtZW50c1sxXSkgfHwgMDtcbiAgICAgIHZhciBrO1xuICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICBrID0gbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBsZW4gKyBuO1xuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSBPW2tdO1xuICAgICAgICBpZiAoc2VhcmNoRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQgfHwgc2VhcmNoRWxlbWVudCAhPT0gc2VhcmNoRWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCAhPT0gY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZWVkc0ZpeCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzID0gT2JqZWN0LmtleXMoJ2EnKTtcbiAgICAgIG5lZWRzRml4ID0gcy5sZW5ndGggIT09IDEgfHwgc1swXSAhPT0gJzAnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5lZWRzRml4ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNGaXgpIHtcbiAgICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgaGFzRG9udEVudW1CdWcgPSAheyB0b1N0cmluZzogbnVsbCB9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgICAgICAgICAgZG9udEVudW1zID0gWyd0b1N0cmluZycsICd0b0xvY2FsZVN0cmluZycsICd2YWx1ZU9mJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnY29uc3RydWN0b3InXSxcbiAgICAgICAgICAgIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkb250RW51bXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIChPKSB7XG4gICAgaWYgKCdhc3NpZ24nIGluIE8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPLmRlZmluZVByb3BlcnR5KE8sICdhc3NpZ24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnT1BTID0gTy5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgICAgICBwSUUgPSBPLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICAgICAgZmlsdGVyT1MgPSBnT1BTID8gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gZ09QUyhzZWxmKS5maWx0ZXIocElFLCBzZWxmKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3NpZ24od2hlcmUpIHtcbiAgICAgICAgICBpZiAoZ09QUyAmJiAhKHdoZXJlIGluc3RhbmNlb2YgTykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJvYmxlbWF0aWMgU3ltYm9scycsIHdoZXJlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXQoa2V5T3JTeW1ib2wpIHtcbiAgICAgICAgICAgIHdoZXJlW2tleU9yU3ltYm9sXSA9IGFyZ1trZXlPclN5bWJvbF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChhcmcgPT09IG51bGwgfHwgYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE8ua2V5cyhhcmcpLmNvbmNhdChmaWx0ZXJPUyhhcmcpKS5mb3JFYWNoKHNldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdoZXJlO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSk7XG4gIH0pKE9iamVjdCk7XG5cbiAgaWYgKCFPYmplY3QuaXMpIHtcbiAgICBPYmplY3QuaXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTUgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICB2YXIgaTtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgaXMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYiB8fCBhICE9PSBhICYmIGIgIT09IGI7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgV2Vha01hcCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLldlYWtNYXAgPSBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcblxuICAgICAgICBjbGVhcjogc2hhcmVkQ2xlYXIsXG5cbiAgICAgICAgZ2V0OiBzaGFyZWRHZXQsXG5cbiAgICAgICAgaGFzOiBtYXBIYXMsXG5cbiAgICAgICAgc2V0OiBzaGFyZWRTZXRcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgTWFwID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBuZXcgTWFwKCkudmFsdWVzICE9PSAnZnVuY3Rpb24nIHx8ICFuZXcgTWFwKCkudmFsdWVzKCkubmV4dCkge1xuICAgICAgdmFyIF9jcmVhdGVDb2xsZWN0aW9uO1xuXG4gICAgICBnbG9iYWwuTWFwID0gY3JlYXRlQ29sbGVjdGlvbigoX2NyZWF0ZUNvbGxlY3Rpb24gPSB7XG4gICAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG5cbiAgICAgICAgaGFzOiBtYXBIYXMsXG5cbiAgICAgICAgZ2V0OiBzaGFyZWRHZXQsXG5cbiAgICAgICAgc2V0OiBzaGFyZWRTZXQsXG5cbiAgICAgICAga2V5czogc2hhcmVkS2V5cyxcblxuICAgICAgICB2YWx1ZXM6IHNoYXJlZFZhbHVlcyxcblxuICAgICAgICBlbnRyaWVzOiBtYXBFbnRyaWVzLFxuXG4gICAgICAgIGZvckVhY2g6IHNoYXJlZEZvckVhY2gsXG5cbiAgICAgICAgY2xlYXI6IHNoYXJlZENsZWFyXG4gICAgICB9LCBfY3JlYXRlQ29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdID0gbWFwRW50cmllcywgX2NyZWF0ZUNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFNldCA9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgbmV3IFNldCgpLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJyB8fCAhbmV3IFNldCgpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgIHZhciBfY3JlYXRlQ29sbGVjdGlvbjI7XG5cbiAgICAgIGdsb2JhbC5TZXQgPSBjcmVhdGVDb2xsZWN0aW9uKChfY3JlYXRlQ29sbGVjdGlvbjIgPSB7XG4gICAgICAgIGhhczogc2V0SGFzLFxuXG4gICAgICAgIGFkZDogc2hhcmVkQWRkLFxuXG4gICAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG5cbiAgICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuXG4gICAgICAgIGtleXM6IHNoYXJlZFZhbHVlcyxcbiAgICAgICAgdmFsdWVzOiBzaGFyZWRWYWx1ZXMsXG5cbiAgICAgICAgZW50cmllczogc2V0RW50cmllcyxcblxuICAgICAgICBmb3JFYWNoOiBzaGFyZWRGb3JFYWNoXG4gICAgICB9LCBfY3JlYXRlQ29sbGVjdGlvbjJbU3ltYm9sLml0ZXJhdG9yXSA9IHNoYXJlZFZhbHVlcywgX2NyZWF0ZUNvbGxlY3Rpb24yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBXZWFrU2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuV2Vha1NldCA9IGNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgICAnZGVsZXRlJzogc2hhcmVkRGVsZXRlLFxuXG4gICAgICAgIGFkZDogc2hhcmVkQWRkLFxuXG4gICAgICAgIGNsZWFyOiBzaGFyZWRDbGVhcixcblxuICAgICAgICBoYXM6IHNldEhhc1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihwcm90bywgb2JqZWN0T25seSkge1xuICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbihhKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCB0aGlzLmNvbnN0cnVjdG9yICE9PSBDb2xsZWN0aW9uKSByZXR1cm4gbmV3IENvbGxlY3Rpb24oYSk7XG4gICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuX2l0cCA9IFtdO1xuICAgICAgICB0aGlzLm9iamVjdE9ubHkgPSBvYmplY3RPbmx5O1xuXG4gICAgICAgIGlmIChhKSBpbml0LmNhbGwodGhpcywgYSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0T25seSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm90bywgJ3NpemUnLCB7XG4gICAgICAgICAgZ2V0OiBzaGFyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb247XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGEpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAodGhpcy5hZGQpIGEuZm9yRWFjaCh0aGlzLmFkZCwgdGhpcyk7ZWxzZSBhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB0aGlzLnNldChhWzBdLCBhWzFdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkRGVsZXRlKGtleSkge1xuICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgdGhpcy5faXRwLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBpZiAoaSA8IHBbMF0pIHBbMF0tLTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMSA8IGk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNoYXJlZEdldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdmFsdWVzW2ldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhcyhsaXN0LCBrZXkpIHtcbiAgICAgIGlmICh0aGlzLm9iamVjdE9ubHkgJiYga2V5ICE9PSBPYmplY3Qoa2V5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdmFsdWUgdXNlZCBhcyB3ZWFrIGNvbGxlY3Rpb24ga2V5XCIpO1xuXG4gICAgICBpZiAoa2V5ICE9IGtleSB8fCBrZXkgPT09IDApIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gJiYgIWlzKGxpc3RbaV0sIGtleSk7KSB7fSBlbHNlIGkgPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgIHJldHVybiAtMSA8IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywgdGhpcy5fdmFsdWVzLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywgdGhpcy5fa2V5cywgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZFNldChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdmFsdWVzW2ldID0gdmFsdWUgOiB0aGlzLl92YWx1ZXNbdGhpcy5fa2V5cy5wdXNoKGtleSkgLSAxXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkQWRkKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkQ2xlYXIoKSB7XG4gICAgICAodGhpcy5fa2V5cyB8fCAwKS5sZW5ndGggPSB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRLZXlzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fa2V5cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fdmFsdWVzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZEl0ZXJhdG9yKGl0cCwgYXJyYXksIGFycmF5Mikge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHZhciBwID0gWzBdLFxuICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgIGl0cC5wdXNoKHApO1xuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIF9yZWYubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciB2LFxuICAgICAgICAgICAgayA9IHBbMF07XG4gICAgICAgIGlmICghZG9uZSAmJiBrIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgdiA9IGFycmF5MiA/IFthcnJheVtrXSwgYXJyYXkyW2tdXSA6IGFycmF5W2tdO1xuICAgICAgICAgIHBbMF0rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICBpdHAuc3BsaWNlKGl0cC5pbmRleE9mKHApLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBkb25lLCB2YWx1ZTogdiB9O1xuICAgICAgfSwgX3JlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkRm9yRWFjaChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgdmFyIGl0ID0gdGhpcy5lbnRyaWVzKCk7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciByID0gaXQubmV4dCgpO1xuICAgICAgICBpZiAoci5kb25lKSBicmVhaztcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCByLnZhbHVlWzFdLCByLnZhbHVlWzBdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKFBMQVRGT1JNLmdsb2JhbCk7XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTUgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuICBpZiAodHlwZW9mIFBMQVRGT1JNLmdsb2JhbC5SZWZsZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgIFBMQVRGT1JNLmdsb2JhbC5SZWZsZWN0ID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmICgodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGFyZ2V0KSkgPT09ICdvYmplY3QnID8gdGFyZ2V0ID09PSBudWxsIDogdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWZsZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgUmVmbGVjdC5jb25zdHJ1Y3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmNvbnN0cnVjdCA9IGZ1bmN0aW9uIChUYXJnZXQsIGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsIGEpKSgpO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3Qub3duS2V5cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3Qub3duS2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobykpO1xuICAgIH07XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTTkVYVCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICB2YXIgZW1wdHlNZXRhZGF0YSA9IE9iamVjdC5mcmVlemUoe30pO1xuICB2YXIgbWV0YWRhdGFDb250YWluZXJLZXkgPSAnX19tZXRhZGF0YV9fJztcblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUNvbnRhaW5lcktleSkpIHtcbiAgICAgICAgcmV0dXJuICh0YXJnZXRbbWV0YWRhdGFDb250YWluZXJLZXldW3RhcmdldEtleV0gfHwgZW1wdHlNZXRhZGF0YSlbbWV0YWRhdGFLZXldO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgdmFyIG1ldGFkYXRhQ29udGFpbmVyID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG1ldGFkYXRhQ29udGFpbmVyS2V5KSA/IHRhcmdldFttZXRhZGF0YUNvbnRhaW5lcktleV0gOiB0YXJnZXRbbWV0YWRhdGFDb250YWluZXJLZXldID0ge307XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gbWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSB8fCAobWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSA9IHt9KTtcbiAgICAgIHRhcmdldENvbnRhaW5lclttZXRhZGF0YUtleV0gPSBtZXRhZGF0YVZhbHVlO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0Lm1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///Q/5p\n");

/***/ })

}]);